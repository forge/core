head[head(Index: )plain(lib/coderay/token_classes.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/token_classes.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/token_classes.rb)plain(	(revision 500\))]
change[change(@@)plain( -4,6 +4,7 )change(@@)]
       ident(h)operator([)ident(k)operator(]) operator(=) ident(k)operator(.)ident(to_s)
     keyword(end)
     constant(ClassOfKind)operator(.)ident(update) ident(with) operator(=) operator({)
insert[insert(+)      symbol(:annotation) operator(=)operator(>) string<delimiter(')content(at)delimiter(')>operator(,)]
       symbol(:attribute_name) operator(=)operator(>) string<delimiter(')content(an)delimiter(')>operator(,)
       symbol(:attribute_name_fat) operator(=)operator(>) string<delimiter(')content(af)delimiter(')>operator(,)
       symbol(:attribute_value) operator(=)operator(>) string<delimiter(')content(av)delimiter(')>operator(,)
change[change(@@)plain( -14,12 +15,15 )change(@@)]
       symbol(:class_variable) operator(=)operator(>) string<delimiter(')content(cv)delimiter(')>operator(,)
       symbol(:color) operator(=)operator(>) string<delimiter(')content(cr)delimiter(')>operator(,)
       symbol(:comment) operator(=)operator(>) string<delimiter(')content(c)delimiter(')>operator(,)
insert[insert(+)      symbol(:complex) operator(=)operator(>) string<delimiter(')content(cm)delimiter(')>operator(,)]
       symbol(:constant) operator(=)operator(>) string<delimiter(')content(co)delimiter(')>operator(,)
       symbol(:content) operator(=)operator(>) string<delimiter(')content(k)delimiter(')>operator(,)
insert[insert(+)      symbol(:decorator) operator(=)operator(>) string<delimiter(')content(de)delimiter(')>operator(,)]
       symbol(:definition) operator(=)operator(>) string<delimiter(')content(df)delimiter(')>operator(,)
       symbol(:delimiter) operator(=)operator(>) string<delimiter(')content(dl)delimiter(')>operator(,)
       symbol(:directive) operator(=)operator(>) string<delimiter(')content(di)delimiter(')>operator(,)
       symbol(:doc) operator(=)operator(>) string<delimiter(')content(do)delimiter(')>operator(,)
insert[insert(+)      symbol(:doctype) operator(=)operator(>) string<delimiter(')content(dt)delimiter(')>operator(,)]
       symbol(:doc_string) operator(=)operator(>) string<delimiter(')content(ds)delimiter(')>operator(,)
       symbol(:entity) operator(=)operator(>) string<delimiter(')content(en)delimiter(')>operator(,)
       symbol(:error) operator(=)operator(>) string<delimiter(')content(er)delimiter(')>operator(,)
change[change(@@)plain( -29,12 +33,16 )change(@@)]
       symbol(:function) operator(=)operator(>) string<delimiter(')content(fu)delimiter(')>operator(,)
       symbol(:global_variable) operator(=)operator(>) string<delimiter(')content(gv)delimiter(')>operator(,)
       symbol(:hex) operator(=)operator(>) string<delimiter(')content(hx)delimiter(')>operator(,)
insert[insert(+)      symbol(:imaginary) operator(=)operator(>) string<delimiter(')content(cm)delimiter(')>operator(,)]
insert[insert(+)      symbol(:important) operator(=)operator(>) string<delimiter(')content(im)delimiter(')>operator(,)]
       symbol(:include) operator(=)operator(>) string<delimiter(')content(ic)delimiter(')>operator(,)
       symbol(:inline) operator(=)operator(>) string<delimiter(')content(il)delimiter(')>operator(,)
       symbol(:inline_delimiter) operator(=)operator(>) string<delimiter(')content(idl)delimiter(')>operator(,)
       symbol(:instance_variable) operator(=)operator(>) string<delimiter(')content(iv)delimiter(')>operator(,)
       symbol(:integer) operator(=)operator(>) string<delimiter(')content(i)delimiter(')>operator(,)
       symbol(:interpreted) operator(=)operator(>) string<delimiter(')content(in)delimiter(')>operator(,)
insert[insert(+)      symbol(:keyword) operator(=)operator(>) string<delimiter(')content(kw)delimiter(')>operator(,)]
insert[insert(+)      symbol(:key) operator(=)operator(>) string<delimiter(')content(ke)delimiter(')>operator(,)]
       symbol(:label) operator(=)operator(>) string<delimiter(')content(la)delimiter(')>operator(,)
       symbol(:local_variable) operator(=)operator(>) string<delimiter(')content(lv)delimiter(')>operator(,)
       symbol(:modifier) operator(=)operator(>) string<delimiter(')content(mod)delimiter(')>operator(,)
change[change(@@)plain( -44,6 +52,7 )change(@@)]
       symbol(:pre_type) operator(=)operator(>) string<delimiter(')content(pt)delimiter(')>operator(,)
       symbol(:predefined) operator(=)operator(>) string<delimiter(')content(pd)delimiter(')>operator(,)
       symbol(:preprocessor) operator(=)operator(>) string<delimiter(')content(pp)delimiter(')>operator(,)
insert[insert(+)      symbol(:pseudo_class) operator(=)operator(>) string<delimiter(')content(ps)delimiter(')>operator(,)]
       symbol(:regexp) operator(=)operator(>) string<delimiter(')content(rx)delimiter(')>operator(,)
       symbol(:reserved) operator(=)operator(>) string<delimiter(')content(r)delimiter(')>operator(,)
       symbol(:shell) operator(=)operator(>) string<delimiter(')content(sh)delimiter(')>operator(,)
change[change(@@)plain( -54,7 +63,13 )change(@@)]
       symbol(:tag_special) operator(=)operator(>) string<delimiter(')content(ts)delimiter(')>operator(,)
       symbol(:type) operator(=)operator(>) string<delimiter(')content(ty)delimiter(')>operator(,)
       symbol(:variable) operator(=)operator(>) string<delimiter(')content(v)delimiter(')>operator(,)
insert[insert(+)      symbol(:value) operator(=)operator(>) string<delimiter(')content(vl)delimiter(')>operator(,)]
       symbol(:xml_text) operator(=)operator(>) string<delimiter(')content(xt)delimiter(')>operator(,)
insert[insert(+)      ]
insert[insert(+)      symbol(:insert) operator(=)operator(>) string<delimiter(')content(ins)delimiter(')>operator(,)]
insert[insert(+)      symbol(:delete) operator(=)operator(>) string<delimiter(')content(del)delimiter(')>operator(,)]
insert[insert(+)      symbol(:change) operator(=)operator(>) string<delimiter(')content(chg)delimiter(')>operator(,)]
insert[insert(+)      symbol(:head) operator(=)operator(>) string<delimiter(')content(head)delimiter(')>operator(,)]
 
       symbol(:ident) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,) comment(# 'id')
       comment(#:operator => 'op',)
change[change(@@)plain( -62,7 +77,7 )change(@@)]
       symbol(:space) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)  comment(# 'sp')
       symbol(:plain) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)
     operator(})
delete[delete(-)    constant(ClassOfKind)operator([)symbol(:)eyecatcher<symbol(procedure)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:)>symbol(method)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:function)operator(])]
insert[insert(+)    constant(ClassOfKind)operator([)symbol(:)symbol(method)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:function)operator(])]
     constant(ClassOfKind)operator([)symbol(:open)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:close)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])
     constant(ClassOfKind)operator([)symbol(:nesting_delimiter)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])
     constant(ClassOfKind)operator([)symbol(:escape)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])
head[head(Index: )plain(lib/coderay/encoder.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoder.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoder.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,5 +1,3 )change(@@)]
delete[delete(-)ident(require) string<delimiter(")content(stringio)delimiter(")>]
delete[delete(-)]
 keyword(module) class(CodeRay)
 
   comment(# This module holds the Encoder class and its subclasses.)
change[change(@@)plain( -126,36 +124,66 )change(@@)]
         instance_variable(@out) operator(=) string<delimiter(')delimiter(')>
       keyword(end)
 
delete[delete(-)      comment(# Called with +)eyecatcher<comment(tex)>comment(t+ and +kind+ of the currently scanned token.)]
insert[insert(+)      comment(# Called with +)eyecatcher<comment(conten)>comment(t+ and +kind+ of the currently scanned token.)]
       comment(# For simple scanners, it's enougth to implement this method.)
       comment(#)
       comment(# By default, it calls text_token or block_token, depending on)
delete[delete(-)      comment(# whether +)eyecatcher<comment(tex)>comment(t+ is a String.)]
delete[delete(-)      keyword(def) method(token) eyecatcher<ident(tex)>ident(t)operator(,) ident(kind)]
delete[delete(-)        eyecatcher<ident(out)> operator(=)]
delete[delete(-)          keyword(if) eyecatcher<ident(text)operator(.)ident(is_a?) operator(::)constant(String)  comment(# Ruby 1.9: :open.is_a? )>comment(String)]
delete[delete(-)            ident(text_token) eyecatcher<ident(tex)>ident(t)operator(,) ident(kind)]
delete[delete(-)          keyword(elsif) eyecatcher<ident(tex)>ident(t)operator(.)ident(is_a?) operator(::)constant(Symbol)]
delete[delete(-)            ident(block_token) eyecatcher<ident(tex)>ident(t)operator(,) ident(kind)]
insert[insert(+)      comment(# whether +)eyecatcher<comment(conten)>comment(t+ is a String.)]
insert[insert(+)      keyword(def) method(token) eyecatcher<ident(conten)>ident(t)operator(,) ident(kind)]
insert[insert(+)        eyecatcher<ident(encoded_token)> operator(=)]
insert[insert(+)          keyword(if) eyecatcher<ident(content)operator(.)ident(is_a?) operator(::)>constant(String)]
insert[insert(+)            ident(text_token) eyecatcher<ident(conten)>ident(t)operator(,) ident(kind)]
insert[insert(+)          keyword(elsif) eyecatcher<ident(conten)>ident(t)operator(.)ident(is_a?) operator(::)constant(Symbol)]
insert[insert(+)            ident(block_token) eyecatcher<ident(conten)>ident(t)operator(,) ident(kind)]
           keyword(else)
delete[delete(-)            ident(raise) string<delimiter(')content(Unknown token )>eyecatcher<string<content(text type: %p)delimiter(')> operator(%) ident(text)>]
insert[insert(+)            ident(raise) string<delimiter(')content(Unknown token )>eyecatcher<string<content(content type: %p)delimiter(')> operator(%) operator([)ident(content)operator(])>]
           keyword(end)
delete[delete(-)        eyecatcher<instance_variable(@out) operator(<<) ident(out) keyword(if) keyword(defined?)operator(()instance_variable(@out)operator(\)) operator(&&) instance_variable(@out)>]
insert[insert(+)        eyecatcher<ident(append_encoded_token_to_output) ident(encoded_token)>]
       keyword(end)
delete[delete(-)]
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(append_encoded_token_to_output) ident(encoded_token)]
insert[insert(+)        instance_variable(@out) operator(<<) ident(encoded_token) keyword(if) ident(encoded_token) operator(&&) keyword(defined?)operator(()instance_variable(@out)operator(\)) operator(&&) instance_variable(@out)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each text token ([text, kind]\), where text is a String.)]
       keyword(def) method(text_token) ident(text)operator(,) ident(kind)
       keyword(end)
delete[delete(-)]
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each block (non-text\) token ([action, kind]\),)]
insert[insert(+)      comment(# where +action+ is a Symbol.)]
insert[insert(+)      comment(# )]
insert[insert(+)      comment(# Calls open_token, close_token, begin_line, and end_line according to)]
insert[insert(+)      comment(# the value of +action+.)]
       keyword(def) method(block_token) ident(action)operator(,) ident(kind)
         keyword(case) ident(action)
         keyword(when) symbol(:open)
           ident(open_token) ident(kind)
         keyword(when) symbol(:close)
           ident(close_token) ident(kind)
insert[insert(+)        keyword(when) symbol(:begin_line)]
insert[insert(+)          ident(begin_line) ident(kind)]
insert[insert(+)        keyword(when) symbol(:end_line)]
insert[insert(+)          ident(end_line) ident(kind)]
         keyword(else)
           ident(raise) string<delimiter(')content(unknown block action: %p)delimiter(')> operator(%) ident(action)
         keyword(end)
       keyword(end)
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each block token at the start of the block ([:open, kind]\).)]
insert[insert(+)      keyword(def) method(open_token) ident(kind)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each block token end of the block ([:close, kind]\).)]
insert[insert(+)      keyword(def) method(close_token) ident(kind)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each line token block at the start of the line ([:begin_line, kind]\).)]
insert[insert(+)      keyword(def) method(begin_line) ident(kind)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      comment(# Called for each line token block at the end of the line ([:end_line, kind]\).)]
insert[insert(+)      keyword(def) method(end_line) ident(kind)]
insert[insert(+)      keyword(end)]
 
       comment(# Called with merged options after encoding starts.)
       comment(# The return value is the result of encoding, typically @out.)
change[change(@@)plain( -167,9 +195,16 )change(@@)]
       comment(#)
       comment(# The already created +tokens+ object must be used; it can be a)
       comment(# TokenStream or a Tokens object.)
delete[delete(-)      keyword(def) method(compile) ident(tokens)operator(,) ident(options)]
delete[delete(-)        ident(tokens)operator(.)ident(each) operator({) operator(|)ident(text)operator(,) ident(kind)operator(|) ident(token) ident(text)operator(,) ident(kind) operator(})  comment(# FIXME for Ruby 1.9?)]
delete[delete(-)        comment(#tokens.each(&self\))]
insert[insert(+)      keyword(if) predefined_constant(RUBY_VERSION) operator(>)operator(=) string<delimiter(')content(1.9)delimiter(')>]
insert[insert(+)        keyword(def) method(compile) ident(tokens)operator(,) ident(options)]
insert[insert(+)          keyword(for) ident(text)operator(,) ident(kind) keyword(in) ident(tokens)]
insert[insert(+)            ident(token) ident(text)operator(,) ident(kind)]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)]
insert[insert(+)      keyword(else)]
insert[insert(+)        keyword(def) method(compile) ident(tokens)operator(,) ident(options)]
insert[insert(+)          ident(tokens)operator(.)ident(each)operator(()operator(&)predefined_constant(self)operator(\))]
insert[insert(+)        keyword(end)]
       keyword(end)
 
     keyword(end)
head[head(Index: )plain(lib/coderay/encoders/tokens.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/tokens.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/tokens.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,44 +0,0 )change(@@)]
delete[delete(-)keyword(module) class(CodeRay)]
delete[delete(-)keyword(module) class(Encoders)]
delete[delete(-)]
delete[delete(-)  comment(# The Tokens encoder converts the tokens to a simple)]
delete[delete(-)  comment(# readable format. It doesn't use colors and is mainly)]
delete[delete(-)  comment(# intended for console output.)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# The tokens are converted with Tokens.write_token.)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# The format is:)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(#   <token-kind> \\t <escaped token-text> \\n)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# Example:)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(#   require 'coderay')]
delete[delete(-)  comment(#   puts CodeRay.scan("puts 3 + 4", :ruby\).tokens)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# prints:)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(#   ident   puts)]
delete[delete(-)  comment(#   space)]
delete[delete(-)  comment(#   integer 3)]
delete[delete(-)  comment(#   space)]
delete[delete(-)  comment(#   operator        +)]
delete[delete(-)  comment(#   space)]
delete[delete(-)  comment(#   integer 4)]
delete[delete(-)  comment(#)]
delete[delete(-)  keyword(class) class(Tokens) operator(<) constant(Encoder)]
delete[delete(-)]
delete[delete(-)    ident(include) constant(Streamable)]
delete[delete(-)    ident(register_for) symbol(:tokens)]
delete[delete(-)]
delete[delete(-)    constant(FILE_EXTENSION) operator(=) string<delimiter(')content(tok)delimiter(')>]
delete[delete(-)]
delete[delete(-)  ident(protected)]
delete[delete(-)    keyword(def) method(token) ident(text)operator(,) ident(kind)]
delete[delete(-)      instance_variable(@out) operator(<<) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(write_token)operator(()ident(text)operator(,) ident(kind)operator(\))]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)keyword(end)]
delete[delete(-)keyword(end)]
head[head(Index: )plain(lib/coderay/encoders/div.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/div.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/div.rb)plain(	(revision 500\))]
change[change(@@)plain( -9,10 +9,9 )change(@@)]
 
     ident(register_for) symbol(:div)
 
delete[delete(-)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher<operator(()operator({)>]
insert[insert(+)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher< \>]
       symbol(:css) operator(=)operator(>) symbol(:style)operator(,)
delete[delete(-)      symbol(:wrap) operator(=)operator(>) symbol(:div)operator(,)]
delete[delete(-)    operator(})operator(\))]
insert[insert(+)      symbol(:wrap) operator(=)operator(>) symbol(:div)]
 
   keyword(end)
 
head[head(Index: )plain(lib/coderay/encoders/text.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/text.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/text.rb)plain(	(revision 500\))]
change[change(@@)plain( -14,16 +14,16 )change(@@)]
 
   ident(protected)
     keyword(def) method(setup) ident(options)
delete[delete(-)      eyecatcher<instance_variable(@out) operator(=) string<delimiter(')delimiter(')>>]
insert[insert(+)      eyecatcher<keyword(super)>]
       instance_variable(@sep) operator(=) ident(options)operator([)symbol(:separator)operator(])
     keyword(end)
 
delete[delete(-)    keyword(def) method(t)method(oken) ident(text)operator(,) ident(kind)]
delete[delete(-)      eyecatcher<instance_variable(@out) operator(<<) ident(text) operator(+) instance_variable(@sep) keyword(if) ident(text)operator(.)ident(is_a?) operator(::)constant(String)>]
insert[insert(+)    keyword(def) method(t)eyecatcher<method(ext_t)>method(oken) ident(text)operator(,) ident(kind)]
insert[insert(+)      eyecatcher<ident(text) operator(+) instance_variable(@sep)>]
     keyword(end)
 
     keyword(def) method(finish) ident(options)
delete[delete(-)      eyecatcher<instance_variable(@out)>operator(.)ident(chomp) instance_variable(@sep)]
insert[insert(+)      eyecatcher<keyword(super)>operator(.)ident(chomp) instance_variable(@sep)]
     keyword(end)
 
   keyword(end)
head[head(Index: )plain(lib/coderay/encoders/filter.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/filter.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/filter.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,75 )change(@@)]
insert[insert(+)operator(()global_variable($:)operator(.)ident(unshift) string<delimiter(')content(../..)delimiter(')>operator(;) ident(require) string<delimiter(')content(coderay)delimiter(')>operator(\)) keyword(unless) keyword(defined?) constant(CodeRay)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Encoders)]
insert[insert(+)  ]
insert[insert(+)  keyword(class) class(Filter) operator(<) constant(Encoder)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:filter)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    keyword(def) method(setup) ident(options)]
insert[insert(+)      instance_variable(@out) operator(=) constant(Tokens)operator(.)ident(new)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(text_token) ident(text)operator(,) ident(kind)]
insert[insert(+)      operator([)ident(text)operator(,) ident(kind)operator(]) keyword(if) ident(include_text_token?) ident(text)operator(,) ident(kind)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(include_text_token?) ident(text)operator(,) ident(kind)]
insert[insert(+)      predefined_constant(true)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(block_token) ident(action)operator(,) ident(kind)]
insert[insert(+)      operator([)ident(action)operator(,) ident(kind)operator(]) keyword(if) ident(include_block_token?) ident(action)operator(,) ident(kind)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(include_block_token?) ident(action)operator(,) ident(kind)]
insert[insert(+)      predefined_constant(true)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(FilterTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_creation)]
insert[insert(+)    ident(assert) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Filter) operator(<) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Encoder)]
insert[insert(+)    ident(filter) operator(=) predefined_constant(nil)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(filter) operator(=) constant(CodeRay)operator(.)ident(encoder) symbol(:filter)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_kind_of) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Encoder)operator(,) ident(filter)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_text_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    integer(10)operator(.)ident(times) keyword(do) operator(|)ident(i)operator(|)]
insert[insert(+)      ident(tokens) operator(<<) operator([)ident(i)operator(.)ident(to_s)operator(,) symbol(:index)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Filter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(\))]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(,) ident(tokens)operator(.)ident(filter)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_block_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    integer(10)operator(.)ident(times) keyword(do) operator(|)ident(i)operator(|)]
insert[insert(+)      ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:index)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)ident(i)operator(.)ident(to_s)operator(,) symbol(:content)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:index)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Filter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(\))]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(,) ident(tokens)operator(.)ident(filter)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/encoders/debug.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/debug.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/debug.rb)plain(	(revision 500\))]
change[change(@@)plain( -32,9 +32,17 )change(@@)]
     keyword(end)
 
     keyword(def) method(close_token) ident(kind)
delete[delete(-)      string<>eyecatcher<string<delimiter(")content(>)delimiter(")>>]
insert[insert(+)      string<>eyecatcher<string<delimiter(')content(>)delimiter(')>>]
     keyword(end)
 
insert[insert(+)    keyword(def) method(begin_line) ident(kind)]
insert[insert(+)      string<delimiter(")inline<inline_delimiter(#{)ident(kind)inline_delimiter(})>content([)delimiter(")>]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    keyword(def) method(end_line) ident(kind)]
insert[insert(+)      string<delimiter(')content(])delimiter(')>]
insert[insert(+)    keyword(end)]
insert[insert(+)]
   keyword(end)
 
 keyword(end)
head[head(Index: )plain(lib/coderay/encoders/lines_of_code.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/lines_of_code.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/lines_of_code.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,90 )change(@@)]
insert[insert(+)operator(()global_variable($:)operator(.)ident(unshift) string<delimiter(')content(../..)delimiter(')>operator(;) ident(require) string<delimiter(')content(coderay)delimiter(')>operator(\)) keyword(unless) keyword(defined?) constant(CodeRay)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Encoders)]
insert[insert(+)  ]
insert[insert(+)  comment(# Counts the LoC (Lines of Code\). Returns an Integer >= 0.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Alias: :loc)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Everything that is not comment, markup, doctype/shebang, or an empty line,)]
insert[insert(+)  comment(# is considered to be code.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# For example,)]
insert[insert(+)  comment(# * HTML files not containing JavaScript have 0 LoC)]
insert[insert(+)  comment(# * in a Java class without comments, LoC is the number of non-empty lines)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# A Scanner class should define the token kinds that are not code in the)]
insert[insert(+)  comment(# KINDS_NOT_LOC constant, which defaults to [:comment, :doctype].)]
insert[insert(+)  keyword(class) class(LinesOfCode) operator(<) constant(Encoder)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:lines_of_code)]
insert[insert(+)    ]
insert[insert(+)    constant(NON_EMPTY_LINE) operator(=) regexp<delimiter(/)content(^)char(\\s)content(*)char(\\S)content(.*$)delimiter(/)>]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(compile) ident(tokens)operator(,) ident(options)]
insert[insert(+)      keyword(if) ident(scanner) operator(=) ident(tokens)operator(.)ident(scanner)]
insert[insert(+)        ident(kinds_not_loc) operator(=) ident(scanner)operator(.)ident(class)operator(::)constant(KINDS_NOT_LOC)]
insert[insert(+)      keyword(else)]
insert[insert(+)        ident(warn) constant(ArgumentError)operator(,) string<delimiter(')content(Tokens have no scanner.)delimiter(')> keyword(if) global_variable($DEBUG)]
insert[insert(+)        ident(kinds_not_loc) operator(=) constant(CodeRay)operator(::)constant(Scanners)operator(::)constant(Scanner)operator(::)constant(KINDS_NOT_LOC)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ident(code) operator(=) ident(tokens)operator(.)ident(token_class_filter) symbol(:exclude) operator(=)operator(>) ident(kinds_not_loc)]
insert[insert(+)      instance_variable(@loc) operator(=) ident(code)operator(.)ident(text)operator(.)ident(scan)operator(()constant(NON_EMPTY_LINE)operator(\))operator(.)ident(size)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(finish) ident(options)]
insert[insert(+)      instance_variable(@loc)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(LinesOfCodeTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_creation)]
insert[insert(+)    ident(assert) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(LinesOfCode) operator(<) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Encoder)]
insert[insert(+)    ident(filter) operator(=) predefined_constant(nil)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(filter) operator(=) constant(CodeRay)operator(.)ident(encoder) symbol(:loc)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_kind_of) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(LinesOfCode)operator(,) ident(filter)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(filter) operator(=) constant(CodeRay)operator(.)ident(encoder) symbol(:lines_of_code)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_kind_of) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(LinesOfCode)operator(,) ident(filter)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_lines_of_code)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(.)ident(scan) string<delimiter(<<-RUBY)>operator(,) symbol(:ruby)]
insert[insert(+)string<content(#!/usr/bin/env ruby)>]
insert[insert(+)]
insert[insert(+)string<content(# a minimal Ruby program)>]
insert[insert(+)string<content(puts "Hello world!")>]
insert[insert(+)string<delimiter(    RUBY)>]
insert[insert(+)    ident(assert_equal) integer(1)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(LinesOfCode)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(\))]
insert[insert(+)    ident(assert_equal) integer(1)operator(,) ident(tokens)operator(.)ident(lines_of_code)]
insert[insert(+)    ident(assert_equal) integer(1)operator(,) ident(tokens)operator(.)ident(loc)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_block_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    ident(tokens) operator(<<) operator([)string<delimiter(")content(Hello)char(\\n)delimiter(")>operator(,) symbol(:world)operator(])]
insert[insert(+)    ident(tokens) operator(<<) operator([)string<delimiter(")content(Hello)char(\\n)delimiter(")>operator(,) symbol(:space)operator(])]
insert[insert(+)    ident(tokens) operator(<<) operator([)string<delimiter(")content(Hello)char(\\n)delimiter(")>operator(,) symbol(:comment)operator(])]
insert[insert(+)    ident(assert_equal) integer(2)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(LinesOfCode)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(\))]
insert[insert(+)    ident(assert_equal) integer(2)operator(,) ident(tokens)operator(.)ident(lines_of_code)]
insert[insert(+)    ident(assert_equal) integer(2)operator(,) ident(tokens)operator(.)ident(loc)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/encoders/xml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/xml.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/xml.rb)plain(	(revision 500\))]
change[change(@@)plain( -29,6 +29,7 )change(@@)]
     keyword(end)
 
     keyword(def) method(finish) ident(options)
insert[insert(+)      instance_variable(@out) operator(=) string<delimiter(')delimiter(')>]
       instance_variable(@doc)operator(.)ident(write) instance_variable(@out)operator(,) ident(options)operator([)symbol(:pretty)operator(])operator(,) ident(options)operator([)symbol(:transitive)operator(])operator(,) predefined_constant(true)
       instance_variable(@out)
     keyword(end)
head[head(Index: )plain(lib/coderay/encoders/span.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/span.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/span.rb)plain(	(revision 500\))]
change[change(@@)plain( -9,10 +9,9 )change(@@)]
 
     ident(register_for) symbol(:span)
 
delete[delete(-)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher<operator(()operator({)>]
insert[insert(+)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher< \>]
       symbol(:css) operator(=)operator(>) symbol(:style)operator(,)
delete[delete(-)      symbol(:wrap) operator(=)operator(>) symbol(:span)operator(,)]
delete[delete(-)    operator(})operator(\))]
insert[insert(+)      symbol(:wrap) operator(=)operator(>) symbol(:span)]
 
   keyword(end)
 
head[head(Index: )plain(lib/coderay/encoders/html/output.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html/output.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/html/output.rb)plain(	(revision 500\))]
change[change(@@)plain( -86,6 +86,11 )change(@@)]
         constant(Template)operator(.)ident(wrap!) predefined_constant(self)operator(,) ident(template)operator(,) string<delimiter(')content(CONTENT)delimiter(')>
         predefined_constant(self)
       keyword(end)
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(apply_title!) ident(title)]
insert[insert(+)        predefined_constant(self)operator(.)ident(sub!)operator(()regexp<delimiter(/)content((<title>\)(<)char(\\/)content(title>\))delimiter(/)>operator(\)) operator({) global_variable($1) operator(+) ident(title) operator(+) global_variable($2) operator(})]
insert[insert(+)        predefined_constant(self)]
insert[insert(+)      keyword(end)]
 
       keyword(def) method(wrap!) ident(element)operator(,) operator(*)ident(args)
         keyword(return) predefined_constant(self) keyword(if) keyword(not) ident(element) keyword(or) ident(element) operator(==) ident(wrapped_in)
change[change(@@)plain( -100,6 +105,10 )change(@@)]
           ident(wrap!) symbol(:div) keyword(if) ident(wrapped_in?) predefined_constant(nil)
           ident(raise) string<delimiter(")content(Can't wrap %p in %p)delimiter(")> operator(%) operator([)ident(wrapped_in)operator(,) ident(element)operator(]) keyword(unless) ident(wrapped_in?) symbol(:div)
           ident(wrap_in!) constant(Output)operator(.)ident(page_template_for_css)operator(()instance_variable(@css)operator(\))
insert[insert(+)          keyword(if) ident(args)operator(.)ident(first)operator(.)ident(is_a?)operator(()constant(Hash)operator(\)) operator(&&) ident(title) operator(=) ident(args)operator(.)ident(first)operator([)symbol(:title)operator(])]
insert[insert(+)            ident(apply_title!) ident(title)]
insert[insert(+)          keyword(end)]
insert[insert(+)          predefined_constant(self)]
         keyword(when) predefined_constant(nil)
           keyword(return) predefined_constant(self)
         keyword(else)
change[change(@@)plain( -166,7 +175,9 )change(@@)]
       comment(# title="double click to expand")
 
       constant(LIST) operator(=) shell<delimiter(<<-`LIST`)>
delete[delete(-)shell<content(<ol class="CodeRay"><%CONTENT%></ol>)>]
insert[insert(+)shell<content(<ol class="CodeRay">)>]
insert[insert(+)shell<content(<%CONTENT%>)>]
insert[insert(+)shell<content(</ol>)>]
shell<delimiter(       LIST)>
 
       constant(PAGE) operator(=) shell<delimiter(<<-`PAGE`)>
change[change(@@)plain( -175,7 +186,7 )change(@@)]
 operator(<)ident(html) ident(xmlns)operator(=)string<delimiter(")content(http://www.w3.org/1999/xhtml)delimiter(")> key(xml)operator(:)ident(lang)operator(=)string<delimiter(")content(en)delimiter(")> ident(lang)operator(=)string<delimiter(")content(de)delimiter(")>operator(>)
 operator(<)ident(head)operator(>)
   operator(<)ident(meta) ident(http)operator(-)ident(equiv)operator(=)string<delimiter(")content(content-type)delimiter(")> ident(content)operator(=)string<delimiter(")content(text/html; charset=utf-8)delimiter(")> operator(/)operator(>)
delete[delete(-)  operator(<)ident(title)operator(>)eyecatcher<constant(CodeRay) constant(HTML) constant(Encoder) constant(Example)>operator(<)regexp<delimiter(/)content(title>)>]
insert[insert(+)  operator(<)ident(title)operator(>)operator(<)regexp<delimiter(/)content(title>)>]
regexp<content(   <style type="text)delimiter(/)>ident(css)string<delimiter(")content(>)>
string<content( <%CSS%>)>
string<content(   </style>)>
head[head(Index: )plain(lib/coderay/encoders/html/numerization.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html/numerization.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/html/numerization.rb)plain(	(revision 500\))]
change[change(@@)plain( -32,9 +32,19 )change(@@)]
         comment(#end)
 
         ident(bold_every) operator(=) ident(options)operator([)symbol(:bold_every)operator(])
insert[insert(+)        ident(highlight_lines) operator(=) ident(options)operator([)symbol(:highlight_lines)operator(])]
         ident(bolding) operator(=)
delete[delete(-)          keyword(if) ident(bold_every) operator(==) predefined_constant(false)]
insert[insert(+)          keyword(if) ident(bold_every) operator(==) predefined_constant(false)eyecatcher< operator(&&) ident(highlight_lines) operator(==) predefined_constant(nil)>]
             ident(proc) operator({) operator(|)ident(line)operator(|) ident(line)operator(.)ident(to_s) operator(})
insert[insert(+)          keyword(elsif) ident(highlight_lines)operator(.)ident(is_a?) constant(Enumerable)]
insert[insert(+)            ident(highlight_lines) operator(=) ident(highlight_lines)operator(.)ident(to_set)]
insert[insert(+)            ident(proc) keyword(do) operator(|)ident(line)operator(|)]
insert[insert(+)              keyword(if) ident(highlight_lines)operator(.)ident(include?) ident(line)]
insert[insert(+)                string<delimiter(")content(<strong class=)char(\\")content(highlighted)char(\\")content(>)inline<inline_delimiter(#{)ident(line)inline_delimiter(})>content(</strong>)delimiter(")>  comment(# highlighted line numbers in bold)]
insert[insert(+)              keyword(else)]
insert[insert(+)                ident(line)operator(.)ident(to_s)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
           keyword(elsif) ident(bold_every)operator(.)ident(is_a?) constant(Integer)
             ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(:bolding can't be 0.)delimiter(")> keyword(if) ident(bold_every) operator(==) integer(0)
             ident(proc) keyword(do) operator(|)ident(line)operator(|)
change[change(@@)plain( -65,12 +75,12 )change(@@)]
           comment(# Because even monospace fonts seem to have different heights when bold,)
           comment(# I make the newline bold, both in the code and the line numbers.)
           comment(# FIXME Still not working perfect for Mr. Internet Exploder)
delete[delete(-)          comment(# FIXME Firefox struggles with very long codes (> 200 lines\))]
           ident(line_numbers) operator(=) operator(()ident(start) operator(...) ident(start) operator(+) ident(line_count)operator(\))operator(.)ident(to_a)operator(.)ident(map)operator(()operator(&)ident(bolding)operator(\))operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))
           ident(line_numbers) operator(<<) string<delimiter(")char(\\n)delimiter(")>  comment(# also for Mr. MS Internet Exploder :-/)
           ident(line_numbers)operator(.)ident(gsub!)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\)) operator({) string<delimiter(")content(<tt>)char(\\n)content(</tt>)delimiter(")> operator(})
 
           ident(line_numbers_table_tpl) operator(=) constant(TABLE)operator(.)ident(apply)operator(()string<delimiter(')content(LINE_NUMBERS)delimiter(')>operator(,) ident(line_numbers)operator(\))
insert[insert(+)          ident(gsub!)operator(()regexp<delimiter(/)content(<)char(\\/)content(div>)char(\\n)delimiter(/)>operator(\)) operator({) string<delimiter(')content(</div>)delimiter(')> operator(})]
           ident(gsub!)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\)) operator({) string<delimiter(")content(<tt>)char(\\n)content(</tt>)delimiter(")> operator(})
           ident(wrap_in!) ident(line_numbers_table_tpl)
           instance_variable(@wrapped_in) operator(=) symbol(:div)
change[change(@@)plain( -90,8 +100,9 )change(@@)]
             keyword(end)
             ident(close) operator(=) string<delimiter(')content(</span>)delimiter(')> operator(*) ident(opened_tags)operator(.)ident(size)
 
delete[delete(-)            string<delimiter(")content(<li>)inline<inline_delimiter(#{)ident(open)inline_delimiter(})>inline<inline_delimiter(#{)ident(line)inline_delimiter(})>inline<inline_delimiter(#{)ident(close)inline_delimiter(})>content(</li>)>string<delimiter(")>]
insert[insert(+)            string<delimiter(")content(<li>)inline<inline_delimiter(#{)ident(open)inline_delimiter(})>inline<inline_delimiter(#{)ident(line)inline_delimiter(})>inline<inline_delimiter(#{)ident(close)inline_delimiter(})>content(</li>)>eyecatcher<string<char(\\n)>>string<delimiter(")>]
           keyword(end)
insert[insert(+)          ident(chomp!)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))]
           ident(wrap_in!) constant(LIST)
           instance_variable(@wrapped_in) operator(=) symbol(:div)
 
head[head(Index: )plain(lib/coderay/encoders/html/css.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html/css.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/html/css.rb)plain(	(revision 500\))]
change[change(@@)plain( -27,16 +27,19 )change(@@)]
         integer(1)operator(.)ident(upto)operator(()ident(styles)operator(.)ident(size)operator(\)) keyword(do) operator(|)ident(offset)operator(|)
           keyword(break) keyword(if) ident(style) operator(=) ident(cl)operator([)ident(styles)operator([)ident(offset) operator(..) integer(-1)operator(])operator(])
         keyword(end)
delete[delete(-)        eyecatcher<ident(raise)> string<delimiter(')content(Style not found: %p)delimiter(')> operator(%) operator([)ident(styles)operator(]) keyword(if) global_variable($DEBUG) keyword(and) ident(style)operator(.)ident(empty?)]
insert[insert(+)        eyecatcher<global_variable($stderr)operator(.)ident(puts)> string<delimiter(')content(Style not found: %p)delimiter(')> operator(%) operator([)ident(styles)operator(]) keyword(if) global_variable($DEBUG) keyword(and) ident(style)operator(.)ident(empty?)]
         keyword(return) ident(style)
       keyword(end)
 
     ident(private)
 
       constant(CSS_CLASS_PATTERN) operator(=) regexp<delimiter(/)>
delete[delete(-)regexp<content(        ( (?:                # $1 = classes)>]
delete[delete(-)regexp<content(          )char(\\s)content(* )char(\\.)content( [-)char(\\w)content(]+)>]
delete[delete(-)regexp<content(        \)+ \))>]
insert[insert(+)regexp<content(        (                    # $1 = selectors)>]
insert[insert(+)regexp<content(          (?:)>]
insert[insert(+)regexp<content(            (?: )char(\\s)content(* )char(\\.)content( [-)char(\\w)content(]+ \)+)>]
insert[insert(+)regexp<content(            )char(\\s)content(* ,?)>]
insert[insert(+)regexp<content(          \)+)>]
insert[insert(+)regexp<content(        \))>]
regexp<content(         )char(\\s)content(* )char(\\{)content( )char(\\s)content(*)>
regexp<content(         ( [^)char(\\})content(]+ \)?          # $2 = style)>
regexp<content(         )char(\\s)content(* )char(\\})content( )char(\\s)content(*)>
change[change(@@)plain( -44,12 +47,14 )change(@@)]
         operator(() operator(.) operator(\))                comment(# $3 = error)
       regexp<delimiter(/)content(mx)>
regexp<content(       def parse stylesheet)>
delete[delete(-)regexp<content(        stylesheet.scan CSS_CLASS_PATTERN do |)>eyecatcher<regexp<content(classe)>>regexp<content(s, style, error|)>]
insert[insert(+)regexp<content(        stylesheet.scan CSS_CLASS_PATTERN do |)>eyecatcher<regexp<content(selector)>>regexp<content(s, style, error|)>]
regexp<content(           raise "CSS parse error: ')inline<inline_delimiter(#{)ident(error)operator(.)ident(inspect)inline_delimiter(})>content(' not recognized" if error)>
delete[delete(-)regexp<content(          styles = classes.scan()delimiter(/)>operator([)operator(-)error(\\)ident(w)operator(])operator(+)regexp<delimiter(/)content(\))>]
delete[delete(-)regexp<content(          cl = styles.pop)>]
delete[delete(-)regexp<content(          @classes[cl] ||= Hash.new)>]
delete[delete(-)regexp<content(          @classes[cl][styles] = style.to_s.strip)>]
insert[insert(+)regexp<content(          for selector in selectors.split(','\))>]
insert[insert(+)regexp<content(            classes = selector.scan()delimiter(/)>operator([)operator(-)error(\\)ident(w)operator(])operator(+)regexp<delimiter(/)content(\))>]
insert[insert(+)regexp<content(            cl = classes.pop)>]
insert[insert(+)regexp<content(            @classes[cl] ||= Hash.new)>]
insert[insert(+)regexp<content(            @classes[cl][classes] = style.to_s.strip.delete(' '\).chomp(';'\))>]
insert[insert(+)regexp<content(          end)>]
regexp<content(         end)>
regexp<content(       end)>
regexp<content( )>
head[head(Index: )plain(lib/coderay/encoders/html.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/html.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,4 +1,4 )change(@@)]
delete[delete(-)ident(require) string<>eyecatcher<string<delimiter(")content(set)delimiter(")>>]
insert[insert(+)ident(require) string<>eyecatcher<string<delimiter(')content(set)delimiter(')>>]
 
 keyword(module) class(CodeRay)
 keyword(module) class(Encoders)
change[change(@@)plain( -41,6 +41,12 )change(@@)]
   comment(#)
   comment(# Default: nil)
   comment(#)
insert[insert(+)  comment(# === :title)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# The title of the HTML page (works only when :wrap is set to :page.\))]
insert[insert(+)  comment(#)]
insert[insert(+)  comment(# Default: 'CodeRay output')]
insert[insert(+)  comment(#)]
   comment(# === :line_numbers)
   comment(# Include line numbers in :table, :inline, :list or nil (no line numbers\))
   comment(#)
change[change(@@)plain( -56,6 +62,16 )change(@@)]
   comment(#)
   comment(# Default: 10)
   comment(#)
insert[insert(+)  comment(# === :highlight_lines)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Highlights certain line numbers.)]
insert[insert(+)  comment(# Can be any Enumerable, typically just an Array or Range, of numbers.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Bolding is deactivated when :highlight_lines is set. It only makes sense)]
insert[insert(+)  comment(# in combination with :line_numbers.)]
insert[insert(+)  comment(#)]
insert[insert(+)  comment(# Default: nil)]
insert[insert(+)  comment(#)]
   comment(# === :hint)
   comment(# Include some information into the output using the title attribute.)
   comment(# Can be :info (show token type on mouse-over\), :info_long (with full path\))
change[change(@@)plain( -72,16 +88,16 )change(@@)]
     constant(DEFAULT_OPTIONS) operator(=) operator({)
       symbol(:tab_width) operator(=)operator(>) integer(8)operator(,)
 
delete[delete(-)      symbol(:level) operator(=)operator(>) symbol(:xhtml)operator(,)]
       symbol(:css) operator(=)operator(>) symbol(:class)operator(,)
 
       symbol(:style) operator(=)operator(>) symbol(:cycnus)operator(,)
delete[delete(-)]
       symbol(:wrap) operator(=)operator(>) predefined_constant(nil)operator(,)
insert[insert(+)      symbol(:title) operator(=)operator(>) string<delimiter(')content(CodeRay output)delimiter(')>operator(,)]
 
       symbol(:line_numbers) operator(=)operator(>) predefined_constant(nil)operator(,)
       symbol(:line_number_start) operator(=)operator(>) integer(1)operator(,)
       symbol(:bold_every) operator(=)operator(>) integer(10)operator(,)
insert[insert(+)      symbol(:highlight_lines) operator(=)operator(>) predefined_constant(nil)operator(,)]
 
       symbol(:hint) operator(=)operator(>) predefined_constant(false)operator(,)
     operator(})
change[change(@@)plain( -216,43 +232,70 )change(@@)]
       instance_variable(@out)operator(.)ident(css) operator(=) instance_variable(@css)
       instance_variable(@out)operator(.)ident(numerize!) ident(options)operator([)symbol(:line_numbers)operator(])operator(,) ident(options)
       instance_variable(@out)operator(.)ident(wrap!) ident(options)operator([)symbol(:wrap)operator(])
insert[insert(+)      instance_variable(@out)operator(.)ident(apply_title!) ident(options)operator([)symbol(:title)operator(])]
 
       keyword(super)
     keyword(end)
 
     keyword(def) method(token) ident(text)operator(,) ident(type)
delete[delete(-)      keyword(if) ident(text)operator(.)ident(is_a?) operator(::)constant(String)]
insert[insert(+)      keyword(case) ident(text)]
insert[insert(+)      ]
insert[insert(+)      keyword(when) predefined_constant(nil)]
insert[insert(+)        comment(# raise 'Token with nil as text was given: %p' % [[text, type]] )]
insert[insert(+)      ]
insert[insert(+)      keyword(when) constant(String)]
         keyword(if) ident(text) operator(=)operator(~) regexp<delimiter(/)inline<inline_delimiter(#{)constant(HTML_ESCAPE_PATTERN)inline_delimiter(})>delimiter(/)modifier(o)>
           ident(text) operator(=) ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(HTML_ESCAPE_PATTERN)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) operator({) operator(|)ident(m)operator(|) instance_variable(@HTML_ESCAPE)operator([)ident(m)operator(]) operator(})
         keyword(end)
         instance_variable(@opened)operator([)integer(0)operator(]) operator(=) ident(type)
delete[delete(-)        keyword(if) ident(style) operator(=) instance_variable(@css_style)operator([)instance_variable(@opened)operator(])]
insert[insert(+)        keyword(if) eyecatcher<ident(text) operator(!=) string<delimiter(")char(\\n)delimiter(")> operator(&&) >ident(style) operator(=) instance_variable(@css_style)operator([)instance_variable(@opened)operator(])]
           instance_variable(@out) operator(<<) ident(style) operator(<<) ident(text) operator(<<) string<delimiter(')content(</span>)delimiter(')>
         keyword(else)
           instance_variable(@out) operator(<<) ident(text)
         keyword(end)
delete[delete(-)      keyword(else)]
delete[delete(-)        keyword(case) ident(text)]
delete[delete(-)        keyword(when) symbol(:open)]
delete[delete(-)          instance_variable(@opened)operator([)integer(0)operator(]) operator(=) ident(type)]
delete[delete(-)          instance_variable(@out) operator(<<) operator(()instance_variable(@css_style)operator([)instance_variable(@opened)operator(]) operator(||) string<delimiter(')content(<span>)delimiter(')>operator(\))]
delete[delete(-)          instance_variable(@opened) operator(<<) ident(type)]
delete[delete(-)        keyword(when) symbol(:close)]
delete[delete(-)          keyword(if) instance_variable(@opened)operator(.)ident(empty?)]
delete[delete(-)            comment(# nothing to close)]
delete[delete(-)          keyword(else)]
delete[delete(-)            keyword(if) global_variable($DEBUG) keyword(and) operator(()instance_variable(@opened)operator(.)ident(size) operator(==) integer(1) keyword(or) instance_variable(@opened)operator(.)ident(last) operator(!=) ident(type)operator(\))]
delete[delete(-)              ident(raise) string<delimiter(')content(Malformed token stream: Trying to close a token (%p\) )content(\\)>]
delete[delete(-)string<content(                that is not open. Open are: %p.)delimiter(')> operator(%) operator([)ident(type)operator(,) instance_variable(@opened)operator([)integer(1)operator(..)integer(-1)operator(])operator(])]
delete[delete(-)            keyword(end)]
delete[delete(-)            instance_variable(@out) operator(<<) string<delimiter(')content(</span>)delimiter(')>]
delete[delete(-)            instance_variable(@opened)operator(.)ident(pop)]
insert[insert(+)        ]
insert[insert(+)      ]
insert[insert(+)      comment(# token groups, eg. strings)]
insert[insert(+)      keyword(when) symbol(:open)]
insert[insert(+)        instance_variable(@opened)operator([)integer(0)operator(]) operator(=) ident(type)]
insert[insert(+)        instance_variable(@out) operator(<<) operator(()instance_variable(@css_style)operator([)instance_variable(@opened)operator(]) operator(||) string<delimiter(')content(<span>)delimiter(')>operator(\))]
insert[insert(+)        instance_variable(@opened) operator(<<) ident(type)]
insert[insert(+)      keyword(when) symbol(:close)]
insert[insert(+)        keyword(if) instance_variable(@opened)operator(.)ident(empty?)]
insert[insert(+)          comment(# nothing to close)]
insert[insert(+)        keyword(else)]
insert[insert(+)          keyword(if) global_variable($DEBUG) keyword(and) operator(()instance_variable(@opened)operator(.)ident(size) operator(==) integer(1) keyword(or) instance_variable(@opened)operator(.)ident(last) operator(!=) ident(type)operator(\))]
insert[insert(+)            ident(raise) string<delimiter(')content(Malformed token stream: Trying to close a token (%p\) )content(\\)>]
insert[insert(+)string<content(              that is not open. Open are: %p.)delimiter(')> operator(%) operator([)ident(type)operator(,) instance_variable(@opened)operator([)integer(1)operator(..)integer(-1)operator(])operator(])]
           keyword(end)
delete[delete(-)        keyword(when) predefined_constant(nil)]
delete[delete(-)          ident(raise) string<delimiter(')content(Token with nil as text was given: %p)delimiter(')> operator(%) operator([)operator([)ident(text)operator(,) ident(type)operator(])operator(])]
insert[insert(+)          instance_variable(@out) operator(<<) string<delimiter(')content(</span>)delimiter(')>]
insert[insert(+)          instance_variable(@opened)operator(.)ident(pop)]
insert[insert(+)        keyword(end)]
insert[insert(+)      ]
insert[insert(+)      comment(# whole lines to be highlighted, eg. a deleted line in a diff)]
insert[insert(+)      keyword(when) symbol(:begin_line)]
insert[insert(+)        instance_variable(@opened)operator([)integer(0)operator(]) operator(=) ident(type)]
insert[insert(+)        keyword(if) ident(style) operator(=) instance_variable(@css_style)operator([)instance_variable(@opened)operator(])]
insert[insert(+)          instance_variable(@out) operator(<<) ident(style)operator(.)ident(sub)operator(()string<delimiter(')content(<span)delimiter(')>operator(,) string<delimiter(')content(<div)delimiter(')>operator(\))]
         keyword(else)
delete[delete(-)          eyecatcher<ident(raise) string<delimiter(')content(unknown token kind: %p)delimiter(')> operator(%) ident(text)>]
insert[insert(+)          eyecatcher<instance_variable(@out) operator(<<) string<delimiter(')content(<div>)delimiter(')>>]
         keyword(end)
insert[insert(+)        instance_variable(@opened) operator(<<) ident(type)]
insert[insert(+)      keyword(when) symbol(:end_line)]
insert[insert(+)        keyword(if) instance_variable(@opened)operator(.)ident(empty?)]
insert[insert(+)          comment(# nothing to close)]
insert[insert(+)        keyword(else)]
insert[insert(+)          keyword(if) global_variable($DEBUG) keyword(and) operator(()instance_variable(@opened)operator(.)ident(size) operator(==) integer(1) keyword(or) instance_variable(@opened)operator(.)ident(last) operator(!=) ident(type)operator(\))]
insert[insert(+)            ident(raise) string<delimiter(')content(Malformed token stream: Trying to close a line (%p\) )content(\\)>]
insert[insert(+)string<content(              that is not open. Open are: %p.)delimiter(')> operator(%) operator([)ident(type)operator(,) instance_variable(@opened)operator([)integer(1)operator(..)integer(-1)operator(])operator(])]
insert[insert(+)          keyword(end)]
insert[insert(+)          instance_variable(@out) operator(<<) string<delimiter(')content(</div>)delimiter(')>]
insert[insert(+)          instance_variable(@opened)operator(.)ident(pop)]
insert[insert(+)        keyword(end)]
insert[insert(+)      ]
insert[insert(+)      keyword(else)]
insert[insert(+)        ident(raise) string<delimiter(')content(unknown token kind: %p)delimiter(')> operator(%) operator([)ident(text)operator(])]
insert[insert(+)        ]
       keyword(end)
     keyword(end)
 
head[head(Index: )plain(lib/coderay/encoders/comment_filter.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/comment_filter.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/comment_filter.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,43 )change(@@)]
insert[insert(+)operator(()global_variable($:)operator(.)ident(unshift) string<delimiter(')content(../..)delimiter(')>operator(;) ident(require) string<delimiter(')content(coderay)delimiter(')>operator(\)) keyword(unless) keyword(defined?) constant(CodeRay)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Encoders)]
insert[insert(+)  ]
insert[insert(+)  ident(load) symbol(:token_class_filter)]
insert[insert(+)  ]
insert[insert(+)  keyword(class) class(CommentFilter) operator(<) constant(TokenClassFilter)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:comment_filter)]
insert[insert(+)    ]
insert[insert(+)    constant(DEFAULT_OPTIONS) operator(=) ident(superclass)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge) \]
insert[insert(+)      symbol(:exclude) operator(=)operator(>) operator([)symbol(:comment)operator(])]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(CommentFilterTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_comments)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(.)ident(scan) string<delimiter(<<-RUBY)>operator(,) symbol(:ruby)]
insert[insert(+)string<content(#!/usr/bin/env ruby)>]
insert[insert(+)string<content(# a minimal Ruby program)>]
insert[insert(+)string<content(puts "Hello world!")>]
insert[insert(+)string<delimiter(    RUBY)>]
insert[insert(+)    ident(assert_equal) string<delimiter(<<-RUBY_FILTERED)>operator(,) ident(tokens)operator(.)ident(comment_filter)operator(.)ident(text)]
insert[insert(+)string<content(#!/usr/bin/env ruby)>]
insert[insert(+)]
insert[insert(+)string<content(puts "Hello world!")>]
insert[insert(+)string<delimiter(    RUBY_FILTERED)>]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/encoders/json.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/json.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/json.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,69 )change(@@)]
insert[insert(+)operator(()global_variable($:)operator(.)ident(unshift) string<delimiter(')content(../..)delimiter(')>operator(;) ident(require) string<delimiter(')content(coderay)delimiter(')>operator(\)) keyword(unless) keyword(defined?) constant(CodeRay)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Encoders)]
insert[insert(+)  ]
insert[insert(+)  comment(# = JSON Encoder)]
insert[insert(+)  keyword(class) class(JSON) operator(<) constant(Encoder)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:json)]
insert[insert(+)    constant(FILE_EXTENSION) operator(=) string<delimiter(')content(json)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    keyword(def) method(setup) ident(options)]
insert[insert(+)      keyword(begin)]
insert[insert(+)        ident(require) string<delimiter(')content(json)delimiter(')>]
insert[insert(+)      keyword(rescue) constant(LoadError)]
insert[insert(+)        ident(require) string<delimiter(')content(rubygems)delimiter(')>]
insert[insert(+)        ident(require) string<delimiter(')content(json)delimiter(')>]
insert[insert(+)      keyword(end)]
insert[insert(+)      instance_variable(@out) operator(=) operator([)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(text_token) ident(text)operator(,) ident(kind)]
insert[insert(+)      operator({) symbol(:type) operator(=)operator(>) string<delimiter(')content(text)delimiter(')>operator(,) symbol(:text) operator(=)operator(>) ident(text)operator(,) symbol(:kind) operator(=)operator(>) ident(kind) operator(})]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(block_token) ident(action)operator(,) ident(kind)]
insert[insert(+)      operator({) symbol(:type) operator(=)operator(>) string<delimiter(')content(block)delimiter(')>operator(,) symbol(:action) operator(=)operator(>) ident(action)operator(,) symbol(:kind) operator(=)operator(>) ident(kind) operator(})]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(finish) ident(options)]
insert[insert(+)      instance_variable(@out)operator(.)ident(to_json)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)global_variable($:)operator(.)ident(delete) string<delimiter(')content(.)delimiter(')>]
insert[insert(+)ident(require) string<delimiter(')content(rubygems)delimiter(')> keyword(if) predefined_constant(RUBY_VERSION) operator(<) string<delimiter(')content(1.9)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(JSONEncoderTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_json_output)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(.)ident(scan) string<delimiter(<<-RUBY)>operator(,) symbol(:ruby)]
insert[insert(+)string<content(puts "Hello world!")>]
insert[insert(+)string<delimiter(    RUBY)>]
insert[insert(+)    ident(require) string<delimiter(')content(json)delimiter(')>]
insert[insert(+)    ident(assert_equal) operator([)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")content(puts)delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(ident)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")content( )delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(space)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(block)delimiter(")>operator(,) string<delimiter(")content(action)delimiter(")>operator(=)operator(>)string<delimiter(")content(open)delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(string)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")char(\\")delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(delimiter)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")content(Hello world!)delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(content)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")char(\\")delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(delimiter)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(block)delimiter(")>operator(,) string<delimiter(")content(action)delimiter(")>operator(=)operator(>)string<delimiter(")content(close)delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(string)delimiter(")>operator(})operator(,)]
insert[insert(+)      operator({)string<delimiter(")content(type)delimiter(")>operator(=)operator(>)string<delimiter(")content(text)delimiter(")>operator(,) string<delimiter(")content(text)delimiter(")>operator(=)operator(>)string<delimiter(")char(\\n)delimiter(")>operator(,) string<delimiter(")content(kind)delimiter(")>operator(=)operator(>)string<delimiter(")content(space)delimiter(")>operator(})]
insert[insert(+)    operator(])operator(,) constant(JSON)operator(.)ident(load)operator(()ident(tokens)operator(.)ident(json)operator(\))]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/encoders/token_class_filter.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/token_class_filter.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/token_class_filter.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,84 )change(@@)]
insert[insert(+)operator(()global_variable($:)operator(.)ident(unshift) string<delimiter(')content(../..)delimiter(')>operator(;) ident(require) string<delimiter(')content(coderay)delimiter(')>operator(\)) keyword(unless) keyword(defined?) constant(CodeRay)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Encoders)]
insert[insert(+)  ]
insert[insert(+)  ident(load) symbol(:filter)]
insert[insert(+)  ]
insert[insert(+)  keyword(class) class(TokenClassFilter) operator(<) constant(Filter)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ident(register_for) symbol(:token_class_filter)]
insert[insert(+)]
insert[insert(+)    constant(DEFAULT_OPTIONS) operator(=) operator({)]
insert[insert(+)      symbol(:exclude) operator(=)operator(>) operator([)operator(])operator(,)]
insert[insert(+)      symbol(:include) operator(=)operator(>) symbol(:all)]
insert[insert(+)    operator(})]
insert[insert(+)]
insert[insert(+)  ident(protected)]
insert[insert(+)    keyword(def) method(setup) ident(options)]
insert[insert(+)      keyword(super)]
insert[insert(+)      instance_variable(@exclude) operator(=) ident(options)operator([)symbol(:exclude)operator(])]
insert[insert(+)      instance_variable(@exclude) operator(=) ident(Array)operator(()instance_variable(@exclude)operator(\)) keyword(unless) instance_variable(@exclude) operator(==) symbol(:all)]
insert[insert(+)      instance_variable(@include) operator(=) ident(options)operator([)symbol(:include)operator(])]
insert[insert(+)      instance_variable(@include) operator(=) ident(Array)operator(()instance_variable(@include)operator(\)) keyword(unless) instance_variable(@include) operator(==) symbol(:all)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(include_text_token?) ident(text)operator(,) ident(kind)]
insert[insert(+)       operator(()instance_variable(@include) operator(==) symbol(:all) operator(||) instance_variable(@include)operator(.)ident(include?)operator(()ident(kind)operator(\))operator(\)) operator(&&)]
insert[insert(+)      operator(!)operator(()instance_variable(@exclude) operator(==) symbol(:all) operator(||) instance_variable(@exclude)operator(.)ident(include?)operator(()ident(kind)operator(\))operator(\))]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(TokenClassFilterTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_creation)]
insert[insert(+)    ident(assert) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter) operator(<) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Encoder)]
insert[insert(+)    ident(assert) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter) operator(<) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(Filter)]
insert[insert(+)    ident(filter) operator(=) predefined_constant(nil)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(filter) operator(=) constant(CodeRay)operator(.)ident(encoder) symbol(:token_class_filter)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_instance_of) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(,) ident(filter)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_text_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    keyword(for) ident(i) keyword(in) integer(1)operator(..)integer(10)]
insert[insert(+)      ident(tokens) operator(<<) operator([)ident(i)operator(.)ident(to_s)operator(,) symbol(:index)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)string<delimiter(')content( )delimiter(')>operator(,) symbol(:space)operator(]) keyword(if) ident(i) operator(<) integer(10)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) integer(10)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(,) symbol(:exclude) operator(=)operator(>) symbol(:space)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(10)operator(,) ident(tokens)operator(.)ident(token_class_filter)operator(()symbol(:exclude) operator(=)operator(>) symbol(:space)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(9)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(,) symbol(:include) operator(=)operator(>) symbol(:space)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(9)operator(,) ident(tokens)operator(.)ident(token_class_filter)operator(()symbol(:include) operator(=)operator(>) symbol(:space)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(0)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(,) symbol(:exclude) operator(=)operator(>) symbol(:all)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(0)operator(,) ident(tokens)operator(.)ident(token_class_filter)operator(()symbol(:exclude) operator(=)operator(>) symbol(:all)operator(\))operator(.)ident(size)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_filtering_block_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    integer(10)operator(.)ident(times) keyword(do) operator(|)ident(i)operator(|)]
insert[insert(+)      ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:index)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)ident(i)operator(.)ident(to_s)operator(,) symbol(:content)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:index)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) integer(20)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(,) symbol(:include) operator(=)operator(>) symbol(:blubb)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(20)operator(,) ident(tokens)operator(.)ident(token_class_filter)operator(()symbol(:include) operator(=)operator(>) symbol(:blubb)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(30)operator(,) constant(CodeRay)operator(::)constant(Encoders)operator(::)constant(TokenClassFilter)operator(.)ident(new)operator(.)ident(encode_tokens)operator(()ident(tokens)operator(,) symbol(:exclude) operator(=)operator(>) symbol(:index)operator(\))operator(.)ident(size)]
insert[insert(+)    ident(assert_equal) integer(30)operator(,) ident(tokens)operator(.)ident(token_class_filter)operator(()symbol(:exclude) operator(=)operator(>) symbol(:index)operator(\))operator(.)ident(size)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/encoders/terminal.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/terminal.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/encoders/terminal.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,137 )change(@@)]
insert[insert(+)comment(# By Rob Aldred (http://robaldred.co.uk\))]
insert[insert(+)comment(# Based on idea by Nathan Weizenbaum (http://nex-3.com\))]
insert[insert(+)comment(# MIT License (http://www.opensource.org/licenses/mit-license.php\))]
insert[insert(+)comment(#)]
insert[insert(+)comment(# A CodeRay encoder that outputs code highlighted for a color terminal.)]
insert[insert(+)comment(# Check out http://robaldred.co.uk)]
insert[insert(+)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)  keyword(module) class(Encoders)]
insert[insert(+)    keyword(class) class(Terminal) operator(<) constant(Encoder)]
insert[insert(+)      ]
insert[insert(+)      ident(register_for) symbol(:terminal)]
insert[insert(+)]
insert[insert(+)      constant(TOKEN_COLORS) operator(=) operator({)]
insert[insert(+)        symbol(:attribute_name) operator(=)operator(>) string<delimiter(')content(33)delimiter(')>operator(,)]
insert[insert(+)        symbol(:attribute_name_fat) operator(=)operator(>) string<delimiter(')content(33)delimiter(')>operator(,)]
insert[insert(+)        symbol(:attribute_value) operator(=)operator(>) string<delimiter(')content(31)delimiter(')>operator(,)]
insert[insert(+)        symbol(:attribute_value_fat) operator(=)operator(>) string<delimiter(')content(31)delimiter(')>operator(,)]
insert[insert(+)        symbol(:bin) operator(=)operator(>) string<delimiter(')content(1;35)delimiter(')>operator(,)]
insert[insert(+)        symbol(:char) operator(=)operator(>) operator({)symbol(:self) operator(=)operator(>) string<delimiter(')content(36)delimiter(')>operator(,) symbol(:delimiter) operator(=)operator(>) string<delimiter(')content(34)delimiter(')>operator(})operator(,)]
insert[insert(+)        symbol(:class) operator(=)operator(>) string<delimiter(')content(1;35)delimiter(')>operator(,)]
insert[insert(+)        symbol(:class_variable) operator(=)operator(>) string<delimiter(')content(36)delimiter(')>operator(,)]
insert[insert(+)        symbol(:color) operator(=)operator(>) string<delimiter(')content(32)delimiter(')>operator(,)]
insert[insert(+)        symbol(:comment) operator(=)operator(>) string<delimiter(')content(37)delimiter(')>operator(,)]
insert[insert(+)        symbol(:constant) operator(=)operator(>) operator([)string<delimiter(')content(34)delimiter(')>operator(,) string<delimiter(')content(4)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:definition) operator(=)operator(>) string<delimiter(')content(1;32)delimiter(')>operator(,)]
insert[insert(+)        symbol(:directive) operator(=)operator(>) operator([)string<delimiter(')content(32)delimiter(')>operator(,) string<delimiter(')content(4)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:doc) operator(=)operator(>) string<delimiter(')content(46)delimiter(')>operator(,)]
insert[insert(+)        symbol(:doc_string) operator(=)operator(>) operator([)string<delimiter(')content(31)delimiter(')>operator(,) string<delimiter(')content(4)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:entity) operator(=)operator(>) string<delimiter(')content(33)delimiter(')>operator(,)]
insert[insert(+)        symbol(:error) operator(=)operator(>) operator([)string<delimiter(')content(1;33)delimiter(')>operator(,) string<delimiter(')content(41)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:exception) operator(=)operator(>) string<delimiter(')content(1;31)delimiter(')>operator(,)]
insert[insert(+)        symbol(:float) operator(=)operator(>) string<delimiter(')content(1;35)delimiter(')>operator(,)]
insert[insert(+)        symbol(:function) operator(=)operator(>) string<delimiter(')content(1;34)delimiter(')>operator(,)]
insert[insert(+)        symbol(:global_variable) operator(=)operator(>) string<delimiter(')content(42)delimiter(')>operator(,)]
insert[insert(+)        symbol(:hex) operator(=)operator(>) string<delimiter(')content(1;36)delimiter(')>operator(,)]
insert[insert(+)        symbol(:include) operator(=)operator(>) string<delimiter(')content(33)delimiter(')>operator(,)]
insert[insert(+)        symbol(:integer) operator(=)operator(>) string<delimiter(')content(1;34)delimiter(')>operator(,)]
insert[insert(+)        symbol(:interpreted) operator(=)operator(>) string<delimiter(')content(1;35)delimiter(')>operator(,)]
insert[insert(+)        symbol(:label) operator(=)operator(>) string<delimiter(')content(1;4)delimiter(')>operator(,)]
insert[insert(+)        symbol(:local_variable) operator(=)operator(>) string<delimiter(')content(33)delimiter(')>operator(,)]
insert[insert(+)        symbol(:oct) operator(=)operator(>) string<delimiter(')content(1;35)delimiter(')>operator(,)]
insert[insert(+)        symbol(:operator_name) operator(=)operator(>) string<delimiter(')content(1;29)delimiter(')>operator(,)]
insert[insert(+)        symbol(:pre_constant) operator(=)operator(>) string<delimiter(')content(1;36)delimiter(')>operator(,)]
insert[insert(+)        symbol(:pre_type) operator(=)operator(>) string<delimiter(')content(1;30)delimiter(')>operator(,)]
insert[insert(+)        symbol(:predefined) operator(=)operator(>) operator([)string<delimiter(')content(4)delimiter(')>operator(,) string<delimiter(')content(1;34)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:preprocessor) operator(=)operator(>) string<delimiter(')content(36)delimiter(')>operator(,)]
insert[insert(+)        symbol(:regexp) operator(=)operator(>) operator({)]
insert[insert(+)          symbol(:content) operator(=)operator(>) string<delimiter(')content(31)delimiter(')>operator(,)]
insert[insert(+)          symbol(:delimiter) operator(=)operator(>) string<delimiter(')content(1;29)delimiter(')>operator(,)]
insert[insert(+)          symbol(:modifier) operator(=)operator(>) string<delimiter(')content(35)delimiter(')>operator(,)]
insert[insert(+)          symbol(:function) operator(=)operator(>) string<delimiter(')content(1;29)delimiter(')>]
insert[insert(+)        operator(})operator(,)]
insert[insert(+)        symbol(:reserved) operator(=)operator(>) string<delimiter(')content(1;31)delimiter(')>operator(,)]
insert[insert(+)        symbol(:shell) operator(=)operator(>) operator({)symbol(:self) operator(=)operator(>) string<delimiter(')content(42)delimiter(')>operator(,) symbol(:content) operator(=)operator(>) string<delimiter(')content(1;29)delimiter(')>operator(})operator(,)]
insert[insert(+)        symbol(:string) operator(=)operator(>) string<delimiter(')content(32)delimiter(')>operator(,)]
insert[insert(+)        symbol(:symbol) operator(=)operator(>) string<delimiter(')content(1;32)delimiter(')>operator(,)]
insert[insert(+)        symbol(:tag) operator(=)operator(>) string<delimiter(')content(34)delimiter(')>operator(,)]
insert[insert(+)        symbol(:tag_fat) operator(=)operator(>) string<delimiter(')content(1;34)delimiter(')>operator(,)]
insert[insert(+)        symbol(:tag_special) operator(=)operator(>) operator([)string<delimiter(')content(34)delimiter(')>operator(,) string<delimiter(')content(4)delimiter(')>operator(])operator(,)]
insert[insert(+)        symbol(:type) operator(=)operator(>) string<delimiter(')content(1;34)delimiter(')>operator(,)]
insert[insert(+)        symbol(:variable) operator(=)operator(>) string<delimiter(')content(34)delimiter(')>]
insert[insert(+)      operator(})]
insert[insert(+)      constant(TOKEN_COLORS)operator([)symbol(:method)operator(]) operator(=) constant(TOKEN_COLORS)operator([)symbol(:function)operator(])]
insert[insert(+)      constant(TOKEN_COLORS)operator([)symbol(:open)operator(]) operator(=) constant(TOKEN_COLORS)operator([)symbol(:close)operator(]) operator(=) constant(TOKEN_COLORS)operator([)symbol(:nesting_delimiter)operator(]) operator(=) constant(TOKEN_COLORS)operator([)symbol(:escape)operator(]) operator(=) constant(TOKEN_COLORS)operator([)symbol(:delimiter)operator(])]
insert[insert(+)]
insert[insert(+)      ident(protected)]
insert[insert(+)]
insert[insert(+)      keyword(def) method(setup)operator(()ident(options)operator(\))]
insert[insert(+)        keyword(super)]
insert[insert(+)        instance_variable(@opened) operator(=) operator([)predefined_constant(nil)operator(])]
insert[insert(+)        instance_variable(@subcolors) operator(=) predefined_constant(nil)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(def) method(finish)operator(()ident(options)operator(\))]
insert[insert(+)        keyword(super)]
insert[insert(+)      keyword(end)]
insert[insert(+)    ]
insert[insert(+)      keyword(def) method(token) ident(text)operator(,) ident(type)]
insert[insert(+)        keyword(case) ident(text)]
insert[insert(+)      ]
insert[insert(+)        keyword(when) predefined_constant(nil)]
insert[insert(+)          comment(# raise 'Token with nil as text was given: %p' % [[text, type]])]
insert[insert(+)      ]
insert[insert(+)        keyword(when) constant(String)]
insert[insert(+)        ]
insert[insert(+)          keyword(if) ident(color) operator(=) operator(()instance_variable(@subcolors) operator(||) constant(TOKEN_COLORS)operator(\))operator([)ident(type)operator(])]
insert[insert(+)            ident(color) operator(=) ident(color)operator([)symbol(:self)operator(]) operator(||) keyword(return) keyword(if) constant(Hash) operator(===) ident(color)]
insert[insert(+)]
insert[insert(+)            instance_variable(@out) operator(<<) ident(col)operator(()ident(color)operator(\)) operator(+) ident(text)operator(.)ident(gsub)operator(()string<delimiter(")char(\\n)delimiter(")>operator(,) ident(col)operator(()integer(0)operator(\)) operator(+) string<delimiter(")char(\\n)delimiter(")> operator(+) ident(col)operator(()ident(color)operator(\))operator(\)) operator(+) ident(col)operator(()integer(0)operator(\))]
insert[insert(+)            instance_variable(@out) operator(<<) ident(col)operator(()instance_variable(@subcolors)operator([)symbol(:self)operator(])operator(\)) keyword(if) instance_variable(@subcolors) operator(&&) instance_variable(@subcolors)operator([)symbol(:self)operator(])]
insert[insert(+)          keyword(else)]
insert[insert(+)            instance_variable(@out) operator(<<) ident(text)]
insert[insert(+)          keyword(end)]
insert[insert(+)      ]
insert[insert(+)        comment(# token groups, eg. strings)]
insert[insert(+)        keyword(when) symbol(:open)]
insert[insert(+)          instance_variable(@opened)operator([)integer(0)operator(]) operator(=) ident(type)]
insert[insert(+)          keyword(if) ident(color) operator(=) constant(TOKEN_COLORS)operator([)ident(type)operator(])]
insert[insert(+)            keyword(if) constant(Hash) operator(===) ident(color)]
insert[insert(+)              instance_variable(@subcolors) operator(=) ident(color)]
insert[insert(+)              instance_variable(@out) operator(<<) ident(col)operator(()ident(color)operator([)symbol(:self)operator(])operator(\)) keyword(if) ident(color)operator([)symbol(:self)operator(])]
insert[insert(+)            keyword(else)]
insert[insert(+)              instance_variable(@subcolors) operator(=) operator({)operator(})]
insert[insert(+)              instance_variable(@out) operator(<<) ident(col)operator(()ident(color)operator(\))]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(end)]
insert[insert(+)          instance_variable(@opened) operator(<<) ident(type)]
insert[insert(+)        keyword(when) symbol(:close)]
insert[insert(+)          keyword(if) instance_variable(@opened)operator(.)ident(empty?)]
insert[insert(+)            comment(# nothing to close)]
insert[insert(+)          keyword(else)]
insert[insert(+)            keyword(if) operator(()instance_variable(@subcolors) operator(||) operator({)operator(})operator(\))operator([)symbol(:self)operator(])]
insert[insert(+)              instance_variable(@out) operator(<<) ident(col)operator(()integer(0)operator(\))]
insert[insert(+)            keyword(end)]
insert[insert(+)            instance_variable(@subcolors) operator(=) predefined_constant(nil)]
insert[insert(+)            instance_variable(@opened)operator(.)ident(pop)]
insert[insert(+)          keyword(end)]
insert[insert(+)      ]
insert[insert(+)        comment(# whole lines to be highlighted, eg. a added/modified/deleted lines in a diff)]
insert[insert(+)        keyword(when) symbol(:begin_line)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:end_line)        ]
insert[insert(+)      ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise) string<delimiter(')content(unknown token kind: %p)delimiter(')> operator(%) operator([)ident(text)operator(])]
insert[insert(+)        keyword(end)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(private)]
insert[insert(+)]
insert[insert(+)      keyword(def) method(col)operator(()ident(color)operator(\))]
insert[insert(+)        ident(Array)operator(()ident(color)operator(\))operator(.)ident(map) operator({) operator(|)ident(c)operator(|) string<delimiter(")char(\\e)content([)inline<inline_delimiter(#{)ident(c)inline_delimiter(})>content(m)delimiter(")> operator(})operator(.)ident(join)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)  keyword(end)]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/encoders/page.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/page.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/page.rb)plain(	(revision 500\))]
change[change(@@)plain( -9,11 +9,10 )change(@@)]
 
     ident(register_for) symbol(:page)
 
delete[delete(-)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher<operator(()operator({)>]
insert[insert(+)    constant(DEFAULT_OPTIONS) operator(=) constant(HTML)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge)eyecatcher< \>]
       symbol(:css) operator(=)operator(>) symbol(:class)operator(,)
       symbol(:wrap) operator(=)operator(>) symbol(:page)operator(,)
       symbol(:line_numbers) operator(=)operator(>) symbol(:table)
delete[delete(-)    operator(})operator(\))]
 
   keyword(end)
 
head[head(Index: )plain(lib/coderay/encoders/_map.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/_map.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/encoders/_map.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,8 +1,11 )change(@@)]
 keyword(module) class(CodeRay)
 keyword(module) class(Encoders)
 
delete[delete(-)  ident(map) symbol(:stats) operator(=)operator(>) symbol(:statistic)operator(,)]
insert[insert(+)  ident(map) \]
insert[insert(+)    symbol(:loc) operator(=)operator(>) symbol(:lines_of_code)operator(,)]
insert[insert(+)    symbol(:term) operator(=)operator(>) symbol(:terminal)operator(,)]
     symbol(:plain) operator(=)operator(>) symbol(:text)operator(,)
insert[insert(+)    symbol(:stats) operator(=)operator(>) symbol(:statistic)operator(,)]
     symbol(:tex) operator(=)operator(>) symbol(:latex)
 
 keyword(end)
head[head(Index: )plain(lib/coderay/helpers/plugin.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/plugin.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/helpers/plugin.rb)plain(	(revision 500\))]
change[change(@@)plain( -2,8 +2,6 )change(@@)]
   
 comment(# = PluginHost)
 comment(#)
delete[delete(-)comment(# $Id$)]
delete[delete(-)comment(#)]
 comment(# A simple subclass plugin system.)
 comment(#)
 comment(#  Example:)
change[change(@@)plain( -135,9 +133,13 )change(@@)]
   comment(#    map :navy => :dark_blue)
   comment(#    default :gray)
   comment(#  end)
delete[delete(-)  keyword(def) method(default) ident(id)]
delete[delete(-)    ident(id) operator(=) ident(validate_id) ident(id)]
delete[delete(-)    ident(plugin_hash)operator([)predefined_constant(nil)operator(]) operator(=) ident(id)]
insert[insert(+)  keyword(def) method(default) ident(id) operator(=) predefined_constant(nil)]
insert[insert(+)    keyword(if) ident(id)]
insert[insert(+)      ident(id) operator(=) ident(validate_id) ident(id)]
insert[insert(+)      ident(plugin_hash)operator([)predefined_constant(nil)operator(]) operator(=) ident(id)]
insert[insert(+)    keyword(else)]
insert[insert(+)      ident(plugin_hash)operator([)predefined_constant(nil)operator(])]
insert[insert(+)    keyword(end)]
   keyword(end)
 
   comment(# Every plugin must register itself for one or more)
change[change(@@)plain( -174,7 +176,7 )change(@@)]
   keyword(def) method(inspect)
     ident(map) operator(=) ident(plugin_hash)operator(.)ident(dup)
     ident(map)operator(.)ident(each) keyword(do) operator(|)ident(id)operator(,) ident(plugin)operator(|)
delete[delete(-)      ident(map)operator([)ident(id)operator(]) operator(=) ident(plugin)operator(.)ident(to_s)operator([)regexp<delimiter(/)content((?>)>eyecatcher<regexp<content([)char(\\w)content(_])>>regexp<content(+\)$)delimiter(/)>operator(])]
insert[insert(+)      ident(map)operator([)ident(id)operator(]) operator(=) ident(plugin)operator(.)ident(to_s)operator([)regexp<delimiter(/)content((?>)>eyecatcher<regexp<char(\\w)>>regexp<content(+\)$)delimiter(/)>operator(])]
     keyword(end)
     string<delimiter(")inline<inline_delimiter(#{)ident(name)inline_delimiter(})>content([)inline<inline_delimiter(#{)ident(host_id)inline_delimiter(})>content(])inline<inline_delimiter(#{)ident(map)operator(.)ident(inspect)inline_delimiter(})>delimiter(")>
   keyword(end)
change[change(@@)plain( -241,7 +243,7 )change(@@)]
       ident(id)
     keyword(elsif) ident(id)operator(.)ident(is_a?) constant(String)
       keyword(if) ident(id)operator([)regexp<delimiter(/)char(\\w)content(+)delimiter(/)>operator(]) operator(==) ident(id)
delete[delete(-)        ident(id)operator(.)ident(to_sym)]
insert[insert(+)        ident(id)operator(.)eyecatcher<ident(downcase)operator(.)>ident(to_sym)]
       keyword(else)
         ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Invalid id: ')inline<inline_delimiter(#{)ident(id)inline_delimiter(})>content(' given.)delimiter(")>
       keyword(end)
change[change(@@)plain( -278,6 +280,16 )change(@@)]
   keyword(def) method(register_for) operator(*)ident(ids)
     ident(plugin_host)operator(.)ident(register) predefined_constant(self)operator(,) operator(*)ident(ids)
   keyword(end)
insert[insert(+)  ]
insert[insert(+)  comment(# Returns the title of the plugin, or sets it to the)]
insert[insert(+)  comment(# optional argument +title+.)]
insert[insert(+)  keyword(def) method(title) ident(title) operator(=) predefined_constant(nil)]
insert[insert(+)    keyword(if) ident(title)]
insert[insert(+)      instance_variable(@title) operator(=) ident(title)operator(.)ident(to_s)]
insert[insert(+)    keyword(else)]
insert[insert(+)      instance_variable(@title) operator(||=) ident(name)operator([)regexp<delimiter(/)content(([^:]+\)$)delimiter(/)>operator(,) integer(1)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)  keyword(end)]
 
   comment(# The host for this Plugin class.)
   keyword(def) method(plugin_host) ident(host) operator(=) predefined_constant(nil)
change[change(@@)plain( -299,15 +311,23 )change(@@)]
   comment(#)
   comment(# The above example loads the file myplugin/my_helper.rb relative to the)
   comment(# file in which MyPlugin was defined.)
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# You can also load a helper from a different plugin:)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(#  helper 'other_plugin/helper_name')]
   keyword(def) method(helper) operator(*)ident(helpers)
     keyword(for) ident(helper) keyword(in) ident(helpers)
delete[delete(-)      predefined_constant(self)operator(::)constant(PLUGIN_HOST)operator(.)ident(require_helper) ident(plugin_id)operator(,) ident(helper)operator(.)ident(to_s)]
insert[insert(+)      keyword(if) ident(helper)operator(.)ident(is_a?)operator(()constant(String)operator(\)) operator(&&) ident(helper)operator([)regexp<delimiter(/)char(\\/)delimiter(/)>operator(])]
insert[insert(+)        predefined_constant(self)operator(::)constant(PLUGIN_HOST)operator(.)ident(require_helper) global_variable($`)operator(,) global_variable($')]
insert[insert(+)      keyword(else)]
insert[insert(+)        predefined_constant(self)operator(::)constant(PLUGIN_HOST)operator(.)ident(require_helper) ident(plugin_id)operator(,) ident(helper)operator(.)ident(to_s)]
insert[insert(+)      keyword(end)]
     keyword(end)
   keyword(end)
 
   comment(# Returns the pulgin id used by the engine.)
   keyword(def) method(plugin_id)
delete[delete(-)    ident(name)operator([)regexp<delimiter(/)>eyecatcher<regexp<content([)char(\\w)content(_])>>regexp<content(+$)delimiter(/)>operator(])operator(.)ident(downcase)]
insert[insert(+)    ident(name)operator([)regexp<delimiter(/)>eyecatcher<regexp<char(\\w)>>regexp<content(+$)delimiter(/)>operator(])operator(.)ident(downcase)]
   keyword(end)
 
 keyword(end)
head[head(Index: )plain(lib/coderay/helpers/file_type.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/file_type.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/helpers/file_type.rb)plain(	(revision 500\))]
change[change(@@)plain( -35,10 +35,12 )change(@@)]
     keyword(def) method([]) ident(filename)operator(,) ident(read_shebang) operator(=) predefined_constant(false)
       ident(name) operator(=) constant(File)operator(.)ident(basename) ident(filename)
       ident(ext) operator(=) constant(File)operator(.)ident(extname)operator(()ident(name)operator(\))operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)char(\\.)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))  comment(# from last dot, delete the leading dot)
delete[delete(-)      ident(ext2) operator(=) ident(filename)operator([)regexp<delimiter(/)char(\\.)content((.*\))delimiter(/)>operator(,) integer(1)operator(])  comment(# from first dot)]
insert[insert(+)      ident(ext2) operator(=) ident(filename)eyecatcher<operator(.)ident(to_s)>operator([)regexp<delimiter(/)char(\\.)content((.*\))delimiter(/)>operator(,) integer(1)operator(])  comment(# from first dot)]
 
       ident(type) operator(=)
insert[insert(+)        constant(TypeFromExt)operator([)ident(ext)operator(]) operator(||)]
         constant(TypeFromExt)operator([)ident(ext)operator(.)ident(downcase)operator(]) operator(||)
insert[insert(+)        operator(()constant(TypeFromExt)operator([)ident(ext2)operator(]) keyword(if) ident(ext2)operator(\)) operator(||)]
         operator(()constant(TypeFromExt)operator([)ident(ext2)operator(.)ident(downcase)operator(]) keyword(if) ident(ext2)operator(\)) operator(||)
         constant(TypeFromName)operator([)ident(name)operator(]) operator(||)
         constant(TypeFromName)operator([)ident(name)operator(.)ident(downcase)operator(])
change[change(@@)plain( -81,25 +83,46 )change(@@)]
   keyword(end)
 
   constant(TypeFromExt) operator(=) operator({)
delete[delete(-)    string<delimiter(')content(rb)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(rbw)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(rake)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(mab)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(cpp)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
     string<delimiter(')content(c)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)
insert[insert(+)    string<delimiter(')content(css)delimiter(')> operator(=)operator(>) symbol(:css)operator(,)]
insert[insert(+)    string<delimiter(')content(diff)delimiter(')> operator(=)operator(>) symbol(:diff)operator(,)]
insert[insert(+)    string<delimiter(')content(dpr)delimiter(')> operator(=)operator(>) symbol(:delphi)operator(,)]
insert[insert(+)    string<delimiter(')content(groovy)delimiter(')> operator(=)operator(>) symbol(:groovy)operator(,)]
insert[insert(+)    string<delimiter(')content(gvy)delimiter(')> operator(=)operator(>) symbol(:groovy)operator(,)]
     string<delimiter(')content(h)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)
delete[delete(-)    string<delimiter(')content(xml)delimiter(')> operator(=)operator(>) symbol(:xml)operator(,)]
     string<delimiter(')content(htm)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)
     string<delimiter(')content(html)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)
delete[delete(-)    string<delimiter(')content(xhtml)delimiter(')> operator(=)operator(>) symbol(:xhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(html.erb)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(java)delimiter(')> operator(=)operator(>) symbol(:java)operator(,)]
insert[insert(+)    string<delimiter(')content(js)delimiter(')> operator(=)operator(>) symbol(:java_script)operator(,)]
insert[insert(+)    string<delimiter(')content(json)delimiter(')> operator(=)operator(>) symbol(:json)operator(,)]
insert[insert(+)    string<delimiter(')content(mab)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(pas)delimiter(')> operator(=)operator(>) symbol(:delphi)operator(,)]
insert[insert(+)    string<delimiter(')content(patch)delimiter(')> operator(=)operator(>) symbol(:diff)operator(,)]
insert[insert(+)    string<delimiter(')content(php)delimiter(')> operator(=)operator(>) symbol(:php)operator(,)]
insert[insert(+)    string<delimiter(')content(php3)delimiter(')> operator(=)operator(>) symbol(:php)operator(,)]
insert[insert(+)    string<delimiter(')content(php4)delimiter(')> operator(=)operator(>) symbol(:php)operator(,)]
insert[insert(+)    string<delimiter(')content(php5)delimiter(')> operator(=)operator(>) symbol(:php)operator(,)]
insert[insert(+)    string<delimiter(')content(py)delimiter(')> operator(=)operator(>) symbol(:python)operator(,)]
insert[insert(+)    string<delimiter(')content(py3)delimiter(')> operator(=)operator(>) symbol(:python)operator(,)]
insert[insert(+)    string<delimiter(')content(pyw)delimiter(')> operator(=)operator(>) symbol(:python)operator(,)]
insert[insert(+)    string<delimiter(')content(rake)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
     string<delimiter(')content(raydebug)delimiter(')> operator(=)operator(>) symbol(:debug)operator(,)
insert[insert(+)    string<delimiter(')content(rb)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(rbw)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
     string<delimiter(')content(rhtml)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)
delete[delete(-)    string<delimiter(')content(html.erb)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(rxml)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(sch)delimiter(')> operator(=)operator(>) symbol(:scheme)operator(,)]
insert[insert(+)    string<delimiter(')content(sql)delimiter(')> operator(=)operator(>) symbol(:sql)operator(,)]
     string<delimiter(')content(ss)delimiter(')> operator(=)operator(>) symbol(:scheme)operator(,)
delete[delete(-)    string<delimiter(')content(sch)delimiter(')> operator(=)operator(>) symbol(:scheme)operator(,)]
insert[insert(+)    string<delimiter(')content(xhtml)delimiter(')> operator(=)operator(>) symbol(:xhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(xml)delimiter(')> operator(=)operator(>) symbol(:xml)operator(,)]
     string<delimiter(')content(yaml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)
     string<delimiter(')content(yml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)
   operator(})
insert[insert(+)  keyword(for) ident(cpp_alias) keyword(in) string<delimiter(%w[)content(cc cpp cp cxx c++ C hh hpp h++ cu)delimiter(])>]
insert[insert(+)    constant(TypeFromExt)operator([)ident(cpp_alias)operator(]) operator(=) symbol(:cpp)]
insert[insert(+)  keyword(end)]
 
   constant(TypeFromShebang) operator(=) regexp<delimiter(/)char(\\b)content((?:ruby|perl|python|sh\))char(\\b)delimiter(/)>
 
change[change(@@)plain( -114,13 +137,13 )change(@@)]
 
 keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)
   global_variable($VERBOSE) operator(=) predefined_constant(true)
delete[delete(-)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__)eyecatcher<operator(+)>integer(4)]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__)eyecatcher< operator(+) >integer(4)]
 keyword(end)
 
 ident(__END__)
 ident(require) string<delimiter(')content(test/unit)delimiter(')>
 
delete[delete(-)keyword(class) eyecatcher<class(TC_FileType)> operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)keyword(class) eyecatcher<class(FileTypeTests)> operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
   
   ident(include) constant(CodeRay)
   
change[change(@@)plain( -150,6 +173,8 )change(@@)]
 
   keyword(def) method(test_ruby)
     ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test.rb)delimiter(')>operator(])
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test.java.rb)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:java)operator(,) constant(FileType)operator([)string<delimiter(')content(test.rb.java)delimiter(')>operator(])]
     ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(C:)char(\\\\)content(Program Files)char(\\\\)content(x)char(\\\\)content(y)char(\\\\)content(c)char(\\\\)content(test.rbw)delimiter(')>operator(])
     ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(/usr/bin/something/Rakefile)delimiter(')>operator(])
     ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(~/myapp/gem/Rantfile)delimiter(')>operator(])
change[change(@@)plain( -169,6 +194,17 )change(@@)]
     ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(~/projects/blabla/c)delimiter(')>operator(])
   keyword(end)
 
insert[insert(+)  keyword(def) method(test_cpp)]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c++)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.cxx)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.hh)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.hpp)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.cu)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.C)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:cpp)operator(,) constant(FileType)operator([)string<delimiter(')content(test.h)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
   keyword(def) method(test_html)
     ident(assert_equal) symbol(:html)operator(,) constant(FileType)operator([)string<delimiter(')content(test.htm)delimiter(')>operator(])
     ident(assert_equal) symbol(:xhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.xhtml)delimiter(')>operator(])
change[change(@@)plain( -184,6 +220,15 )change(@@)]
     ident(assert_not_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(YAML)delimiter(')>operator(])
   keyword(end)
 
insert[insert(+)  keyword(def) method(test_pathname)]
insert[insert(+)    ident(require) string<delimiter(')content(pathname)delimiter(')>]
insert[insert(+)    ident(pn) operator(=) constant(Pathname)operator(.)ident(new) string<delimiter(')content(test.rb)delimiter(')>]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)ident(pn)operator(])]
insert[insert(+)    ident(dir) operator(=) constant(Pathname)operator(.)ident(new) string<delimiter(')content(/etc/var/blubb)delimiter(')>]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)ident(dir) operator(+) ident(pn)operator(])]
insert[insert(+)    ident(assert_equal) symbol(:cpp)operator(,) constant(FileType)operator([)ident(dir) operator(+) string<delimiter(')content(test.cpp)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
   keyword(def) method(test_no_shebang)
     ident(dir) operator(=) string<delimiter(')content(./test)delimiter(')>
     keyword(if) constant(File)operator(.)ident(directory?) ident(dir)
head[head(Index: )plain(lib/coderay/helpers/gzip_simple.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/gzip_simple.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/helpers/gzip_simple.rb)plain(	(revision 500\))]
change[change(@@)plain( -2,7 +2,7 )change(@@)]
 comment(#)
 comment(# A simplified interface to the gzip library +zlib+ (from the Ruby Standard Library.\))
 comment(#)
delete[delete(-)comment(# Author: murphy (mail to murphy )eyecatcher<comment(cYcnus)>comment( de\))]
insert[insert(+)comment(# Author: murphy (mail to murphy )eyecatcher<comment(rubychan)>comment( de\))]
 comment(#)
 comment(# Version: 0.2 (2005.may.28\))
 comment(#)
head[head(Index: )plain(lib/coderay/helpers/word_list.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/word_list.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/helpers/word_list.rb)plain(	(revision 500\))]
change[change(@@)plain( -98,17 +98,24 )change(@@)]
   comment(# Creates a new case-insensitive WordList with +default+ as default value.)
   comment(# )
   comment(# You can activate caching to store the results for every [] request.)
insert[insert(+)  comment(# This speeds up subsequent lookups for the same word, but also)]
insert[insert(+)  comment(# uses memory.)]
   keyword(def) method(initialize) ident(default) operator(=) predefined_constant(false)operator(,) ident(caching) operator(=) predefined_constant(false)
     keyword(if) ident(caching)
       keyword(super)operator(()ident(default)operator(,) predefined_constant(false)operator(\)) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)
         ident(h)operator([)ident(k)operator(]) operator(=) ident(h)operator(.)ident(fetch) ident(k)operator(.)ident(downcase)operator(,) ident(default)
       keyword(end)
     keyword(else)
delete[delete(-)      keyword(def) predefined_constant(self)operator(.)method([]) ident(key)  comment(# :nodoc:)]
delete[delete(-)        keyword(super)operator(()ident(key)operator(.)ident(downcase)operator(\))]
delete[delete(-)      keyword(end)]
insert[insert(+)      keyword(super)operator(()ident(default)operator(,) predefined_constant(false)operator(\))]
insert[insert(+)      ident(extend) constant(Uncached)]
     keyword(end)
   keyword(end)
insert[insert(+)  ]
insert[insert(+)  keyword(module) class(Uncached)  comment(# :nodoc:)]
insert[insert(+)    keyword(def) method([]) ident(key)]
insert[insert(+)      keyword(super)operator(()ident(key)operator(.)ident(downcase)operator(\))]
insert[insert(+)    keyword(end)]
insert[insert(+)  keyword(end)]
 
   comment(# Add +words+ to the list and associate them with +kind+.)
   keyword(def) method(add) ident(words)operator(,) ident(kind) operator(=) predefined_constant(true)
change[change(@@)plain( -120,4 +127,12 )change(@@)]
 
 keyword(end)
 
delete[delete(-)keyword(end)]
comment(\\ No newline at end of file)
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)comment(# check memory consumption)]
insert[insert(+)keyword(END) operator({)]
insert[insert(+)  constant(ObjectSpace)operator(.)ident(each_object)operator(()constant(CodeRay)operator(::)constant(CaseIgnoringWordList)operator(\)) keyword(do) operator(|)ident(wl)operator(|)]
insert[insert(+)    ident(p) ident(wl)operator(.)ident(inject)operator(()integer(0)operator(\)) operator({) operator(|)ident(memo)operator(,) ident(key)operator(,) ident(value)operator(|) ident(memo) operator(+) ident(key)operator(.)ident(size) operator(+) integer(24) operator(})]
insert[insert(+)  keyword(end)]
insert[insert(+)operator(})]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/style.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/style.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/style.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,20 +1,23 )change(@@)]
 keyword(module) class(CodeRay)
 
   comment(# This module holds the Style class and its subclasses.)
delete[delete(-)  comment(#)]
insert[insert(+)  comment(#)eyecatcher<comment( )>]
   comment(# See Plugin.)
   keyword(module) class(Styles)
     ident(extend) constant(PluginHost)
     ident(plugin_path) constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(styles)delimiter(')>
delete[delete(-)]
insert[insert(+)    ]
insert[insert(+)    comment(# Base class for styles.)]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# Styles are used by Encoders::HTML to colorize tokens.)]
     keyword(class) class(Style)
       ident(extend) constant(Plugin)
       ident(plugin_host) constant(Styles)
delete[delete(-)]
delete[delete(-)      constant(DEFAULT_OPTIONS) operator(=) operator({) operator(})]
delete[delete(-)]
insert[insert(+)eyecatcher<      >]
insert[insert(+)      constant(DEFAULT_OPTIONS) operator(=) operator({) operator(})eyecatcher<  comment(# :nodoc:)>]
insert[insert(+)eyecatcher<      >]
     keyword(end)
delete[delete(-)]
insert[insert(+)eyecatcher<    >]
   keyword(end)
delete[delete(-)]
insert[insert(+)eyecatcher<  >]
 keyword(end)
head[head(Index: )plain(lib/coderay/styles/cycnus.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/styles/cycnus.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/styles/cycnus.rb)plain(	(revision 500\))]
change[change(@@)plain( -8,7 +8,7 )change(@@)]
     ident(code_background) operator(=) string<delimiter(')content(#f8f8f8)delimiter(')>
     ident(numbers_background) operator(=) string<delimiter(')content(#def)delimiter(')>
     ident(border_color) operator(=) string<delimiter(')content(silver)delimiter(')>
delete[delete(-)    ident(normal_color) operator(=) string<delimiter(')content(#)>eyecatcher<string<content(1)>>string<content(00)delimiter(')>]
insert[insert(+)    ident(normal_color) operator(=) string<delimiter(')content(#)>eyecatcher<string<content(0)>>string<content(00)delimiter(')>]
 
     constant(CSS_MAIN_STYLES) operator(=) string<delimiter(<<-MAIN)>
string<content( .CodeRay {)>
change[change(@@)plain( -32,6 +32,7 )change(@@)]
   ident(text)operator(-)key(align)operator(:) ident(right)operator(;)
 operator(})
 operator(.)ident(CodeRay) operator(.)ident(line_numbers) ident(tt) operator({) ident(font)operator(-)key(weight)operator(:) ident(bold) operator(})
insert[insert(+)operator(.)ident(CodeRay) operator(.)ident(line_numbers) operator(.)ident(highlighted) operator({) key(color)operator(:) ident(red) operator(})]
 operator(.)ident(CodeRay) operator(.)ident(no) operator({) key(padding)operator(:) integer(0)ident(px) integer(4)ident(px) operator(})
 operator(.)ident(CodeRay) operator(.)ident(code) operator({) key(width)operator(:) integer(100)operator(%) operator(})
 
change[change(@@)plain( -46,28 +47,32 )change(@@)]
 
 operator(.)ident(af) operator({) key(color)operator(:)comment(#00C })
 operator(.)ident(an) operator({) key(color)operator(:)comment(#007 })
insert[insert(+)operator(.)ident(at) operator({) key(color)operator(:)comment(#f08 })]
 operator(.)ident(av) operator({) key(color)operator(:)comment(#700 })
 operator(.)ident(aw) operator({) key(color)operator(:)comment(#C00 })
 operator(.)ident(bi) operator({) key(color)operator(:)comment(#509; font-weight:bold })
delete[delete(-)operator(.)ident(c)  operator({) key(color)operator(:)comment(#)eyecatcher<comment(666)>comment(; })]
insert[insert(+)operator(.)ident(c)  operator({) key(color)operator(:)comment(#)eyecatcher<comment(888)>comment(; })]
 
 operator(.)ident(ch) operator({) key(color)operator(:)comment(#04D })
 operator(.)ident(ch) operator(.)ident(k) operator({) key(color)operator(:)comment(#04D })
 operator(.)ident(ch) operator(.)ident(dl) operator({) key(color)operator(:)comment(#039 })
 
 operator(.)ident(cl) operator({) key(color)operator(:)comment(#B06; font-weight:bold })
insert[insert(+)operator(.)ident(cm) operator({) key(color)operator(:)comment(#A08; font-weight:bold })]
 operator(.)ident(co) operator({) key(color)operator(:)comment(#036; font-weight:bold })
 operator(.)ident(cr) operator({) key(color)operator(:)comment(#0A0 })
 operator(.)ident(cv) operator({) key(color)operator(:)comment(#369 })
insert[insert(+)operator(.)ident(de) operator({) key(color)operator(:)comment(#B0B; })]
 operator(.)ident(df) operator({) key(color)operator(:)comment(#099; font-weight:bold })
 operator(.)ident(di) operator({) key(color)operator(:)comment(#088; font-weight:bold })
 operator(.)ident(dl) operator({) key(color)operator(:)ident(black) operator(})
 operator(.)ident(do) operator({) key(color)operator(:)comment(#970 })
insert[insert(+)operator(.)ident(dt) operator({) key(color)operator(:)comment(#34b })]
 operator(.)ident(ds) operator({) key(color)operator(:)comment(#D42; font-weight:bold })
 operator(.)ident(e)  operator({) key(color)operator(:)comment(#666; font-weight:bold })
 operator(.)ident(en) operator({) key(color)operator(:)comment(#800; font-weight:bold })
 operator(.)ident(er) operator({) key(color)operator(:)comment(#F00; background-color:#FAA })
delete[delete(-)operator(.)ident(ex) operator({) key(color)operator(:)comment(#)eyecatcher<comment(F)>comment(00; font-weight:bold })]
insert[insert(+)operator(.)ident(ex) operator({) key(color)operator(:)comment(#)eyecatcher<comment(C)>comment(00; font-weight:bold })]
 operator(.)ident(fl) operator({) key(color)operator(:)comment(#60E; font-weight:bold })
 operator(.)ident(fu) operator({) key(color)operator(:)comment(#06B; font-weight:bold })
 operator(.)ident(gv) operator({) key(color)operator(:)comment(#d70; font-weight:bold })
change[change(@@)plain( -75,11 +80,13 )change(@@)]
 operator(.)ident(i)  operator({) key(color)operator(:)comment(#00D; font-weight:bold })
 operator(.)ident(ic) operator({) key(color)operator(:)comment(#B44; font-weight:bold })
 
delete[delete(-)operator(.)ident(il) operator({) key(background)operator(:) comment(#eee })]
delete[delete(-)operator(.)ident(il) operator(.)ident(il) operator({) key(background)operator(:) comment(#ddd })]
delete[delete(-)operator(.)ident(il) operator(.)ident(il) operator(.)ident(il) operator({) key(background)operator(:) comment(#ccc })]
delete[delete(-)operator(.)ident(il) operator(.)ident(idl) operator({) ident(font)operator(-)key(weight)operator(:) ident(bold)operator(;) key(color)operator(:) comment(#888 })]
insert[insert(+)operator(.)ident(il) operator({) key(background)operator(:) comment(#ddd; color: black })]
insert[insert(+)operator(.)ident(il) operator(.)ident(il) operator({) key(background)operator(:) comment(#ccc })]
insert[insert(+)operator(.)ident(il) operator(.)ident(il) operator(.)ident(il) operator({) key(background)operator(:) comment(#bbb })]
insert[insert(+)operator(.)ident(il) operator(.)ident(idl) operator({) key(background)operator(:) comment(#ddd; font-weight: bold; color: #666 })]
insert[insert(+)operator(.)ident(idl) operator({) ident(background)operator(-)key(color)operator(:) comment(#bbb; font-weight: bold; color: #666; })]
 
insert[insert(+)operator(.)ident(im) operator({) key(color)operator(:)comment(#f00; })]
 operator(.)ident(in) operator({) key(color)operator(:)comment(#B2B; font-weight:bold })
 operator(.)ident(iv) operator({) key(color)operator(:)comment(#33B })
 operator(.)ident(la) operator({) key(color)operator(:)comment(#970; font-weight:bold })
change[change(@@)plain( -89,24 +96,31 )change(@@)]
 operator(.)ident(op) operator({) operator(})
 operator(.)ident(pc) operator({) key(color)operator(:)comment(#038; font-weight:bold })
 operator(.)ident(pd) operator({) key(color)operator(:)comment(#369; font-weight:bold })
delete[delete(-)operator(.)ident(pp) operator({) key(color)operator(:)comment(#579 })]
delete[delete(-)operator(.)ident(pt) operator({) key(color)operator(:)comment(#339; font-weight:bold })]
delete[delete(-)operator(.)ident(r)  operator({) key(color)operator(:)comment(#080; font-weight:bold })]
insert[insert(+)operator(.)ident(pp) operator({) key(color)operator(:)comment(#579; })]
insert[insert(+)operator(.)ident(ps) operator({) key(color)operator(:)comment(#00C; font-weight:bold })]
insert[insert(+)operator(.)ident(pt) operator({) key(color)operator(:)comment(#074; font-weight:bold })]
insert[insert(+)operator(.)ident(r)operator(,) operator(.)ident(kw)  operator({) key(color)operator(:)comment(#080; font-weight:bold })]
 
insert[insert(+)operator(.)ident(ke) operator({) key(color)operator(:) comment(#808; })]
insert[insert(+)operator(.)ident(ke) operator(.)ident(dl) operator({) key(color)operator(:) comment(#606; })]
insert[insert(+)operator(.)ident(ke) operator(.)ident(ch) operator({) key(color)operator(:) comment(#80f; })]
insert[insert(+)operator(.)ident(vl) operator({) key(color)operator(:) comment(#088; })]
insert[insert(+)]
 operator(.)ident(rx) operator({) ident(background)operator(-)key(color)operator(:)comment(#fff0ff })
 operator(.)ident(rx) operator(.)ident(k) operator({) key(color)operator(:)comment(#808 })
 operator(.)ident(rx) operator(.)ident(dl) operator({) key(color)operator(:)comment(#404 })
 operator(.)ident(rx) operator(.)ident(mod) operator({) key(color)operator(:)comment(#C2C })
 operator(.)ident(rx) operator(.)ident(fu)  operator({) key(color)operator(:)comment(#404; font-weight: bold })
 
delete[delete(-)operator(.)ident(s)  operator({) ident(background)operator(-)key(color)operator(:)comment(#fff0f0 })]
delete[delete(-)operator(.)ident(s)  operator(.)ident(s) operator({) ident(background)operator(-)key(color)operator(:)comment(#ffe0e0 })]
delete[delete(-)operator(.)ident(s)  operator(.)ident(s)  operator(.)ident(s) operator({) ident(background)operator(-)key(color)operator(:)comment(#ffd0d0 })]
delete[delete(-)operator(.)ident(s)  operator(.)ident(k) operator({) key(color)operator(:)comment(#D20 })]
delete[delete(-)operator(.)ident(s)  operator(.)ident(dl) operator({) key(color)operator(:)comment(#710 })]
insert[insert(+)operator(.)ident(s) operator({) ident(background)operator(-)key(color)operator(:)comment(#fff0f0; color: #D20; })]
insert[insert(+)operator(.)ident(s) operator(.)ident(s) operator({) ident(background)operator(-)key(color)operator(:)comment(#ffe0e0 })]
insert[insert(+)operator(.)ident(s) operator(.)ident(s)  operator(.)ident(s) operator({) ident(background)operator(-)key(color)operator(:)comment(#ffd0d0 })]
insert[insert(+)operator(.)ident(s) operator(.)ident(k) operator({) operator(})]
insert[insert(+)operator(.)ident(s) operator(.)ident(ch) operator({) key(color)operator(:) comment(#b0b; })]
insert[insert(+)operator(.)ident(s) operator(.)ident(dl) operator({) key(color)operator(:) comment(#710; })]
 
delete[delete(-)operator(.)ident(sh) operator({) ident(background)operator(-)key(color)operator(:)comment(#f0fff0)comment( })]
delete[delete(-)operator(.)ident(sh) operator(.)ident(k) operator({) eyecatcher<key(color)operator(:)comment(#2B2 )>comment(})]
insert[insert(+)operator(.)ident(sh) operator({) ident(background)operator(-)key(color)operator(:)comment(#f0fff0)eyecatcher<comment(; color:#2B2)>comment( })]
insert[insert(+)operator(.)ident(sh) operator(.)ident(k) operator({) operator(})]
 operator(.)ident(sh) operator(.)ident(dl) operator({) key(color)operator(:)comment(#161 })
 
 operator(.)ident(sy) operator({) key(color)operator(:)comment(#A60 })
change[change(@@)plain( -119,6 +133,16 )change(@@)]
 operator(.)ident(ty) operator({) key(color)operator(:)comment(#339; font-weight:bold })
 operator(.)ident(v)  operator({) key(color)operator(:)comment(#036 })
 operator(.)ident(xt) operator({) key(color)operator(:)comment(#444 })
insert[insert(+)]
insert[insert(+)operator(.)ident(ins) operator({) key(background)operator(:) comment(#afa; })]
insert[insert(+)operator(.)ident(del) operator({) key(background)operator(:) comment(#faa; })]
insert[insert(+)operator(.)ident(chg) operator({) key(color)operator(:) comment(#aaf; background: #007; })]
insert[insert(+)operator(.)ident(head) operator({) key(color)operator(:) comment(#f8f; background: #505 })]
insert[insert(+)]
insert[insert(+)operator(.)ident(ins) operator(.)ident(ins) operator({) key(color)operator(:) comment(#080; font-weight:bold })]
insert[insert(+)operator(.)ident(del) operator(.)ident(del) operator({) key(color)operator(:) comment(#800; font-weight:bold })]
insert[insert(+)operator(.)ident(chg) operator(.)ident(chg) operator({) key(color)operator(:) comment(#66f; })]
insert[insert(+)operator(.)ident(head) operator(.)ident(head) operator({) key(color)operator(:) comment(#f4f; })]
     constant(TOKENS)
 
   keyword(end)
head[head(Index: )plain(lib/coderay/styles/murphy.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/styles/murphy.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/styles/murphy.rb)plain(	(revision 500\))]
change[change(@@)plain( -84,7 +84,10 )change(@@)]
 operator(.)ident(pp) operator({) key(color)operator(:)comment(#579; })
 operator(.)ident(pt) operator({) key(color)operator(:)comment(#66f; font-weight:bold; })
 operator(.)ident(r)  operator({) key(color)operator(:)comment(#5de; font-weight:bold; })
insert[insert(+)operator(.)ident(r)operator(,) operator(.)ident(kw)  operator({) key(color)operator(:)comment(#5de; font-weight:bold })]
 
insert[insert(+)operator(.)ident(ke) operator({) key(color)operator(:) comment(#808; })]
insert[insert(+)]
 operator(.)ident(rx) operator({) ident(background)operator(-)key(color)operator(:)comment(#221133; })
 operator(.)ident(rx) operator(.)ident(k) operator({) key(color)operator(:)comment(#f8f; })
 operator(.)ident(rx) operator(.)ident(dl) operator({) key(color)operator(:)comment(#f0f; })
change[change(@@)plain( -111,6 +114,16 )change(@@)]
 operator(.)ident(ty) operator({) key(color)operator(:)comment(#339; font-weight:bold; })
 operator(.)ident(v)  operator({) key(color)operator(:)comment(#036; })
 operator(.)ident(xt) operator({) key(color)operator(:)comment(#444; })
insert[insert(+)]
insert[insert(+)operator(.)ident(ins) operator({) key(background)operator(:) comment(#afa; })]
insert[insert(+)operator(.)ident(del) operator({) key(background)operator(:) comment(#faa; })]
insert[insert(+)operator(.)ident(chg) operator({) key(color)operator(:) comment(#aaf; background: #007; })]
insert[insert(+)operator(.)ident(head) operator({) key(color)operator(:) comment(#f8f; background: #505 })]
insert[insert(+)]
insert[insert(+)operator(.)ident(ins) operator(.)ident(ins) operator({) key(color)operator(:) comment(#080; font-weight:bold })]
insert[insert(+)operator(.)ident(del) operator(.)ident(del) operator({) key(color)operator(:) comment(#800; font-weight:bold })]
insert[insert(+)operator(.)ident(chg) operator(.)ident(chg) operator({) key(color)operator(:) comment(#66f; })]
insert[insert(+)operator(.)ident(head) operator(.)ident(head) operator({) key(color)operator(:) comment(#f4f; })]
     constant(TOKENS)
 
   keyword(end)
head[head(Index: )plain(lib/coderay/styles/alpha.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/styles/alpha.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/styles/alpha.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,145 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Styles)]
insert[insert(+)  ]
insert[insert(+)  comment(# A colorful theme using CSS 3 colors (with alpha channel\).)]
insert[insert(+)  keyword(class) class(Alpha) operator(<) constant(Style)]
insert[insert(+)]
insert[insert(+)    ident(register_for) symbol(:alpha)]
insert[insert(+)]
insert[insert(+)    ident(code_background) operator(=) string<delimiter(')content(#f8f8f8)delimiter(')>]
insert[insert(+)    ident(numbers_background) operator(=) string<delimiter(')content(#def)delimiter(')>]
insert[insert(+)    ident(border_color) operator(=) string<delimiter(')content(silver)delimiter(')>]
insert[insert(+)    ident(normal_color) operator(=) string<delimiter(')content(#000)delimiter(')>]
insert[insert(+)]
insert[insert(+)    constant(CSS_MAIN_STYLES) operator(=) string<delimiter(<<-MAIN)>  comment(# :nodoc:)]
insert[insert(+)string<content(.CodeRay {)>]
insert[insert(+)string<content(  background-color: )inline<inline_delimiter(#{)ident(code_background)inline_delimiter(})>content(;)>]
insert[insert(+)string<content(  border: 1px solid )inline<inline_delimiter(#{)ident(border_color)inline_delimiter(})>content(;)>]
insert[insert(+)string<content(  font-family: 'Courier New', 'Terminal', monospace;)>]
insert[insert(+)string<content(  color: )inline<inline_delimiter(#{)ident(normal_color)inline_delimiter(})>content(;)>]
insert[insert(+)string<content(})>]
insert[insert(+)string<content(.CodeRay pre { margin: 0px })>]
insert[insert(+)]
insert[insert(+)string<content(div.CodeRay { })>]
insert[insert(+)]
insert[insert(+)string<content(span.CodeRay { white-space: pre; border: 0px; padding: 2px })>]
insert[insert(+)]
insert[insert(+)string<content(table.CodeRay { border-collapse: collapse; width: 100%; padding: 2px })>]
insert[insert(+)string<content(table.CodeRay td { padding: 2px 4px; vertical-align: top })>]
insert[insert(+)]
insert[insert(+)string<content(.CodeRay .line_numbers, .CodeRay .no {)>]
insert[insert(+)string<content(  background-color: )inline<inline_delimiter(#{)ident(numbers_background)inline_delimiter(})>content(;)>]
insert[insert(+)string<content(  color: gray;)>]
insert[insert(+)string<content(  text-align: right;)>]
insert[insert(+)string<content(})>]
insert[insert(+)string<content(.CodeRay .line_numbers tt { font-weight: bold })>]
insert[insert(+)string<content(.CodeRay .line_numbers .highlighted { color: red })>]
insert[insert(+)string<content(.CodeRay .no { padding: 0px 4px })>]
insert[insert(+)string<content(.CodeRay .code { width: 100% })>]
insert[insert(+)]
insert[insert(+)string<content(ol.CodeRay { font-size: 10pt })>]
insert[insert(+)string<content(ol.CodeRay li { white-space: pre })>]
insert[insert(+)]
insert[insert(+)string<content(.CodeRay .code pre { overflow: auto })>]
insert[insert(+)string<delimiter(    MAIN)>]
insert[insert(+)]
insert[insert(+)    constant(TOKEN_COLORS) operator(=) string<delimiter(<<-'TOKENS')>]
insert[insert(+)string<content(.debug { color:white ! important; background:blue ! important; })>]
insert[insert(+)]
insert[insert(+)string<content(.an { color:#007 })>]
insert[insert(+)string<content(.at { color:#f08 })>]
insert[insert(+)string<content(.av { color:#700 })>]
insert[insert(+)string<content(.bi { color:#509; font-weight:bold })>]
insert[insert(+)string<content(.c  { color:#888; })>]
insert[insert(+)]
insert[insert(+)string<content(.ch { color:#04D })>]
insert[insert(+)string<content(.ch .k { color:#04D })>]
insert[insert(+)string<content(.ch .dl { color:#039 })>]
insert[insert(+)]
insert[insert(+)string<content(.cl { color:#B06; font-weight:bold })>]
insert[insert(+)string<content(.cm { color:#A08; font-weight:bold })>]
insert[insert(+)string<content(.co { color:#036; font-weight:bold })>]
insert[insert(+)string<content(.cr { color:#0A0 })>]
insert[insert(+)string<content(.cv { color:#369 })>]
insert[insert(+)string<content(.de { color:#B0B; })>]
insert[insert(+)string<content(.df { color:#099; font-weight:bold })>]
insert[insert(+)string<content(.di { color:#088; font-weight:bold })>]
insert[insert(+)string<content(.dl { color:black })>]
insert[insert(+)string<content(.do { color:#970 })>]
insert[insert(+)string<content(.dt { color:#34b })>]
insert[insert(+)string<content(.ds { color:#D42; font-weight:bold })>]
insert[insert(+)string<content(.e  { color:#666; font-weight:bold })>]
insert[insert(+)string<content(.en { color:#800; font-weight:bold })>]
insert[insert(+)string<content(.er { color:#F00; background-color:#FAA })>]
insert[insert(+)string<content(.ex { color:#C00; font-weight:bold })>]
insert[insert(+)string<content(.fl { color:#60E; font-weight:bold })>]
insert[insert(+)string<content(.fu { color:#06B; font-weight:bold })>]
insert[insert(+)string<content(.gv { color:#d70; font-weight:bold })>]
insert[insert(+)string<content(.hx { color:#058; font-weight:bold })>]
insert[insert(+)string<content(.i  { color:#00D; font-weight:bold })>]
insert[insert(+)string<content(.ic { color:#B44; font-weight:bold })>]
insert[insert(+)]
insert[insert(+)string<content(.il { background: hsla(0,0%,0%,0.1\); color: black })>]
insert[insert(+)string<content(.il .idl { font-weight: bold; color: #666 })>]
insert[insert(+)string<content(.idl { font-weight: bold; color: #666; })>]
insert[insert(+)]
insert[insert(+)string<content(.im { color:#f00; })>]
insert[insert(+)string<content(.in { color:#B2B; font-weight:bold })>]
insert[insert(+)string<content(.iv { color:#33B })>]
insert[insert(+)string<content(.la { color:#970; font-weight:bold })>]
insert[insert(+)string<content(.lv { color:#963 })>]
insert[insert(+)string<content(.oc { color:#40E; font-weight:bold })>]
insert[insert(+)string<content(.op { })>]
insert[insert(+)string<content(.pc { color:#038; font-weight:bold })>]
insert[insert(+)string<content(.pd { color:#369; font-weight:bold })>]
insert[insert(+)string<content(.pp { color:#579; })>]
insert[insert(+)string<content(.ps { color:#00C; font-weight:bold })>]
insert[insert(+)string<content(.pt { color:#074; font-weight:bold })>]
insert[insert(+)string<content(.r, .kw  { color:#080; font-weight:bold })>]
insert[insert(+)]
insert[insert(+)string<content(.ke { color: #808; })>]
insert[insert(+)string<content(.ke .dl { color: #606; })>]
insert[insert(+)string<content(.ke .ch { color: #80f; })>]
insert[insert(+)string<content(.vl { color: #088; })>]
insert[insert(+)]
insert[insert(+)string<content(.rx { background-color:hsla(300,100%,50%,0.1\); })>]
insert[insert(+)string<content(.rx .k { color:#808 })>]
insert[insert(+)string<content(.rx .dl { color:#404 })>]
insert[insert(+)string<content(.rx .mod { color:#C2C })>]
insert[insert(+)string<content(.rx .fu  { color:#404; font-weight: bold })>]
insert[insert(+)]
insert[insert(+)string<content(.s { background-color:hsla(0,100%,50%,0.1\); color: #D20; })>]
insert[insert(+)string<content(.s .k { })>]
insert[insert(+)string<content(.s .ch { color: #b0b; })>]
insert[insert(+)string<content(.s .dl { color: #710; })>]
insert[insert(+)]
insert[insert(+)string<content(.sh { background-color:hsla(120,100%,50%,0.1\); color:#2B2 })>]
insert[insert(+)string<content(.sh .k { })>]
insert[insert(+)string<content(.sh .dl { color:#161 })>]
insert[insert(+)]
insert[insert(+)string<content(.sy { color:#A60 })>]
insert[insert(+)string<content(.sy .k { color:#A60 })>]
insert[insert(+)string<content(.sy .dl { color:#630 })>]
insert[insert(+)]
insert[insert(+)string<content(.ta { color:#070 })>]
insert[insert(+)string<content(.ts { color:#D70; font-weight:bold })>]
insert[insert(+)string<content(.ty { color:#339; font-weight:bold })>]
insert[insert(+)string<content(.v  { color:#036 })>]
insert[insert(+)string<content(.xt { color:#444 })>]
insert[insert(+)]
insert[insert(+)string<content(.ins { background: #afa; })>]
insert[insert(+)string<content(.del { background: #faa; })>]
insert[insert(+)string<content(.chg { color: #aaf; background: #007; })>]
insert[insert(+)string<content(.head { color: #f8f; background: #505 })>]
insert[insert(+)string<content(.head .filename { color: white; })>]
insert[insert(+)]
insert[insert(+)string<content(.ins .ins { color: #080; font-weight:bold })>]
insert[insert(+)string<content(.del .del { color: #800; font-weight:bold })>]
insert[insert(+)string<content(.chg .chg { color: #66f; })>]
insert[insert(+)string<content(.head .head { color: #f4f; })>]
insert[insert(+)string<delimiter(    TOKENS)>]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/tokens.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/tokens.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/tokens.rb)plain(	(revision 500\))]
change[change(@@)plain( -14,7 +14,7 )change(@@)]
   comment(#)
   comment(#   [:comment, '# It looks like this'])
   comment(#   [:float, '3.1415926'])
delete[delete(-)  comment(#   [:error, ')eyecatcher<comment()>comment('])]
insert[insert(+)  comment(#   [:error, ')eyecatcher<comment($^)>comment('])]
   comment(#)
   comment(# Some scanners also yield some kind of sub-tokens, represented by special)
   comment(# token texts, namely :open and :close .)
change[change(@@)plain( -46,47 +46,10 )change(@@)]
   comment(#)
   comment(# Tokens' subclass TokenStream allows streaming to save memory.)
   keyword(class) class(Tokens) operator(<) constant(Array)
delete[delete(-)]
delete[delete(-)    keyword(class) operator(<<) class(self)]
delete[delete(-)]
delete[delete(-)      comment(# Convert the token to a string.)]
delete[delete(-)      comment(#)]
delete[delete(-)      comment(# This format is used by Encoders.Tokens.)]
delete[delete(-)      comment(# It can be reverted using read_token.)]
delete[delete(-)      keyword(def) method(write_token) ident(text)operator(,) ident(type)]
delete[delete(-)        keyword(if) ident(text)operator(.)ident(is_a?) constant(String)]
delete[delete(-)          string<delimiter(")inline<inline_delimiter(#{)ident(type)inline_delimiter(})>char(\\t)inline<inline_delimiter(#{)ident(escape)operator(()ident(text)operator(\))inline_delimiter(})>char(\\n)delimiter(")>]
delete[delete(-)        keyword(else)]
delete[delete(-)          string<delimiter(")content(:)inline<inline_delimiter(#{)ident(text)inline_delimiter(})>char(\\t)inline<inline_delimiter(#{)ident(type)inline_delimiter(})>char(\\t)char(\\n)delimiter(")>]
delete[delete(-)        keyword(end)]
delete[delete(-)      keyword(end)]
delete[delete(-)]
delete[delete(-)      comment(# Read a token from the string.)]
delete[delete(-)      comment(#)]
delete[delete(-)      comment(# Inversion of write_token.)]
delete[delete(-)      comment(#)]
delete[delete(-)      comment(# TODO Test this!)]
delete[delete(-)      keyword(def) method(read_token) ident(token)]
delete[delete(-)        ident(type)operator(,) ident(text) operator(=) ident(token)operator(.)ident(split)operator(()string<delimiter(")char(\\t)delimiter(")>operator(,) integer(2)operator(\))]
delete[delete(-)        keyword(if) ident(type)operator([)integer(0)operator(]) operator(==) integer(?:)]
delete[delete(-)          operator([)ident(text)operator(.)ident(to_sym)operator(,) ident(type)operator([)integer(1)operator(..)integer(-1)operator(])operator(.)ident(to_sym)operator(])]
delete[delete(-)        keyword(else)]
delete[delete(-)          operator([)ident(type)operator(.)ident(to_sym)operator(,) ident(unescape)operator(()ident(text)operator(\))operator(])]
delete[delete(-)        keyword(end)]
delete[delete(-)      keyword(end)]
delete[delete(-)]
delete[delete(-)      comment(# Escapes a string for use in write_token.)]
delete[delete(-)      keyword(def) method(escape) ident(text)]
delete[delete(-)        ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)content([)char(\\n)char(\\\\)content(])delimiter(/)>operator(,) string<delimiter(')char(\\\\)char(\\\\)content(\\&)delimiter(')>operator(\))]
delete[delete(-)      keyword(end)]
delete[delete(-)]
delete[delete(-)      comment(# Unescapes a string created by escape.)]
delete[delete(-)      keyword(def) method(unescape) ident(text)]
delete[delete(-)        ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content([)char(\\n)char(\\\\)content(])delimiter(/)>operator(\)) operator({) operator(|)ident(m)operator(|) ident(m)operator([)integer(1)operator(,)integer(1)operator(]) operator(})]
delete[delete(-)      keyword(end)]
delete[delete(-)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
insert[insert(+)    ]
insert[insert(+)    comment(# The Scanner instance that created the tokens.)]
insert[insert(+)    ident(attr_accessor) symbol(:scanner)]
insert[insert(+)    ]
     comment(# Whether the object is a TokenStream.)
     comment(#)
     comment(# Returns false.)
change[change(@@)plain( -146,7 +109,6 )change(@@)]
       ident(encode) symbol(:text)operator(,) ident(options)
     keyword(end)
 
delete[delete(-)]
     comment(# Redirects unknown methods to encoder calls.)
     comment(#)
     comment(# For example, if you call +tokens.html+, the HTML encoder)
change[change(@@)plain( -200,25 +162,29 )change(@@)]
     comment(#)
     comment(# TODO: Test this!)
     keyword(def) method(fix)
insert[insert(+)      ident(tokens) operator(=) predefined_constant(self)operator(.)ident(class)operator(.)ident(new)]
       comment(# Check token nesting using a stack of kinds.)
       ident(opened) operator(=) operator([)operator(])
delete[delete(-)      keyword(for) ident(token)operator(,) ident(kind) keyword(in) predefined_constant(self)]
delete[delete(-)        keyword(if) ident(token) operator(==) symbol(:open)]
delete[delete(-)          ident(opened)operator(.)ident(push) ident(kind)]
delete[delete(-)        keyword(elsif) ident(token) operator(==) symbol(:close)]
insert[insert(+)      keyword(for) ident(type)operator(,) ident(kind) keyword(in) predefined_constant(self)]
insert[insert(+)        keyword(case) ident(type)]
insert[insert(+)        keyword(when) symbol(:open)]
insert[insert(+)          ident(opened)operator(.)ident(push) operator([)symbol(:close)operator(,) ident(kind)operator(])]
insert[insert(+)        keyword(when) symbol(:begin_line)]
insert[insert(+)          ident(opened)operator(.)ident(push) operator([)symbol(:end_line)operator(,) ident(kind)operator(])]
insert[insert(+)        keyword(when) symbol(:close)operator(,) symbol(:end_line)]
           ident(expected) operator(=) ident(opened)operator(.)ident(pop)
delete[delete(-)          keyword(if) eyecatcher<ident(kind)> operator(!=) ident(expected)]
insert[insert(+)          keyword(if) eyecatcher<operator([)ident(type)operator(,) ident(kind)operator(])> operator(!=) ident(expected)]
             comment(# Unexpected :close; decide what to do based on the kind:)
insert[insert(+)            comment(# - token was never opened: delete the :close (just skip it\))]
insert[insert(+)            keyword(next) keyword(unless) ident(opened)operator(.)ident(rindex) ident(expected)]
             comment(# - token was opened earlier: also close tokens in between)
delete[delete(-)            comment(# - token was never opened: delete the :close (skip with next\))]
delete[delete(-)            keyword(next) keyword(unless) ident(opened)operator(.)ident(rindex) ident(expected)]
delete[delete(-)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(kind)operator(]) keyword(until) operator(()ident(kind) operator(=) ident(opened)operator(.)ident(pop)operator(\)) operator(==) ident(expected)]
insert[insert(+)            ident(tokens) operator(<<) ident(token) keyword(until) operator(()ident(token) operator(=) ident(opened)operator(.)ident(pop)operator(\)) operator(==) ident(expected)]
           keyword(end)
         keyword(end)
delete[delete(-)        ident(tokens) operator(<<) operator([)ident(t)eyecatcher<ident(oken)>operator(,) ident(kind)operator(])]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(t)eyecatcher<ident(ype)>operator(,) ident(kind)operator(])]
       keyword(end)
       comment(# Close remaining opened tokens)
delete[delete(-)      ident(tokens) operator(<<) eyecatcher<operator([)symbol(:close)operator(,) ident(kind)operator(]) keyword(while) ident(kind)> operator(=) ident(opened)operator(.)ident(pop)]
insert[insert(+)      ident(tokens) operator(<<) eyecatcher<ident(token) keyword(while) ident(token)> operator(=) ident(opened)operator(.)ident(pop)]
       ident(tokens)
     keyword(end)
     
change[change(@@)plain( -226,6 +192,8 )change(@@)]
       ident(replace) ident(fix)
     keyword(end)
     
insert[insert(+)    comment(# TODO: Scanner#split_into_lines)]
insert[insert(+)    comment(# )]
     comment(# Makes sure that:)
     comment(# - newlines are single tokens)
     comment(#   (which means all other token are single-line\))
change[change(@@)plain( -376,8 +344,48 )change(@@)]
 
   keyword(end)
 
delete[delete(-)  ]
delete[delete(-)  comment(# Token name abbreviations)]
delete[delete(-)  ident(require) string<delimiter(')content(coderay/token_classes)delimiter(')>]
insert[insert(+)keyword(end)]
 
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  global_variable($:) operator(<<) constant(File)operator(.)ident(join)operator(()constant(File)operator(.)ident(dirname)operator(()predefined_constant(__FILE__)operator(\))operator(,) string<delimiter(')content(..)delimiter(')>operator(\))]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__) operator(+) integer(4)]
 keyword(end)
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(TokensTest) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_creation)]
insert[insert(+)    ident(assert) constant(CodeRay)operator(::)constant(Tokens) operator(<) constant(Array)]
insert[insert(+)    ident(tokens) operator(=) predefined_constant(nil)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_kind_of) constant(Array)operator(,) ident(tokens)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_adding_tokens)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(tokens) operator(<<) operator([)string<delimiter(')content(string)delimiter(')>operator(,) symbol(:type)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)string<delimiter(')content((\))delimiter(')>operator(,) symbol(:operator)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(.)ident(size)operator(,) integer(2)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_dump_undump)]
insert[insert(+)    ident(tokens) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(new)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(tokens) operator(<<) operator([)string<delimiter(')content(string)delimiter(')>operator(,) symbol(:type)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)string<delimiter(')content((\))delimiter(')>operator(,) symbol(:operator)operator(])]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(tokens2) operator(=) predefined_constant(nil)]
insert[insert(+)    ident(assert_nothing_raised) keyword(do)]
insert[insert(+)      ident(tokens2) operator(=) ident(tokens)operator(.)ident(dump)operator(.)ident(undump)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ident(assert_equal) ident(tokens)operator(,) ident(tokens2)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/duo.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/duo.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/duo.rb)plain(	(revision 500\))]
change[change(@@)plain( -2,8 +2,6 )change(@@)]
   
   comment(# = Duo)
   comment(#)
delete[delete(-)  comment(# $Id: scanner.rb 123 2006-03-21 14:46:34Z murphy $)]
delete[delete(-)  comment(#)]
   comment(# A Duo is a convenient way to use CodeRay. You just create a Duo,)
   comment(# giving it a lang (language of the input code\) and a format (desired)
   comment(# output format\), and call Duo#highlight with the code.)
head[head(Index: )plain(lib/coderay/scanner.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanner.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanner.rb)plain(	(revision 500\))]
change[change(@@)plain( -4,8 +4,6 )change(@@)]
 
   comment(# = Scanners)
   comment(#)
delete[delete(-)  comment(# $Id$)]
delete[delete(-)  comment(#)]
   comment(# This module holds the Scanner class and its subclasses.)
   comment(# For example, the Ruby scanner is named CodeRay::Scanners::Ruby)
   comment(# can be found in coderay/scanners/ruby.)
change[change(@@)plain( -45,6 +43,7 )change(@@)]
     comment(# You can also use +map+, +any?+, +find+ and even +sort_by+,)
     comment(# if you want.)
     keyword(class) class(Scanner) operator(<) constant(StringScanner)
insert[insert(+)      ]
       ident(extend) constant(Plugin)
       ident(plugin_host) constant(Scanners)
 
change[change(@@)plain( -57,6 +56,8 )change(@@)]
       comment(#)
       comment(# Define @default_options for subclasses.)
       constant(DEFAULT_OPTIONS) operator(=) operator({) symbol(:stream) operator(=)operator(>) predefined_constant(false) operator(})
insert[insert(+)      ]
insert[insert(+)      constant(KINDS_NOT_LOC) operator(=) operator([)symbol(:comment)operator(,) symbol(:doctype)operator(])]
 
       keyword(class) operator(<<) class(self)
 
change[change(@@)plain( -67,7 +68,14 )change(@@)]
 
         keyword(def) method(normify) ident(code)
           ident(code) operator(=) ident(code)operator(.)ident(to_s)
delete[delete(-)          ident(code)operator(.)ident(force_encoding) string<delimiter(')content(binary)delimiter(')> keyword(if) ident(code)operator(.)ident(respond_to?) symbol(:force_encoding)]
insert[insert(+)          keyword(if) ident(code)operator(.)ident(respond_to?) symbol(:force_encoding)]
insert[insert(+)            keyword(begin)]
insert[insert(+)              ident(code)operator(.)ident(force_encoding) string<delimiter(')content(utf-8)delimiter(')>]
insert[insert(+)              ident(code)operator([)regexp<delimiter(/)char(\\z)delimiter(/)>operator(])  comment(# raises an ArgumentError when code contains a non-UTF-8 char)]
insert[insert(+)            keyword(rescue) constant(ArgumentError)]
insert[insert(+)              ident(code)operator(.)ident(force_encoding) string<delimiter(')content(binary)delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(end)]
           ident(code)operator(.)ident(to_unix)
         keyword(end)
         
change[change(@@)plain( -77,7 +85,7 )change(@@)]
           keyword(else)
             instance_variable(@file_extension) operator(||=) ident(plugin_id)operator(.)ident(to_s)
           keyword(end)
delete[delete(-)        keyword(end)eyecatcher<        >]
insert[insert(+)        keyword(end)]
 
       keyword(end)
 
change[change(@@)plain( -106,9 +114,10 )change(@@)]
       comment(#)
       comment(# Else, a Tokens object is used.)
       keyword(def) method(initialize) ident(code)operator(=)string<delimiter(')delimiter(')>operator(,) ident(options) operator(=) operator({)operator(})operator(,) operator(&)ident(block)
delete[delete(-)        instance_variable(@options) operator(=) predefined_constant(self)operator(.)ident(class)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge) ident(options)]
         ident(raise) string<delimiter(")content(I am only the basic Scanner class. I can't scan )delimiter(")>\
           string<delimiter(")content(anything. :( Use my subclasses.)delimiter(")> keyword(if) predefined_constant(self)operator(.)ident(class) operator(==) constant(Scanner)
insert[insert(+)        ]
insert[insert(+)        instance_variable(@options) operator(=) predefined_constant(self)operator(.)ident(class)operator(::)constant(DEFAULT_OPTIONS)operator(.)ident(merge) ident(options)]
 
         keyword(super) constant(Scanner)operator(.)ident(normify)operator(()ident(code)operator(\))
 
change[change(@@)plain( -123,6 +132,7 )change(@@)]
             string<delimiter(")content(but :stream is )inline<inline_delimiter(#{)instance_variable(@options)operator([)symbol(:stream)operator(])inline_delimiter(})>delimiter(")> keyword(if) ident(block_given?)
           instance_variable(@tokens) operator(||=) constant(Tokens)operator(.)ident(new)
         keyword(end)
insert[insert(+)        instance_variable(@tokens)operator(.)ident(scanner) operator(=) predefined_constant(self)]
 
         ident(setup)
       keyword(end)
change[change(@@)plain( -142,6 +152,11 )change(@@)]
       keyword(alias) method(code) method(string)
       keyword(alias) method(code=) method(string=)
 
insert[insert(+)      comment(# Returns the Plugin ID for this scanner.)]
insert[insert(+)      keyword(def) method(lang)]
insert[insert(+)        predefined_constant(self)operator(.)ident(class)operator(.)ident(plugin_id)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
       comment(# Scans the code and returns all tokens in a Tokens object.)
       keyword(def) method(tokenize) ident(new_string)operator(=)predefined_constant(nil)operator(,) ident(options) operator(=) operator({)operator(})
         ident(options) operator(=) instance_variable(@options)operator(.)ident(merge)operator(()ident(options)operator(\))
change[change(@@)plain( -180,6 +195,24 )change(@@)]
       keyword(def) method(line)
         ident(string)operator([)integer(0)operator(..)ident(pos)operator(])operator(.)ident(count)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\)) operator(+) integer(1)
       keyword(end)
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(column) ident(pos) operator(=) predefined_constant(self)operator(.)ident(pos)]
insert[insert(+)        keyword(return) integer(0) keyword(if) ident(pos) operator(<=) integer(0)]
insert[insert(+)        ident(string) operator(=) ident(string)operator(()operator(\))]
insert[insert(+)        keyword(if) ident(string)operator(.)ident(respond_to?)operator(()symbol(:bytesize)operator(\)) operator(&&) operator(()keyword(defined?)operator(()instance_variable(@bin_string)operator(\)) operator(||) ident(string)operator(.)ident(bytesize) operator(!=) ident(string)operator(.)ident(size)operator(\))]
insert[insert(+)          instance_variable(@bin_string) operator(||=) ident(string)operator(.)ident(dup)operator(.)ident(force_encoding)operator(()symbol(:binary)operator(\))]
insert[insert(+)          ident(string) operator(=) instance_variable(@bin_string)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(pos) operator(-) operator(()ident(string)operator(.)ident(rindex)operator(()integer(?\\n)operator(,) ident(pos)operator(\)) operator(||) integer(0)operator(\))]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(marshal_dump)]
insert[insert(+)        instance_variable(@options)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(marshal_load) ident(options)]
insert[insert(+)        instance_variable(@options) operator(=) ident(options)]
insert[insert(+)      keyword(end)]
 
     ident(protected)
 
change[change(@@)plain( -204,6 +237,7 )change(@@)]
       keyword(def) method(reset_instance)
         instance_variable(@tokens)operator(.)ident(clear) keyword(unless) instance_variable(@options)operator([)symbol(:keep_tokens)operator(])
         instance_variable(@cached_tokens) operator(=) predefined_constant(nil)
insert[insert(+)        instance_variable(@bin_string) operator(=) predefined_constant(nil) keyword(if) keyword(defined?) instance_variable(@bin_string)]
       keyword(end)
 
       comment(# Scanner error with additional status information)
change[change(@@)plain( -216,7 +250,7 )change(@@)]
 key(tokens)operator(:)
 operator(%)ident(s)
 
delete[delete(-)ident(current) key(line)operator(:) operator(%)ident(d)  eyecatcher<ident(pos) operator(=)> operator(%)ident(d)]
insert[insert(+)ident(current) key(line)operator(:) operator(%)ident(d)  eyecatcher<key(column)operator(:) operator(%)ident(d)  key(pos)operator(:)> operator(%)ident(d)]
 key(matched)operator(:) operator(%)ident(p)  key(state)operator(:) operator(%)ident(p)
 ident(bol?) operator(=) operator(%)ident(p)operator(,)  ident(eos?) operator(=) operator(%)ident(p)
 
change[change(@@)plain( -231,10 +265,10 )change(@@)]
           ident(msg)operator(,)
           ident(tokens)operator(.)ident(size)operator(,)
           ident(tokens)operator(.)ident(last)operator(()integer(10)operator(\))operator(.)ident(map) operator({) operator(|)ident(t)operator(|) ident(t)operator(.)ident(inspect) operator(})operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator(,)
delete[delete(-)          ident(line)operator(,) ident(pos)operator(,)]
insert[insert(+)          ident(line)operator(,) eyecatcher<ident(column)operator(,) >ident(pos)operator(,)]
           ident(matched)operator(,) ident(state)operator(,) ident(bol?)operator(,) ident(eos?)operator(,)
delete[delete(-)          ident(string)operator([)ident(pos)eyecatcher<operator(-)ident(ambit)operator(,)>ident(ambit)operator(])operator(,)]
delete[delete(-)          ident(string)operator([)ident(pos)operator(,)ident(ambit)operator(])operator(,)]
insert[insert(+)          ident(string)operator([)ident(pos)eyecatcher< operator(-) ident(ambit)operator(,) >ident(ambit)operator(])operator(,)]
insert[insert(+)          ident(string)operator([)ident(pos)operator(,)eyecatcher< >ident(ambit)operator(])operator(,)]
         operator(])
       keyword(end)
 
head[head(Index: )plain(lib/coderay/for_redcloth.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/for_redcloth.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/for_redcloth.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,4 +1,4 )change(@@)]
delete[delete(-)keyword(module) class(CodeRay)eyecatcher<  comment(# :nodoc:)>]
insert[insert(+)keyword(module) class(CodeRay)]
   
   comment(# A little hack to enable CodeRay highlighting in RedCloth.)
   comment(# )
change[change(@@)plain( -15,10 +15,12 )change(@@)]
     keyword(def) predefined_constant(self)operator(.)method(install)
       ident(gem) string<delimiter(')content(RedCloth)delimiter(')>operator(,) string<delimiter(')content(>= 4.0.3)delimiter(')> keyword(rescue) predefined_constant(nil)
       ident(require) string<delimiter(')content(redcloth)delimiter(')>
delete[delete(-)      ident(raise) string<delimiter(')content(CodeRay.for_redcloth needs RedCloth 4.0.3 or later.)delimiter(')> keyword(unless) constant(RedCloth)operator(::)constant(VERSION)operator(.)ident(to_s) operator(>)operator(=) string<delimiter(')content(4.0.3)delimiter(')>]
insert[insert(+)      keyword(unless) constant(RedCloth)operator(::)constant(VERSION)operator(.)ident(to_s) operator(>)operator(=) string<delimiter(')content(4.0.3)delimiter(')>]
insert[insert(+)        ident(raise) string<delimiter(')content(CodeRay.for_redcloth needs RedCloth version 4.0.3 or later.)delimiter(')>]
insert[insert(+)      keyword(end)]
       constant(RedCloth)operator(::)constant(TextileDoc)operator(.)ident(send) symbol(:include)operator(,) constant(ForRedCloth)operator(::)constant(TextileDoc)
       constant(RedCloth)operator(::)constant(Formatters)operator(::)constant(HTML)operator(.)ident(module_eval) keyword(do)
delete[delete(-)        keyword(def) method(unescape)operator(()ident(html)operator(\))]
insert[insert(+)        keyword(def) method(unescape)operator(()ident(html)operator(\))eyecatcher<  comment(# :nodoc:)>]
           ident(replacements) operator(=) operator({)
             string<delimiter(')content(&amp;)delimiter(')> operator(=)operator(>) string<delimiter(')content(&)delimiter(')>operator(,)
             string<delimiter(')content(&quot;)delimiter(')> operator(=)operator(>) string<delimiter(')content(")delimiter(')>operator(,)
change[change(@@)plain( -27,16 +29,26 )change(@@)]
           operator(})
           ident(html)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(&(?:amp|quot|[gl]t\);)delimiter(/)>operator(\)) operator({) operator(|)ident(entity)operator(|) ident(replacements)operator([)ident(entity)operator(]) operator(})
         keyword(end)
delete[delete(-)        ident(undef)eyecatcher<ident(_method) symbol(:code)operator(,) symbol(:bc_open)operator(,) symbol(:bc_close)operator(,) symbol(:)>symbol(escape_pre)]
insert[insert(+)        keyword(undef)eyecatcher< method(code)operator(,) method(bc_open)operator(,) method(bc_close)operator(,) >method(escape_pre)]
         keyword(def) method(code)operator(()ident(opts)operator(\))  comment(# :nodoc:)
           ident(opts)operator([)symbol(:block)operator(]) operator(=) predefined_constant(true)
insert[insert(+)          keyword(if) operator(!)ident(opts)operator([)symbol(:lang)operator(]) operator(&&) constant(RedCloth)operator(::)constant(VERSION)operator(.)ident(to_s) operator(>)operator(=) string<delimiter(')content(4.2.0)delimiter(')>]
insert[insert(+)            comment(# simulating pre-4.2 behavior)]
insert[insert(+)            keyword(if) ident(opts)operator([)symbol(:text)operator(])operator(.)ident(sub!)operator(()regexp<delimiter(/)char(\\A)char(\\[)content(()char(\\w)content(+\))char(\\])delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))]
insert[insert(+)              keyword(if) constant(CodeRay)operator(::)constant(Scanners)operator([)global_variable($1)operator(])operator(.)ident(plugin_id) operator(==) string<delimiter(')content(plaintext)delimiter(')>]
insert[insert(+)                ident(opts)operator([)symbol(:text)operator(]) operator(=) global_variable($&) operator(+) ident(opts)operator([)symbol(:text)operator(])]
insert[insert(+)              keyword(else)]
insert[insert(+)                ident(opts)operator([)symbol(:lang)operator(]) operator(=) global_variable($1)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(end)]
           keyword(if) ident(opts)operator([)symbol(:lang)operator(]) operator(&&) operator(!)ident(filter_coderay)
             ident(require) string<delimiter(')content(coderay)delimiter(')>
             instance_variable(@in_bc) operator(||=) predefined_constant(nil)
             ident(format) operator(=) instance_variable(@in_bc) operator(?) symbol(:div) operator(:) symbol(:span)
insert[insert(+)            ident(opts)operator([)symbol(:text)operator(]) operator(=) ident(unescape)operator(()ident(opts)operator([)symbol(:text)operator(])operator(\)) keyword(unless) instance_variable(@in_bc)]
             ident(highlighted_code) operator(=) constant(CodeRay)operator(.)ident(encode) ident(opts)operator([)symbol(:text)operator(])operator(,) ident(opts)operator([)symbol(:lang)operator(])operator(,) ident(format)operator(,) symbol(:stream) operator(=)operator(>) predefined_constant(true)
             ident(highlighted_code)operator(.)ident(sub!)operator(()regexp<delimiter(/)char(\\A)content(<(span|div\))delimiter(/)>operator(\)) operator({) operator(|)ident(m)operator(|) ident(m) operator(+) ident(pba)operator(()instance_variable(@in_bc) operator(||) ident(opts)operator(\)) operator(})
delete[delete(-)            ident(highlighted_code) operator(=) ident(unescape)operator(()ident(highlighted_code)operator(\)) keyword(unless) instance_variable(@in_bc)]
             ident(highlighted_code)
           keyword(else)
             string<delimiter(")content(<code)inline<inline_delimiter(#{)ident(pba)operator(()ident(opts)operator(\))inline_delimiter(})>content(>)inline<inline_delimiter(#{)ident(opts)operator([)symbol(:text)operator(])inline_delimiter(})>content(</code>)delimiter(")>
change[change(@@)plain( -48,10 +60,11 )change(@@)]
           ident(opts)operator([)symbol(:lang)operator(]) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(")content(<pre)inline<inline_delimiter(#{)ident(pba)operator(()ident(opts)operator(\))inline_delimiter(})>content(>)delimiter(")>
         keyword(end)
         keyword(def) method(bc_close)operator(()ident(opts)operator(\))  comment(# :nodoc:)
insert[insert(+)          ident(opts) operator(=) instance_variable(@in_bc)]
           instance_variable(@in_bc) operator(=) predefined_constant(nil)
           ident(opts)operator([)symbol(:lang)operator(]) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(")content(</pre>)char(\\n)delimiter(")>
         keyword(end)
delete[delete(-)        keyword(def) method(escape_pre)operator(()ident(text)operator(\))]
insert[insert(+)        keyword(def) method(escape_pre)operator(()ident(text)operator(\))eyecatcher<  comment(# :nodoc:)>]
           keyword(if) instance_variable(@in_bc) operator(||=) predefined_constant(nil)
             ident(text)
           keyword(else)
head[head(Index: )plain(lib/coderay/scanners/ruby/patterns.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/ruby/patterns.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/ruby/patterns.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,3 +1,4 )change(@@)]
insert[insert(+)comment(# encoding: utf-8)]
 keyword(module) class(CodeRay)
 keyword(module) class(Scanners)
 
change[change(@@)plain( -31,18 +32,18 )change(@@)]
       ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
       ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))
 
delete[delete(-)    constant(IDENT) operator(=) regexp<>eyecatcher<regexp<delimiter(/)content([a-z_][)char(\\w)content(_]*)delimiter(/)modifier(i)>>]
insert[insert(+)    constant(IDENT) operator(=) string<>eyecatcher<string<delimiter(')content()delimiter(')>operator([)regexp<delimiter(/)content([[:alpha:]])delimiter(/)>operator(]) operator(==) string<delimiter(')content()delimiter(')> operator(?) regexp<delimiter(/)content([[:alpha:]_][[:alnum:]_]*)delimiter(/)> operator(:) regexp<delimiter(/)content([^)char(\\W)char(\\d)content(])char(\\w)content(*)delimiter(/)>>]
 
     constant(METHOD_NAME) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( [?!]? )delimiter(/)modifier(ox)>
     constant(METHOD_NAME_OPERATOR) operator(=) regexp<delimiter(/)>
regexp<content(       )char(\\*)char(\\*)content(?           # multiplication and power)>
delete[delete(-)regexp<content(      | [-+~]@?       # plus, minus, tilde with and without )>eyecatcher<regexp<content(@)>>]
delete[delete(-)regexp<content(      | [)char(\\/)content(%&|^`]     # division, modulo or format strings, )>eyecatcher<regexp<content(&and, |or, ^xor, `system`)>>]
insert[insert(+)regexp<content(      | [-+~]@?       # plus, minus, tilde with and without )>eyecatcher<regexp<content(at sign)>>]
insert[insert(+)regexp<content(      | [)char(\\/)content(%&|^`]     # division, modulo or format strings, )>eyecatcher<regexp<content(and, or, xor, system)>>]
regexp<content(       | )char(\\[)char(\\])content(=?        # array getter and setter)>
regexp<content(       | << | >>       # append or shift left, shift right)>
regexp<content(       | <=?>? | >=?   # comparison, rocket operator)>
regexp<content(       | ===? | =~     # simple equality, case equality, match)>
delete[delete(-)regexp<content(      | ![~=@]?       # negation with and without )>eyecatcher<regexp<content(@)>>regexp<content(, not-equal and not-match)>]
insert[insert(+)regexp<content(      | ![~=@]?       # negation with and without )>eyecatcher<regexp<content(at sign)>>regexp<content(, not-equal and not-match)>]
regexp<content(     )delimiter(/)modifier(ox)>
     constant(METHOD_NAME_EX) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( (?:[?!]|=(?!>\)\)? | )inline<inline_delimiter(#{)constant(METHOD_NAME_OPERATOR)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(INSTANCE_VARIABLE) operator(=) regexp<delimiter(/)content( @ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
change[change(@@)plain( -59,7 +60,7 )change(@@)]
     constant(QUOTE_TO_TYPE)operator(.)ident(default) operator(=) symbol(:string)
 
     constant(REGEXP_MODIFIERS) operator(=) regexp<delimiter(/)content([mixounse]*)delimiter(/)>
delete[delete(-)    constant(REGEXP_SYMBOLS) operator(=) regexp<delimiter(/)content([|?*+)>eyecatcher<regexp<content(?)>>regexp<content((\){})char(\\[)char(\\])content(.^$])delimiter(/)>]
insert[insert(+)    constant(REGEXP_SYMBOLS) operator(=) regexp<delimiter(/)content([|?*+)>regexp<content((\){})char(\\[)char(\\])content(.^$])delimiter(/)>]
 
     constant(DECIMAL) operator(=) regexp<delimiter(/)char(\\d)content(+(?:_)char(\\d)content(+\)*)delimiter(/)>
     constant(OCTAL) operator(=) regexp<delimiter(/)content(0_?[0-7]+(?:_[0-7]+\)*)delimiter(/)>
change[change(@@)plain( -81,25 +82,30 )change(@@)]
     regexp<delimiter(/)content(ox)>
regexp<content(     METHOD_NAME_OR_SYMBOL = )delimiter(/)> comment(#{METHOD_NAME_EX} | #{SYMBOL} /ox)
 
delete[delete(-)    comment(# TODO investigste \\M, \\c and \\C escape sequences)]
delete[delete(-)    comment(# (?: M-\\\\C-|C-\\\\M-|M-\\\\c|c\\\\M-|c|C-|M-\)? (?: \\\\ (?: [0-7]{3} | x[0-9A-Fa-f]{2} | . \) \))]
delete[delete(-)    comment(# assert_equal(225, ?\\M-a\))]
delete[delete(-)    comment(# assert_equal(129, ?\\M-\\C-a\))]
delete[delete(-)    constant(ESCAPE) operator(=) regexp<delimiter(/)>]
insert[insert(+)    constant(SIMPLE_ESCAPE) operator(=) regexp<delimiter(/)>]
regexp<content(         [abefnrstv])>
delete[delete(-)regexp<content(      | M-)char(\\\\)content(C-|C-)char(\\\\)content(M-|M-)char(\\\\)content(c|c)char(\\\\)content(M-|c|C-|M-)>]
regexp<content(       |  [0-7]{1,3})>
regexp<content(       | x[0-9A-Fa-f]{1,2})>
delete[delete(-)regexp<content(      | .)>]
insert[insert(+)regexp<content(      | .)>eyecatcher<regexp<content(?)>>]
regexp<content(     )delimiter(/)modifier(mx)>
delete[delete(-)]
insert[insert(+)    ]
insert[insert(+)    constant(CONTROL_META_ESCAPE) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(      (?: M-|C-|c \))>]
insert[insert(+)regexp<content(      (?: )char(\\\\)content( (?: M-|C-|c \) \)*)>]
insert[insert(+)regexp<content(      (?: [^)char(\\\\)content(] | )char(\\\\)content( )inline<inline_delimiter(#{)constant(SIMPLE_ESCAPE)inline_delimiter(})>content( \)?)>]
insert[insert(+)regexp<content(    )delimiter(/)modifier(mox)>]
insert[insert(+)    ]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(      )inline<inline_delimiter(#{)constant(CONTROL_META_ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(SIMPLE_ESCAPE)inline_delimiter(})>>]
insert[insert(+)regexp<content(    )delimiter(/)modifier(mox)>]
insert[insert(+)    ]
     constant(CHARACTER) operator(=) regexp<delimiter(/)>
regexp<content(       )char(\\?)>
regexp<content(       (?:)>
regexp<content(         [^)char(\\s)char(\\\\)content(])>
regexp<content(       | )char(\\\\)content( )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>>
regexp<content(       \))>
delete[delete(-)regexp<content(    )delimiter(/)modifier(m)>regexp<modifier(x)>]
insert[insert(+)regexp<content(    )delimiter(/)modifier(m)>eyecatcher<regexp<modifier(o)>>regexp<modifier(x)>]
 
     comment(# NOTE: This is not completely correct, but)
     comment(# nobody needs heredoc delimiters ending with \\n.)
change[change(@@)plain( -136,14 +142,19 )change(@@)]
       operator(|) comment(#{CHARACTER})
       operator(\))
     regexp<delimiter(/)content(x)>
insert[insert(+)regexp<content(    KEYWORDS_EXPECTING_VALUE = WordList.new.add(%w[)>]
insert[insert(+)regexp<content(      and end in or unless begin)>]
insert[insert(+)regexp<content(      defined? ensure redo super until)>]
insert[insert(+)regexp<content(      break do next rescue then)>]
insert[insert(+)regexp<content(      when case else for retry)>]
insert[insert(+)regexp<content(      while elsif if not return)>]
insert[insert(+)regexp<content(      yield)>]
insert[insert(+)regexp<content(    ]\))>]
regexp<content( )>
regexp<content(     RUBYDOC_OR_DATA = )delimiter(/)> comment(#{RUBYDOC} | #{DATA} /xo)
 
     constant(RDOC_DATA_START) operator(=) regexp<delimiter(/)content( ^=begin (?!)char(\\S)content(\) | ^__END__$ )delimiter(/)modifier(x)>
 
delete[delete(-)    comment(# FIXME: \\s and = are only a workaround, they are still allowed)]
delete[delete(-)    comment(# as delimiters.)]
delete[delete(-)    constant(FANCY_START_SAVE) operator(=) regexp<delimiter(/)content( % ( [qQwWxsr] | (?![a-zA-Z0-9)char(\\s)content(=]\) \) ([^a-zA-Z0-9]\) )delimiter(/)modifier(mx)>]
     constant(FANCY_START_CORRECT) operator(=) regexp<delimiter(/)content( % ( [qQwWxsr] | (?![a-zA-Z0-9]\) \) ([^a-zA-Z0-9]\) )delimiter(/)modifier(mx)>
 
     constant(FancyStringType) operator(=) operator({)
change[change(@@)plain( -166,17 +177,18 )change(@@)]
         operator({) operator(})
       operator(]) operator(])
 
delete[delete(-)      constant(CLOSING_PAREN)operator(.)eyecatcher<ident(values)operator(.)ident(each) operator({) operator(|)ident(o)operator(|) ident(o)>operator(.)ident(freeze) operator(})  comment(# debug, if I try to change it with <<)]
insert[insert(+)      constant(CLOSING_PAREN)operator(.)eyecatcher<ident(each) operator({) operator(|)ident(k)operator(,)ident(v)operator(|) ident(k)operator(.)ident(freeze)operator(;) ident(v)>operator(.)ident(freeze) operator(})  comment(# debug, if I try to change it with <<)]
       constant(OPENING_PAREN) operator(=) constant(CLOSING_PAREN)operator(.)ident(invert)
 
delete[delete(-)      constant(STRING_PATTERN) operator(=) constant(Hash)operator(.)ident(new) eyecatcher<operator({)> operator(|)ident(h)operator(,) ident(k)operator(|)]
insert[insert(+)      constant(STRING_PATTERN) operator(=) constant(Hash)operator(.)ident(new) eyecatcher<keyword(do)> operator(|)ident(h)operator(,) ident(k)operator(|)]
         ident(delim)operator(,) ident(interpreted) operator(=) operator(*)ident(k)
delete[delete(-)        ident(delim_pattern) operator(=) constant(Regexp)operator(.)ident(escape)operator(()ident(delim)operator(.)ident(dup)operator(\))]
insert[insert(+)        ident(delim_pattern) operator(=) constant(Regexp)operator(.)ident(escape)operator(()ident(delim)operator(.)ident(dup)operator(\))eyecatcher<  comment(# dup: workaround for old Ruby)>]
         keyword(if) ident(closing_paren) operator(=) constant(CLOSING_PAREN)operator([)ident(delim)operator(])
insert[insert(+)          ident(delim_pattern) operator(=) ident(delim_pattern)operator([)integer(0)operator(..)integer(-1)operator(]) keyword(if) keyword(defined?) constant(JRUBY_VERSION)  comment(# JRuby fix)]
           ident(delim_pattern) operator(<<) constant(Regexp)operator(.)ident(escape)operator(()ident(closing_paren)operator(\))
         keyword(end)
delete[delete(-)]
delete[delete(-)]
insert[insert(+)eyecatcher<        ident(delim_pattern) operator(<<) string<delimiter(')char(\\\\)char(\\\\)delimiter(')> keyword(unless) ident(delim) operator(==) string<delimiter(')char(\\\\)delimiter(')>>]
insert[insert(+)eyecatcher<        >]
         ident(special_escapes) operator(=)
           keyword(case) ident(interpreted)
           keyword(when) symbol(:regexp_symbols)
change[change(@@)plain( -184,18 +196,18 )change(@@)]
           keyword(when) symbol(:words)
             string<delimiter(')content(| )content(\\s)delimiter(')>
           keyword(end)
delete[delete(-)]
insert[insert(+)eyecatcher<        >]
         ident(h)operator([)ident(k)operator(]) operator(=)
           keyword(if) ident(interpreted) keyword(and) keyword(not) ident(delim) operator(==) string<delimiter(')content(#)delimiter(')>
delete[delete(-)            regexp<delimiter(/)content( (?= [)inline<inline_delimiter(#{)ident(delim_pattern)inline_delimiter(})>>eyecatcher<regexp<char(\\\\)>>regexp<content(] | )char(\\#)content( [{$@] )inline<inline_delimiter(#{)ident(special_escapes)inline_delimiter(})>content( \) )delimiter(/)modifier(mx)>]
insert[insert(+)            regexp<delimiter(/)content( (?= [)inline<inline_delimiter(#{)ident(delim_pattern)inline_delimiter(})>>regexp<content(] | )char(\\#)content( [{$@] )inline<inline_delimiter(#{)ident(special_escapes)inline_delimiter(})>content( \) )delimiter(/)modifier(mx)>]
           keyword(else)
delete[delete(-)            regexp<delimiter(/)content( (?= [)inline<inline_delimiter(#{)ident(delim_pattern)inline_delimiter(})>>eyecatcher<regexp<char(\\\\)>>regexp<content(] )inline<inline_delimiter(#{)ident(special_escapes)inline_delimiter(})>content( \) )delimiter(/)modifier(mx)>]
insert[insert(+)            regexp<delimiter(/)content( (?= [)inline<inline_delimiter(#{)ident(delim_pattern)inline_delimiter(})>>regexp<content(] )inline<inline_delimiter(#{)ident(special_escapes)inline_delimiter(})>content( \) )delimiter(/)modifier(mx)>]
           keyword(end)
delete[delete(-)      eyecatcher<operator(})>]
insert[insert(+)      eyecatcher<keyword(end)>]
 
delete[delete(-)      constant(HEREDOC_PATTERN) operator(=) constant(Hash)operator(.)ident(new) eyecatcher<operator({)> operator(|)ident(h)operator(,) ident(k)operator(|)]
insert[insert(+)      constant(HEREDOC_PATTERN) operator(=) constant(Hash)operator(.)ident(new) eyecatcher<keyword(do)> operator(|)ident(h)operator(,) ident(k)operator(|)]
         ident(delim)operator(,) ident(interpreted)operator(,) ident(indented) operator(=) operator(*)ident(k)
delete[delete(-)        ident(delim_pattern) operator(=) constant(Regexp)operator(.)ident(escape)operator(()ident(delim)operator(.)ident(dup)operator(\))]
insert[insert(+)        ident(delim_pattern) operator(=) constant(Regexp)operator(.)ident(escape)operator(()ident(delim)operator(.)ident(dup)operator(\))eyecatcher<  comment(# dup: workaround for old Ruby)>]
         ident(delim_pattern) operator(=) regexp<delimiter(/)content( )char(\\n)content( )inline<inline_delimiter(#{) string<delimiter(')content((?>[)content(\\ )content(\\t)content(]*\))delimiter(')> keyword(if) ident(indented) inline_delimiter(})>content( )inline<inline_delimiter(#{) constant(Regexp)operator(.)ident(new) ident(delim_pattern) inline_delimiter(})>content( $ )delimiter(/)modifier(x)>
         ident(h)operator([)ident(k)operator(]) operator(=)
           keyword(if) ident(interpreted)
change[change(@@)plain( -203,12 +215,12 )change(@@)]
           keyword(else)
             regexp<delimiter(/)content( (?= )inline<inline_delimiter(#{)ident(delim_pattern)inline_delimiter(})>content((\) | )char(\\\\)content( \) )delimiter(/)modifier(mx)>
           keyword(end)
delete[delete(-)      eyecatcher<operator(})>]
insert[insert(+)      eyecatcher<keyword(end)>]
 
       keyword(def) method(initialize) ident(kind)operator(,) ident(interpreted)operator(,) ident(delim)operator(,) ident(heredoc) operator(=) predefined_constant(false)
         keyword(if) ident(heredoc)
           ident(pattern) operator(=) constant(HEREDOC_PATTERN)operator([) operator([)ident(delim)operator(,) ident(interpreted)operator(,) ident(heredoc) operator(==) symbol(:indented)operator(]) operator(])
delete[delete(-)          ident(delim) eyecatcher< >operator(=) predefined_constant(nil)]
insert[insert(+)          ident(delim) operator(=) predefined_constant(nil)]
         keyword(else)
           ident(pattern) operator(=) constant(STRING_PATTERN)operator([) operator([)ident(delim)operator(,) ident(interpreted)operator(]) operator(])
           keyword(if) ident(paren) operator(=) constant(CLOSING_PAREN)operator([)ident(delim)operator(])
head[head(Index: )plain(lib/coderay/scanners/java/builtin_types.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/java/builtin_types.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/java/builtin_types.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,419 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  keyword(module) class(Java::BuiltinTypes)  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(List) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      AbstractAction AbstractBorder AbstractButton AbstractCellEditor AbstractCollection)>]
insert[insert(+)string<content(      AbstractColorChooserPanel AbstractDocument AbstractExecutorService AbstractInterruptibleChannel)>]
insert[insert(+)string<content(      AbstractLayoutCache AbstractList AbstractListModel AbstractMap AbstractMethodError AbstractPreferences)>]
insert[insert(+)string<content(      AbstractQueue AbstractQueuedSynchronizer AbstractSelectableChannel AbstractSelectionKey AbstractSelector)>]
insert[insert(+)string<content(      AbstractSequentialList AbstractSet AbstractSpinnerModel AbstractTableModel AbstractUndoableEdit)>]
insert[insert(+)string<content(      AbstractWriter AccessControlContext AccessControlException AccessController AccessException Accessible)>]
insert[insert(+)string<content(      AccessibleAction AccessibleAttributeSequence AccessibleBundle AccessibleComponent AccessibleContext)>]
insert[insert(+)string<content(      AccessibleEditableText AccessibleExtendedComponent AccessibleExtendedTable AccessibleExtendedText)>]
insert[insert(+)string<content(      AccessibleHyperlink AccessibleHypertext AccessibleIcon AccessibleKeyBinding AccessibleObject)>]
insert[insert(+)string<content(      AccessibleRelation AccessibleRelationSet AccessibleResourceBundle AccessibleRole AccessibleSelection)>]
insert[insert(+)string<content(      AccessibleState AccessibleStateSet AccessibleStreamable AccessibleTable AccessibleTableModelChange)>]
insert[insert(+)string<content(      AccessibleText AccessibleTextSequence AccessibleValue AccountException AccountExpiredException)>]
insert[insert(+)string<content(      AccountLockedException AccountNotFoundException Acl AclEntry AclNotFoundException Action ActionEvent)>]
insert[insert(+)string<content(      ActionListener ActionMap ActionMapUIResource Activatable ActivateFailedException ActivationDesc)>]
insert[insert(+)string<content(      ActivationException ActivationGroup ActivationGroupDesc ActivationGroupID ActivationGroup_Stub)>]
insert[insert(+)string<content(      ActivationID ActivationInstantiator ActivationMonitor ActivationSystem Activator ActiveEvent)>]
insert[insert(+)string<content(      ActivityCompletedException ActivityRequiredException Adjustable AdjustmentEvent AdjustmentListener)>]
insert[insert(+)string<content(      Adler32 AffineTransform AffineTransformOp AlgorithmParameterGenerator AlgorithmParameterGeneratorSpi)>]
insert[insert(+)string<content(      AlgorithmParameters AlgorithmParameterSpec AlgorithmParametersSpi AllPermission AlphaComposite)>]
insert[insert(+)string<content(      AlreadyBoundException AlreadyConnectedException AncestorEvent AncestorListener AnnotatedElement)>]
insert[insert(+)string<content(      Annotation AnnotationFormatError AnnotationTypeMismatchException AppConfigurationEntry Appendable Applet)>]
insert[insert(+)string<content(      AppletContext AppletInitializer AppletStub Arc2D Area AreaAveragingScaleFilter ArithmeticException Array)>]
insert[insert(+)string<content(      ArrayBlockingQueue ArrayIndexOutOfBoundsException ArrayList Arrays ArrayStoreException ArrayType)>]
insert[insert(+)string<content(      AssertionError AsyncBoxView AsynchronousCloseException AtomicBoolean AtomicInteger AtomicIntegerArray)>]
insert[insert(+)string<content(      AtomicIntegerFieldUpdater AtomicLong AtomicLongArray AtomicLongFieldUpdater AtomicMarkableReference)>]
insert[insert(+)string<content(      AtomicReference AtomicReferenceArray AtomicReferenceFieldUpdater AtomicStampedReference Attribute)>]
insert[insert(+)string<content(      AttributeChangeNotification AttributeChangeNotificationFilter AttributedCharacterIterator)>]
insert[insert(+)string<content(      AttributedString AttributeException AttributeInUseException AttributeList AttributeModificationException)>]
insert[insert(+)string<content(      AttributeNotFoundException Attributes AttributeSet AttributeSetUtilities AttributeValueExp AudioClip)>]
insert[insert(+)string<content(      AudioFileFormat AudioFileReader AudioFileWriter AudioFormat AudioInputStream AudioPermission AudioSystem)>]
insert[insert(+)string<content(      AuthenticationException AuthenticationNotSupportedException Authenticator AuthorizeCallback)>]
insert[insert(+)string<content(      AuthPermission AuthProvider Autoscroll AWTError AWTEvent AWTEventListener AWTEventListenerProxy)>]
insert[insert(+)string<content(      AWTEventMulticaster AWTException AWTKeyStroke AWTPermission BackingStoreException)>]
insert[insert(+)string<content(      BadAttributeValueExpException BadBinaryOpValueExpException BadLocationException BadPaddingException)>]
insert[insert(+)string<content(      BadStringOperationException BandCombineOp BandedSampleModel BaseRowSet BasicArrowButton BasicAttribute)>]
insert[insert(+)string<content(      BasicAttributes BasicBorders BasicButtonListener BasicButtonUI BasicCheckBoxMenuItemUI BasicCheckBoxUI)>]
insert[insert(+)string<content(      BasicColorChooserUI BasicComboBoxEditor BasicComboBoxRenderer BasicComboBoxUI BasicComboPopup)>]
insert[insert(+)string<content(      BasicControl BasicDesktopIconUI BasicDesktopPaneUI BasicDirectoryModel BasicEditorPaneUI)>]
insert[insert(+)string<content(      BasicFileChooserUI BasicFormattedTextFieldUI BasicGraphicsUtils BasicHTML BasicIconFactory)>]
insert[insert(+)string<content(      BasicInternalFrameTitlePane BasicInternalFrameUI BasicLabelUI BasicListUI BasicLookAndFeel)>]
insert[insert(+)string<content(      BasicMenuBarUI BasicMenuItemUI BasicMenuUI BasicOptionPaneUI BasicPanelUI BasicPasswordFieldUI)>]
insert[insert(+)string<content(      BasicPermission BasicPopupMenuSeparatorUI BasicPopupMenuUI BasicProgressBarUI BasicRadioButtonMenuItemUI)>]
insert[insert(+)string<content(      BasicRadioButtonUI BasicRootPaneUI BasicScrollBarUI BasicScrollPaneUI BasicSeparatorUI BasicSliderUI)>]
insert[insert(+)string<content(      BasicSpinnerUI BasicSplitPaneDivider BasicSplitPaneUI BasicStroke BasicTabbedPaneUI BasicTableHeaderUI)>]
insert[insert(+)string<content(      BasicTableUI BasicTextAreaUI BasicTextFieldUI BasicTextPaneUI BasicTextUI BasicToggleButtonUI)>]
insert[insert(+)string<content(      BasicToolBarSeparatorUI BasicToolBarUI BasicToolTipUI BasicTreeUI BasicViewportUI BatchUpdateException)>]
insert[insert(+)string<content(      BeanContext BeanContextChild BeanContextChildComponentProxy BeanContextChildSupport)>]
insert[insert(+)string<content(      BeanContextContainerProxy BeanContextEvent BeanContextMembershipEvent BeanContextMembershipListener)>]
insert[insert(+)string<content(      BeanContextProxy BeanContextServiceAvailableEvent BeanContextServiceProvider)>]
insert[insert(+)string<content(      BeanContextServiceProviderBeanInfo BeanContextServiceRevokedEvent BeanContextServiceRevokedListener)>]
insert[insert(+)string<content(      BeanContextServices BeanContextServicesListener BeanContextServicesSupport BeanContextSupport)>]
insert[insert(+)string<content(      BeanDescriptor BeanInfo Beans BevelBorder Bidi BigDecimal BigInteger BinaryRefAddr BindException Binding)>]
insert[insert(+)string<content(      BitSet Blob BlockingQueue BlockView BMPImageWriteParam Book Boolean BooleanControl Border BorderFactory)>]
insert[insert(+)string<content(      BorderLayout BorderUIResource BoundedRangeModel Box BoxLayout BoxView BreakIterator)>]
insert[insert(+)string<content(      BrokenBarrierException Buffer BufferCapabilities BufferedImage BufferedImageFilter BufferedImageOp)>]
insert[insert(+)string<content(      BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter BufferOverflowException)>]
insert[insert(+)string<content(      BufferStrategy BufferUnderflowException Button ButtonGroup ButtonModel ButtonUI Byte)>]
insert[insert(+)string<content(      ByteArrayInputStream ByteArrayOutputStream ByteBuffer ByteChannel ByteLookupTable ByteOrder CachedRowSet)>]
insert[insert(+)string<content(      CacheRequest CacheResponse Calendar Callable CallableStatement Callback CallbackHandler)>]
insert[insert(+)string<content(      CancelablePrintJob CancellationException CancelledKeyException CannotProceedException)>]
insert[insert(+)string<content(      CannotRedoException CannotUndoException Canvas CardLayout Caret CaretEvent CaretListener CellEditor)>]
insert[insert(+)string<content(      CellEditorListener CellRendererPane Certificate CertificateEncodingException CertificateException)>]
insert[insert(+)string<content(      CertificateExpiredException CertificateFactory CertificateFactorySpi CertificateNotYetValidException)>]
insert[insert(+)string<content(      CertificateParsingException CertPath CertPathBuilder CertPathBuilderException CertPathBuilderResult)>]
insert[insert(+)string<content(      CertPathBuilderSpi CertPathParameters CertPathTrustManagerParameters CertPathValidator)>]
insert[insert(+)string<content(      CertPathValidatorException CertPathValidatorResult CertPathValidatorSpi CertSelector CertStore)>]
insert[insert(+)string<content(      CertStoreException CertStoreParameters CertStoreSpi ChangedCharSetException ChangeEvent ChangeListener)>]
insert[insert(+)string<content(      Channel Channels Character CharacterCodingException CharacterIterator CharArrayReader CharArrayWriter)>]
insert[insert(+)string<content(      CharBuffer CharConversionException CharSequence Charset CharsetDecoder CharsetEncoder CharsetProvider)>]
insert[insert(+)string<content(      Checkbox CheckboxGroup CheckboxMenuItem CheckedInputStream CheckedOutputStream Checksum Choice)>]
insert[insert(+)string<content(      ChoiceCallback ChoiceFormat Chromaticity Cipher CipherInputStream CipherOutputStream CipherSpi Class)>]
insert[insert(+)string<content(      ClassCastException ClassCircularityError ClassDefinition ClassDesc ClassFileTransformer ClassFormatError)>]
insert[insert(+)string<content(      ClassLoader ClassLoaderRepository ClassLoadingMXBean ClassNotFoundException Clip Clipboard)>]
insert[insert(+)string<content(      ClipboardOwner Clob Cloneable CloneNotSupportedException Closeable ClosedByInterruptException)>]
insert[insert(+)string<content(      ClosedChannelException ClosedSelectorException CMMException CoderMalfunctionError CoderResult CodeSigner)>]
insert[insert(+)string<content(      CodeSource CodingErrorAction CollationElementIterator CollationKey Collator Collection)>]
insert[insert(+)string<content(      CollectionCertStoreParameters Collections Color ColorChooserComponentFactory ColorChooserUI)>]
insert[insert(+)string<content(      ColorConvertOp ColorModel ColorSelectionModel ColorSpace ColorSupported ColorType ColorUIResource)>]
insert[insert(+)string<content(      ComboBoxEditor ComboBoxModel ComboBoxUI ComboPopup CommunicationException Comparable Comparator)>]
insert[insert(+)string<content(      CompilationMXBean Compiler CompletionService Component ComponentAdapter ComponentColorModel)>]
insert[insert(+)string<content(      ComponentEvent ComponentInputMap ComponentInputMapUIResource ComponentListener ComponentOrientation)>]
insert[insert(+)string<content(      ComponentSampleModel ComponentUI ComponentView Composite CompositeContext CompositeData)>]
insert[insert(+)string<content(      CompositeDataSupport CompositeName CompositeType CompositeView CompoundBorder CompoundControl)>]
insert[insert(+)string<content(      CompoundEdit CompoundName Compression ConcurrentHashMap ConcurrentLinkedQueue ConcurrentMap)>]
insert[insert(+)string<content(      ConcurrentModificationException Condition Configuration ConfigurationException ConfirmationCallback)>]
insert[insert(+)string<content(      ConnectException ConnectIOException Connection ConnectionEvent ConnectionEventListener)>]
insert[insert(+)string<content(      ConnectionPendingException ConnectionPoolDataSource ConsoleHandler Constructor Container)>]
insert[insert(+)string<content(      ContainerAdapter ContainerEvent ContainerListener ContainerOrderFocusTraversalPolicy ContentHandler)>]
insert[insert(+)string<content(      ContentHandlerFactory ContentModel Context ContextNotEmptyException ContextualRenderedImageFactory)>]
insert[insert(+)string<content(      Control ControlFactory ControllerEventListener ConvolveOp CookieHandler Copies CopiesSupported)>]
insert[insert(+)string<content(      CopyOnWriteArrayList CopyOnWriteArraySet CountDownLatch CounterMonitor CounterMonitorMBean CRC32)>]
insert[insert(+)string<content(      CredentialException CredentialExpiredException CredentialNotFoundException CRL CRLException CRLSelector)>]
insert[insert(+)string<content(      CropImageFilter CSS CubicCurve2D Currency Cursor Customizer CyclicBarrier DatabaseMetaData DataBuffer)>]
insert[insert(+)string<content(      DataBufferByte DataBufferDouble DataBufferFloat DataBufferInt DataBufferShort DataBufferUShort)>]
insert[insert(+)string<content(      DataFlavor DataFormatException DatagramChannel DatagramPacket DatagramSocket DatagramSocketImpl)>]
insert[insert(+)string<content(      DatagramSocketImplFactory DataInput DataInputStream DataLine DataOutput DataOutputStream DataSource)>]
insert[insert(+)string<content(      DataTruncation DatatypeConfigurationException DatatypeConstants DatatypeFactory Date DateFormat)>]
insert[insert(+)string<content(      DateFormatSymbols DateFormatter DateTimeAtCompleted DateTimeAtCreation DateTimeAtProcessing)>]
insert[insert(+)string<content(      DateTimeSyntax DebugGraphics DecimalFormat DecimalFormatSymbols DefaultBoundedRangeModel)>]
insert[insert(+)string<content(      DefaultButtonModel DefaultCaret DefaultCellEditor DefaultColorSelectionModel DefaultComboBoxModel)>]
insert[insert(+)string<content(      DefaultDesktopManager DefaultEditorKit DefaultFocusManager DefaultFocusTraversalPolicy DefaultFormatter)>]
insert[insert(+)string<content(      DefaultFormatterFactory DefaultHighlighter DefaultKeyboardFocusManager DefaultListCellRenderer)>]
insert[insert(+)string<content(      DefaultListModel DefaultListSelectionModel DefaultLoaderRepository DefaultMenuLayout DefaultMetalTheme)>]
insert[insert(+)string<content(      DefaultMutableTreeNode DefaultPersistenceDelegate DefaultSingleSelectionModel DefaultStyledDocument)>]
insert[insert(+)string<content(      DefaultTableCellRenderer DefaultTableColumnModel DefaultTableModel DefaultTextUI DefaultTreeCellEditor)>]
insert[insert(+)string<content(      DefaultTreeCellRenderer DefaultTreeModel DefaultTreeSelectionModel Deflater DeflaterOutputStream Delayed)>]
insert[insert(+)string<content(      DelayQueue DelegationPermission Deprecated Descriptor DescriptorAccess DescriptorSupport DESedeKeySpec)>]
insert[insert(+)string<content(      DesignMode DESKeySpec DesktopIconUI DesktopManager DesktopPaneUI Destination Destroyable)>]
insert[insert(+)string<content(      DestroyFailedException DGC DHGenParameterSpec DHKey DHParameterSpec DHPrivateKey DHPrivateKeySpec)>]
insert[insert(+)string<content(      DHPublicKey DHPublicKeySpec Dialog Dictionary DigestException DigestInputStream DigestOutputStream)>]
insert[insert(+)string<content(      Dimension Dimension2D DimensionUIResource DirContext DirectColorModel DirectoryManager DirObjectFactory)>]
insert[insert(+)string<content(      DirStateFactory DisplayMode DnDConstants Doc DocAttribute DocAttributeSet DocFlavor DocPrintJob Document)>]
insert[insert(+)string<content(      DocumentBuilder DocumentBuilderFactory Documented DocumentEvent DocumentFilter DocumentListener)>]
insert[insert(+)string<content(      DocumentName DocumentParser DomainCombiner DOMLocator DOMResult DOMSource Double DoubleBuffer)>]
insert[insert(+)string<content(      DragGestureEvent DragGestureListener DragGestureRecognizer DragSource DragSourceAdapter)>]
insert[insert(+)string<content(      DragSourceContext DragSourceDragEvent DragSourceDropEvent DragSourceEvent DragSourceListener)>]
insert[insert(+)string<content(      DragSourceMotionListener Driver DriverManager DriverPropertyInfo DropTarget DropTargetAdapter)>]
insert[insert(+)string<content(      DropTargetContext DropTargetDragEvent DropTargetDropEvent DropTargetEvent DropTargetListener DSAKey)>]
insert[insert(+)string<content(      DSAKeyPairGenerator DSAParameterSpec DSAParams DSAPrivateKey DSAPrivateKeySpec DSAPublicKey)>]
insert[insert(+)string<content(      DSAPublicKeySpec DTD DTDConstants DuplicateFormatFlagsException Duration DynamicMBean ECField ECFieldF2m)>]
insert[insert(+)string<content(      ECFieldFp ECGenParameterSpec ECKey ECParameterSpec ECPoint ECPrivateKey ECPrivateKeySpec ECPublicKey)>]
insert[insert(+)string<content(      ECPublicKeySpec EditorKit Element ElementIterator ElementType Ellipse2D EllipticCurve EmptyBorder)>]
insert[insert(+)string<content(      EmptyStackException EncodedKeySpec Encoder EncryptedPrivateKeyInfo Entity Enum)>]
insert[insert(+)string<content(      EnumConstantNotPresentException EnumControl Enumeration EnumMap EnumSet EnumSyntax EOFException Error)>]
insert[insert(+)string<content(      ErrorListener ErrorManager EtchedBorder Event EventContext EventDirContext EventHandler EventListener)>]
insert[insert(+)string<content(      EventListenerList EventListenerProxy EventObject EventQueue EventSetDescriptor Exception)>]
insert[insert(+)string<content(      ExceptionInInitializerError ExceptionListener Exchanger ExecutionException Executor)>]
insert[insert(+)string<content(      ExecutorCompletionService Executors ExecutorService ExemptionMechanism ExemptionMechanismException)>]
insert[insert(+)string<content(      ExemptionMechanismSpi ExpandVetoException ExportException Expression ExtendedRequest ExtendedResponse)>]
insert[insert(+)string<content(      Externalizable FactoryConfigurationError FailedLoginException FeatureDescriptor Fidelity Field)>]
insert[insert(+)string<content(      FieldPosition FieldView File FileCacheImageInputStream FileCacheImageOutputStream FileChannel)>]
insert[insert(+)string<content(      FileChooserUI FileDescriptor FileDialog FileFilter FileHandler FileImageInputStream)>]
insert[insert(+)string<content(      FileImageOutputStream FileInputStream FileLock FileLockInterruptionException FilenameFilter FileNameMap)>]
insert[insert(+)string<content(      FileNotFoundException FileOutputStream FilePermission FileReader FileSystemView FileView FileWriter)>]
insert[insert(+)string<content(      Filter FilteredImageSource FilteredRowSet FilterInputStream FilterOutputStream FilterReader FilterWriter)>]
insert[insert(+)string<content(      Finishings FixedHeightLayoutCache FlatteningPathIterator FlavorEvent FlavorException FlavorListener)>]
insert[insert(+)string<content(      FlavorMap FlavorTable Float FloatBuffer FloatControl FlowLayout FlowView Flushable FocusAdapter)>]
insert[insert(+)string<content(      FocusEvent FocusListener FocusManager FocusTraversalPolicy Font FontFormatException FontMetrics)>]
insert[insert(+)string<content(      FontRenderContext FontUIResource Format FormatConversionProvider FormatFlagsConversionMismatchException)>]
insert[insert(+)string<content(      Formattable FormattableFlags Formatter FormatterClosedException FormSubmitEvent FormView Frame Future)>]
insert[insert(+)string<content(      FutureTask GapContent GarbageCollectorMXBean GatheringByteChannel GaugeMonitor GaugeMonitorMBean)>]
insert[insert(+)string<content(      GeneralPath GeneralSecurityException GenericArrayType GenericDeclaration GenericSignatureFormatError)>]
insert[insert(+)string<content(      GlyphJustificationInfo GlyphMetrics GlyphVector GlyphView GradientPaint GraphicAttribute Graphics)>]
insert[insert(+)string<content(      Graphics2D GraphicsConfigTemplate GraphicsConfiguration GraphicsDevice GraphicsEnvironment GrayFilter)>]
insert[insert(+)string<content(      GregorianCalendar GridBagConstraints GridBagLayout GridLayout Group Guard GuardedObject GZIPInputStream)>]
insert[insert(+)string<content(      GZIPOutputStream Handler HandshakeCompletedEvent HandshakeCompletedListener HasControls HashAttributeSet)>]
insert[insert(+)string<content(      HashDocAttributeSet HashMap HashPrintJobAttributeSet HashPrintRequestAttributeSet)>]
insert[insert(+)string<content(      HashPrintServiceAttributeSet HashSet Hashtable HeadlessException HierarchyBoundsAdapter)>]
insert[insert(+)string<content(      HierarchyBoundsListener HierarchyEvent HierarchyListener Highlighter HostnameVerifier HTML HTMLDocument)>]
insert[insert(+)string<content(      HTMLEditorKit HTMLFrameHyperlinkEvent HTMLWriter HttpRetryException HttpsURLConnection HttpURLConnection)>]
insert[insert(+)string<content(      HyperlinkEvent HyperlinkListener ICC_ColorSpace ICC_Profile ICC_ProfileGray ICC_ProfileRGB Icon)>]
insert[insert(+)string<content(      IconUIResource IconView Identity IdentityHashMap IdentityScope IIOByteBuffer IIOException IIOImage)>]
insert[insert(+)string<content(      IIOInvalidTreeException IIOMetadata IIOMetadataController IIOMetadataFormat IIOMetadataFormatImpl)>]
insert[insert(+)string<content(      IIOMetadataNode IIOParam IIOParamController IIOReadProgressListener IIOReadUpdateListener)>]
insert[insert(+)string<content(      IIOReadWarningListener IIORegistry IIOServiceProvider IIOWriteProgressListener IIOWriteWarningListener)>]
insert[insert(+)string<content(      IllegalAccessError IllegalAccessException IllegalArgumentException IllegalBlockingModeException)>]
insert[insert(+)string<content(      IllegalBlockSizeException IllegalCharsetNameException IllegalClassFormatException)>]
insert[insert(+)string<content(      IllegalComponentStateException IllegalFormatCodePointException IllegalFormatConversionException)>]
insert[insert(+)string<content(      IllegalFormatException IllegalFormatFlagsException IllegalFormatPrecisionException)>]
insert[insert(+)string<content(      IllegalFormatWidthException IllegalMonitorStateException IllegalPathStateException)>]
insert[insert(+)string<content(      IllegalSelectorException IllegalStateException IllegalThreadStateException Image ImageCapabilities)>]
insert[insert(+)string<content(      ImageConsumer ImageFilter ImageGraphicAttribute ImageIcon ImageInputStream ImageInputStreamImpl)>]
insert[insert(+)string<content(      ImageInputStreamSpi ImageIO ImageObserver ImageOutputStream ImageOutputStreamImpl ImageOutputStreamSpi)>]
insert[insert(+)string<content(      ImageProducer ImageReader ImageReaderSpi ImageReaderWriterSpi ImageReadParam ImageTranscoder)>]
insert[insert(+)string<content(      ImageTranscoderSpi ImageTypeSpecifier ImageView ImageWriteParam ImageWriter ImageWriterSpi)>]
insert[insert(+)string<content(      ImagingOpException IncompatibleClassChangeError IncompleteAnnotationException IndexColorModel)>]
insert[insert(+)string<content(      IndexedPropertyChangeEvent IndexedPropertyDescriptor IndexOutOfBoundsException Inet4Address Inet6Address)>]
insert[insert(+)string<content(      InetAddress InetSocketAddress Inflater InflaterInputStream InheritableThreadLocal Inherited)>]
insert[insert(+)string<content(      InitialContext InitialContextFactory InitialContextFactoryBuilder InitialDirContext InitialLdapContext)>]
insert[insert(+)string<content(      InlineView InputContext InputEvent InputMap InputMapUIResource InputMethod InputMethodContext)>]
insert[insert(+)string<content(      InputMethodDescriptor InputMethodEvent InputMethodHighlight InputMethodListener InputMethodRequests)>]
insert[insert(+)string<content(      InputMismatchException InputStream InputStreamReader InputSubset InputVerifier Insets InsetsUIResource)>]
insert[insert(+)string<content(      InstanceAlreadyExistsException InstanceNotFoundException InstantiationError InstantiationException)>]
insert[insert(+)string<content(      Instrument Instrumentation InsufficientResourcesException IntBuffer Integer IntegerSyntax InternalError)>]
insert[insert(+)string<content(      InternalFrameAdapter InternalFrameEvent InternalFrameFocusTraversalPolicy InternalFrameListener)>]
insert[insert(+)string<content(      InternalFrameUI InternationalFormatter InterruptedException InterruptedIOException)>]
insert[insert(+)string<content(      InterruptedNamingException InterruptibleChannel IntrospectionException Introspector)>]
insert[insert(+)string<content(      InvalidActivityException InvalidAlgorithmParameterException InvalidApplicationException)>]
insert[insert(+)string<content(      InvalidAttributeIdentifierException InvalidAttributesException InvalidAttributeValueException)>]
insert[insert(+)string<content(      InvalidClassException InvalidDnDOperationException InvalidKeyException InvalidKeySpecException)>]
insert[insert(+)string<content(      InvalidMarkException InvalidMidiDataException InvalidNameException InvalidObjectException)>]
insert[insert(+)string<content(      InvalidOpenTypeException InvalidParameterException InvalidParameterSpecException)>]
insert[insert(+)string<content(      InvalidPreferencesFormatException InvalidPropertiesFormatException InvalidRelationIdException)>]
insert[insert(+)string<content(      InvalidRelationServiceException InvalidRelationTypeException InvalidRoleInfoException)>]
insert[insert(+)string<content(      InvalidRoleValueException InvalidSearchControlsException InvalidSearchFilterException)>]
insert[insert(+)string<content(      InvalidTargetObjectTypeException InvalidTransactionException InvocationEvent InvocationHandler)>]
insert[insert(+)string<content(      InvocationTargetException IOException ItemEvent ItemListener ItemSelectable Iterable Iterator)>]
insert[insert(+)string<content(      IvParameterSpec JApplet JarEntry JarException JarFile JarInputStream JarOutputStream JarURLConnection)>]
insert[insert(+)string<content(      JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JdbcRowSet JDesktopPane JDialog)>]
insert[insert(+)string<content(      JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayeredPane JList JMenu)>]
insert[insert(+)string<content(      JMenuBar JMenuItem JMException JMRuntimeException JMXAuthenticator JMXConnectionNotification)>]
insert[insert(+)string<content(      JMXConnector JMXConnectorFactory JMXConnectorProvider JMXConnectorServer JMXConnectorServerFactory)>]
insert[insert(+)string<content(      JMXConnectorServerMBean JMXConnectorServerProvider JMXPrincipal JMXProviderException)>]
insert[insert(+)string<content(      JMXServerErrorException JMXServiceURL JobAttributes JobHoldUntil JobImpressions JobImpressionsCompleted)>]
insert[insert(+)string<content(      JobImpressionsSupported JobKOctets JobKOctetsProcessed JobKOctetsSupported JobMediaSheets)>]
insert[insert(+)string<content(      JobMediaSheetsCompleted JobMediaSheetsSupported JobMessageFromOperator JobName JobOriginatingUserName)>]
insert[insert(+)string<content(      JobPriority JobPrioritySupported JobSheets JobState JobStateReason JobStateReasons Joinable JoinRowSet)>]
insert[insert(+)string<content(      JOptionPane JPanel JPasswordField JPEGHuffmanTable JPEGImageReadParam JPEGImageWriteParam JPEGQTable)>]
insert[insert(+)string<content(      JPopupMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator)>]
insert[insert(+)string<content(      JSlider JSpinner JSplitPane JTabbedPane JTable JTableHeader JTextArea JTextComponent JTextField)>]
insert[insert(+)string<content(      JTextPane JToggleButton JToolBar JToolTip JTree JViewport JWindow KerberosKey KerberosPrincipal)>]
insert[insert(+)string<content(      KerberosTicket Kernel Key KeyAdapter KeyAgreement KeyAgreementSpi KeyAlreadyExistsException)>]
insert[insert(+)string<content(      KeyboardFocusManager KeyEvent KeyEventDispatcher KeyEventPostProcessor KeyException KeyFactory)>]
insert[insert(+)string<content(      KeyFactorySpi KeyGenerator KeyGeneratorSpi KeyListener KeyManagementException KeyManager)>]
insert[insert(+)string<content(      KeyManagerFactory KeyManagerFactorySpi Keymap KeyPair KeyPairGenerator KeyPairGeneratorSpi KeyRep)>]
insert[insert(+)string<content(      KeySpec KeyStore KeyStoreBuilderParameters KeyStoreException KeyStoreSpi KeyStroke Label LabelUI)>]
insert[insert(+)string<content(      LabelView LanguageCallback LastOwnerException LayeredHighlighter LayoutFocusTraversalPolicy)>]
insert[insert(+)string<content(      LayoutManager LayoutManager2 LayoutQueue LDAPCertStoreParameters LdapContext LdapName)>]
insert[insert(+)string<content(      LdapReferralException Lease Level LimitExceededException Line Line2D LineBorder LineBreakMeasurer)>]
insert[insert(+)string<content(      LineEvent LineListener LineMetrics LineNumberInputStream LineNumberReader LineUnavailableException)>]
insert[insert(+)string<content(      LinkageError LinkedBlockingQueue LinkedHashMap LinkedHashSet LinkedList LinkException LinkLoopException)>]
insert[insert(+)string<content(      LinkRef List ListCellRenderer ListDataEvent ListDataListener ListenerNotFoundException ListIterator)>]
insert[insert(+)string<content(      ListModel ListResourceBundle ListSelectionEvent ListSelectionListener ListSelectionModel ListUI ListView)>]
insert[insert(+)string<content(      LoaderHandler Locale LocateRegistry Lock LockSupport Logger LoggingMXBean LoggingPermission LoginContext)>]
insert[insert(+)string<content(      LoginException LoginModule LogManager LogRecord LogStream Long LongBuffer LookAndFeel LookupOp)>]
insert[insert(+)string<content(      LookupTable Mac MacSpi MalformedInputException MalformedLinkException MalformedObjectNameException)>]
insert[insert(+)string<content(      MalformedParameterizedTypeException MalformedURLException ManagementFactory ManagementPermission)>]
insert[insert(+)string<content(      ManageReferralControl ManagerFactoryParameters Manifest Map MappedByteBuffer MarshalException)>]
insert[insert(+)string<content(      MarshalledObject MaskFormatter Matcher MatchResult Math MathContext MatteBorder MBeanAttributeInfo)>]
insert[insert(+)string<content(      MBeanConstructorInfo MBeanException MBeanFeatureInfo MBeanInfo MBeanNotificationInfo MBeanOperationInfo)>]
insert[insert(+)string<content(      MBeanParameterInfo MBeanPermission MBeanRegistration MBeanRegistrationException MBeanServer)>]
insert[insert(+)string<content(      MBeanServerBuilder MBeanServerConnection MBeanServerDelegate MBeanServerDelegateMBean MBeanServerFactory)>]
insert[insert(+)string<content(      MBeanServerForwarder MBeanServerInvocationHandler MBeanServerNotification MBeanServerNotificationFilter)>]
insert[insert(+)string<content(      MBeanServerPermission MBeanTrustPermission Media MediaName MediaPrintableArea MediaSize MediaSizeName)>]
insert[insert(+)string<content(      MediaTracker MediaTray Member MemoryCacheImageInputStream MemoryCacheImageOutputStream MemoryHandler)>]
insert[insert(+)string<content(      MemoryImageSource MemoryManagerMXBean MemoryMXBean MemoryNotificationInfo MemoryPoolMXBean MemoryType)>]
insert[insert(+)string<content(      MemoryUsage Menu MenuBar MenuBarUI MenuComponent MenuContainer MenuDragMouseEvent MenuDragMouseListener)>]
insert[insert(+)string<content(      MenuElement MenuEvent MenuItem MenuItemUI MenuKeyEvent MenuKeyListener MenuListener MenuSelectionManager)>]
insert[insert(+)string<content(      MenuShortcut MessageDigest MessageDigestSpi MessageFormat MetaEventListener MetalBorders MetalButtonUI)>]
insert[insert(+)string<content(      MetalCheckBoxIcon MetalCheckBoxUI MetalComboBoxButton MetalComboBoxEditor MetalComboBoxIcon)>]
insert[insert(+)string<content(      MetalComboBoxUI MetalDesktopIconUI MetalFileChooserUI MetalIconFactory MetalInternalFrameTitlePane)>]
insert[insert(+)string<content(      MetalInternalFrameUI MetalLabelUI MetalLookAndFeel MetalMenuBarUI MetalPopupMenuSeparatorUI)>]
insert[insert(+)string<content(      MetalProgressBarUI MetalRadioButtonUI MetalRootPaneUI MetalScrollBarUI MetalScrollButton)>]
insert[insert(+)string<content(      MetalScrollPaneUI MetalSeparatorUI MetalSliderUI MetalSplitPaneUI MetalTabbedPaneUI MetalTextFieldUI)>]
insert[insert(+)string<content(      MetalTheme MetalToggleButtonUI MetalToolBarUI MetalToolTipUI MetalTreeUI MetaMessage Method)>]
insert[insert(+)string<content(      MethodDescriptor MGF1ParameterSpec MidiChannel MidiDevice MidiDeviceProvider MidiEvent MidiFileFormat)>]
insert[insert(+)string<content(      MidiFileReader MidiFileWriter MidiMessage MidiSystem MidiUnavailableException MimeTypeParseException)>]
insert[insert(+)string<content(      MinimalHTMLWriter MissingFormatArgumentException MissingFormatWidthException MissingResourceException)>]
insert[insert(+)string<content(      Mixer MixerProvider MLet MLetMBean ModelMBean ModelMBeanAttributeInfo ModelMBeanConstructorInfo)>]
insert[insert(+)string<content(      ModelMBeanInfo ModelMBeanInfoSupport ModelMBeanNotificationBroadcaster ModelMBeanNotificationInfo)>]
insert[insert(+)string<content(      ModelMBeanOperationInfo ModificationItem Modifier Monitor MonitorMBean MonitorNotification)>]
insert[insert(+)string<content(      MonitorSettingException MouseAdapter MouseDragGestureRecognizer MouseEvent MouseInfo MouseInputAdapter)>]
insert[insert(+)string<content(      MouseInputListener MouseListener MouseMotionAdapter MouseMotionListener MouseWheelEvent)>]
insert[insert(+)string<content(      MouseWheelListener MultiButtonUI MulticastSocket MultiColorChooserUI MultiComboBoxUI MultiDesktopIconUI)>]
insert[insert(+)string<content(      MultiDesktopPaneUI MultiDoc MultiDocPrintJob MultiDocPrintService MultiFileChooserUI)>]
insert[insert(+)string<content(      MultiInternalFrameUI MultiLabelUI MultiListUI MultiLookAndFeel MultiMenuBarUI MultiMenuItemUI)>]
insert[insert(+)string<content(      MultiOptionPaneUI MultiPanelUI MultiPixelPackedSampleModel MultipleDocumentHandling MultipleMaster)>]
insert[insert(+)string<content(      MultiPopupMenuUI MultiProgressBarUI MultiRootPaneUI MultiScrollBarUI MultiScrollPaneUI MultiSeparatorUI)>]
insert[insert(+)string<content(      MultiSliderUI MultiSpinnerUI MultiSplitPaneUI MultiTabbedPaneUI MultiTableHeaderUI MultiTableUI)>]
insert[insert(+)string<content(      MultiTextUI MultiToolBarUI MultiToolTipUI MultiTreeUI MultiViewportUI MutableAttributeSet)>]
insert[insert(+)string<content(      MutableComboBoxModel MutableTreeNode Name NameAlreadyBoundException NameCallback NameClassPair)>]
insert[insert(+)string<content(      NameNotFoundException NameParser NamespaceChangeListener NamespaceContext Naming NamingEnumeration)>]
insert[insert(+)string<content(      NamingEvent NamingException NamingExceptionEvent NamingListener NamingManager NamingSecurityException)>]
insert[insert(+)string<content(      NavigationFilter NegativeArraySizeException NetPermission NetworkInterface NoClassDefFoundError)>]
insert[insert(+)string<content(      NoConnectionPendingException NodeChangeEvent NodeChangeListener NoInitialContextException)>]
insert[insert(+)string<content(      NoninvertibleTransformException NonReadableChannelException NonWritableChannelException)>]
insert[insert(+)string<content(      NoPermissionException NoRouteToHostException NoSuchAlgorithmException NoSuchAttributeException)>]
insert[insert(+)string<content(      NoSuchElementException NoSuchFieldError NoSuchFieldException NoSuchMethodError NoSuchMethodException)>]
insert[insert(+)string<content(      NoSuchObjectException NoSuchPaddingException NoSuchProviderException NotActiveException)>]
insert[insert(+)string<content(      NotBoundException NotCompliantMBeanException NotContextException Notification NotificationBroadcaster)>]
insert[insert(+)string<content(      NotificationBroadcasterSupport NotificationEmitter NotificationFilter NotificationFilterSupport)>]
insert[insert(+)string<content(      NotificationListener NotificationResult NotOwnerException NotSerializableException NotYetBoundException)>]
insert[insert(+)string<content(      NotYetConnectedException NullCipher NullPointerException Number NumberFormat NumberFormatException)>]
insert[insert(+)string<content(      NumberFormatter NumberOfDocuments NumberOfInterveningJobs NumberUp NumberUpSupported NumericShaper)>]
insert[insert(+)string<content(      OAEPParameterSpec Object ObjectChangeListener ObjectFactory ObjectFactoryBuilder ObjectInput)>]
insert[insert(+)string<content(      ObjectInputStream ObjectInputValidation ObjectInstance ObjectName ObjectOutput ObjectOutputStream)>]
insert[insert(+)string<content(      ObjectStreamClass ObjectStreamConstants ObjectStreamException ObjectStreamField ObjectView ObjID)>]
insert[insert(+)string<content(      Observable Observer OceanTheme OpenDataException OpenMBeanAttributeInfo OpenMBeanAttributeInfoSupport)>]
insert[insert(+)string<content(      OpenMBeanConstructorInfo OpenMBeanConstructorInfoSupport OpenMBeanInfo OpenMBeanInfoSupport)>]
insert[insert(+)string<content(      OpenMBeanOperationInfo OpenMBeanOperationInfoSupport OpenMBeanParameterInfo)>]
insert[insert(+)string<content(      OpenMBeanParameterInfoSupport OpenType OperatingSystemMXBean Operation OperationNotSupportedException)>]
insert[insert(+)string<content(      OperationsException Option OptionalDataException OptionPaneUI OrientationRequested OutOfMemoryError)>]
insert[insert(+)string<content(      OutputDeviceAssigned OutputKeys OutputStream OutputStreamWriter OverlappingFileLockException)>]
insert[insert(+)string<content(      OverlayLayout Override Owner Pack200 Package PackedColorModel Pageable PageAttributes)>]
insert[insert(+)string<content(      PagedResultsControl PagedResultsResponseControl PageFormat PageRanges PagesPerMinute PagesPerMinuteColor)>]
insert[insert(+)string<content(      Paint PaintContext PaintEvent Panel PanelUI Paper ParagraphView ParameterBlock ParameterDescriptor)>]
insert[insert(+)string<content(      ParameterizedType ParameterMetaData ParseException ParsePosition Parser ParserConfigurationException)>]
insert[insert(+)string<content(      ParserDelegator PartialResultException PasswordAuthentication PasswordCallback PasswordView Patch)>]
insert[insert(+)string<content(      PathIterator Pattern PatternSyntaxException PBEKey PBEKeySpec PBEParameterSpec PDLOverrideSupported)>]
insert[insert(+)string<content(      Permission PermissionCollection Permissions PersistenceDelegate PersistentMBean PhantomReference Pipe)>]
insert[insert(+)string<content(      PipedInputStream PipedOutputStream PipedReader PipedWriter PixelGrabber PixelInterleavedSampleModel)>]
insert[insert(+)string<content(      PKCS8EncodedKeySpec PKIXBuilderParameters PKIXCertPathBuilderResult PKIXCertPathChecker)>]
insert[insert(+)string<content(      PKIXCertPathValidatorResult PKIXParameters PlainDocument PlainView Point Point2D PointerInfo Policy)>]
insert[insert(+)string<content(      PolicyNode PolicyQualifierInfo Polygon PooledConnection Popup PopupFactory PopupMenu PopupMenuEvent)>]
insert[insert(+)string<content(      PopupMenuListener PopupMenuUI Port PortableRemoteObject PortableRemoteObjectDelegate)>]
insert[insert(+)string<content(      PortUnreachableException Position Predicate PreferenceChangeEvent PreferenceChangeListener Preferences)>]
insert[insert(+)string<content(      PreferencesFactory PreparedStatement PresentationDirection Principal Printable PrinterAbortException)>]
insert[insert(+)string<content(      PrinterException PrinterGraphics PrinterInfo PrinterIOException PrinterIsAcceptingJobs PrinterJob)>]
insert[insert(+)string<content(      PrinterLocation PrinterMakeAndModel PrinterMessageFromOperator PrinterMoreInfo)>]
insert[insert(+)string<content(      PrinterMoreInfoManufacturer PrinterName PrinterResolution PrinterState PrinterStateReason)>]
insert[insert(+)string<content(      PrinterStateReasons PrinterURI PrintEvent PrintException PrintGraphics PrintJob PrintJobAdapter)>]
insert[insert(+)string<content(      PrintJobAttribute PrintJobAttributeEvent PrintJobAttributeListener PrintJobAttributeSet PrintJobEvent)>]
insert[insert(+)string<content(      PrintJobListener PrintQuality PrintRequestAttribute PrintRequestAttributeSet PrintService)>]
insert[insert(+)string<content(      PrintServiceAttribute PrintServiceAttributeEvent PrintServiceAttributeListener PrintServiceAttributeSet)>]
insert[insert(+)string<content(      PrintServiceLookup PrintStream PrintWriter PriorityBlockingQueue PriorityQueue PrivateClassLoader)>]
insert[insert(+)string<content(      PrivateCredentialPermission PrivateKey PrivateMLet PrivilegedAction PrivilegedActionException)>]
insert[insert(+)string<content(      PrivilegedExceptionAction Process ProcessBuilder ProfileDataException ProgressBarUI ProgressMonitor)>]
insert[insert(+)string<content(      ProgressMonitorInputStream Properties PropertyChangeEvent PropertyChangeListener)>]
insert[insert(+)string<content(      PropertyChangeListenerProxy PropertyChangeSupport PropertyDescriptor PropertyEditor)>]
insert[insert(+)string<content(      PropertyEditorManager PropertyEditorSupport PropertyPermission PropertyResourceBundle)>]
insert[insert(+)string<content(      PropertyVetoException ProtectionDomain ProtocolException Provider ProviderException Proxy ProxySelector)>]
insert[insert(+)string<content(      PSource PSSParameterSpec PublicKey PushbackInputStream PushbackReader QName QuadCurve2D Query QueryEval)>]
insert[insert(+)string<content(      QueryExp Queue QueuedJobCount Random RandomAccess RandomAccessFile Raster RasterFormatException RasterOp)>]
insert[insert(+)string<content(      RC2ParameterSpec RC5ParameterSpec Rdn Readable ReadableByteChannel Reader ReadOnlyBufferException)>]
insert[insert(+)string<content(      ReadWriteLock RealmCallback RealmChoiceCallback Receiver Rectangle Rectangle2D RectangularShape)>]
insert[insert(+)string<content(      ReentrantLock ReentrantReadWriteLock Ref RefAddr Reference Referenceable ReferenceQueue)>]
insert[insert(+)string<content(      ReferenceUriSchemesSupported ReferralException ReflectionException ReflectPermission Refreshable)>]
insert[insert(+)string<content(      RefreshFailedException Region RegisterableService Registry RegistryHandler RejectedExecutionException)>]
insert[insert(+)string<content(      RejectedExecutionHandler Relation RelationException RelationNotFoundException RelationNotification)>]
insert[insert(+)string<content(      RelationService RelationServiceMBean RelationServiceNotRegisteredException RelationSupport)>]
insert[insert(+)string<content(      RelationSupportMBean RelationType RelationTypeNotFoundException RelationTypeSupport Remote RemoteCall)>]
insert[insert(+)string<content(      RemoteException RemoteObject RemoteObjectInvocationHandler RemoteRef RemoteServer RemoteStub)>]
insert[insert(+)string<content(      RenderableImage RenderableImageOp RenderableImageProducer RenderContext RenderedImage)>]
insert[insert(+)string<content(      RenderedImageFactory Renderer RenderingHints RepaintManager ReplicateScaleFilter RequestingUserName)>]
insert[insert(+)string<content(      RequiredModelMBean RescaleOp ResolutionSyntax Resolver ResolveResult ResourceBundle ResponseCache Result)>]
insert[insert(+)string<content(      ResultSet ResultSetMetaData Retention RetentionPolicy ReverbType RGBImageFilter RMIClassLoader)>]
insert[insert(+)string<content(      RMIClassLoaderSpi RMIClientSocketFactory RMIConnection RMIConnectionImpl RMIConnectionImpl_Stub)>]
insert[insert(+)string<content(      RMIConnector RMIConnectorServer RMIFailureHandler RMIIIOPServerImpl RMIJRMPServerImpl)>]
insert[insert(+)string<content(      RMISecurityException RMISecurityManager RMIServer RMIServerImpl RMIServerImpl_Stub)>]
insert[insert(+)string<content(      RMIServerSocketFactory RMISocketFactory Robot Role RoleInfo RoleInfoNotFoundException RoleList)>]
insert[insert(+)string<content(      RoleNotFoundException RoleResult RoleStatus RoleUnresolved RoleUnresolvedList RootPaneContainer)>]
insert[insert(+)string<content(      RootPaneUI RoundingMode RoundRectangle2D RowMapper RowSet RowSetEvent RowSetInternal RowSetListener)>]
insert[insert(+)string<content(      RowSetMetaData RowSetMetaDataImpl RowSetReader RowSetWarning RowSetWriter RSAKey RSAKeyGenParameterSpec)>]
insert[insert(+)string<content(      RSAMultiPrimePrivateCrtKey RSAMultiPrimePrivateCrtKeySpec RSAOtherPrimeInfo RSAPrivateCrtKey)>]
insert[insert(+)string<content(      RSAPrivateCrtKeySpec RSAPrivateKey RSAPrivateKeySpec RSAPublicKey RSAPublicKeySpec RTFEditorKit)>]
insert[insert(+)string<content(      RuleBasedCollator Runnable Runtime RuntimeErrorException RuntimeException RuntimeMBeanException)>]
insert[insert(+)string<content(      RuntimeMXBean RuntimeOperationsException RuntimePermission SampleModel Sasl SaslClient SaslClientFactory)>]
insert[insert(+)string<content(      SaslException SaslServer SaslServerFactory Savepoint SAXParser SAXParserFactory SAXResult SAXSource)>]
insert[insert(+)string<content(      SAXTransformerFactory Scanner ScatteringByteChannel ScheduledExecutorService ScheduledFuture)>]
insert[insert(+)string<content(      ScheduledThreadPoolExecutor Schema SchemaFactory SchemaFactoryLoader SchemaViolationException Scrollable)>]
insert[insert(+)string<content(      Scrollbar ScrollBarUI ScrollPane ScrollPaneAdjustable ScrollPaneConstants ScrollPaneLayout ScrollPaneUI)>]
insert[insert(+)string<content(      SealedObject SearchControls SearchResult SecretKey SecretKeyFactory SecretKeyFactorySpi SecretKeySpec)>]
insert[insert(+)string<content(      SecureCacheResponse SecureClassLoader SecureRandom SecureRandomSpi Security SecurityException)>]
insert[insert(+)string<content(      SecurityManager SecurityPermission Segment SelectableChannel SelectionKey Selector SelectorProvider)>]
insert[insert(+)string<content(      Semaphore SeparatorUI Sequence SequenceInputStream Sequencer SerialArray SerialBlob SerialClob)>]
insert[insert(+)string<content(      SerialDatalink SerialException Serializable SerializablePermission SerialJavaObject SerialRef)>]
insert[insert(+)string<content(      SerialStruct ServerCloneException ServerError ServerException ServerNotActiveException ServerRef)>]
insert[insert(+)string<content(      ServerRuntimeException ServerSocket ServerSocketChannel ServerSocketFactory ServiceNotFoundException)>]
insert[insert(+)string<content(      ServicePermission ServiceRegistry ServiceUI ServiceUIFactory ServiceUnavailableException Set)>]
insert[insert(+)string<content(      SetOfIntegerSyntax Severity Shape ShapeGraphicAttribute SheetCollate Short ShortBuffer)>]
insert[insert(+)string<content(      ShortBufferException ShortLookupTable ShortMessage Sides Signature SignatureException SignatureSpi)>]
insert[insert(+)string<content(      SignedObject Signer SimpleAttributeSet SimpleBeanInfo SimpleDateFormat SimpleDoc SimpleFormatter)>]
insert[insert(+)string<content(      SimpleTimeZone SimpleType SinglePixelPackedSampleModel SingleSelectionModel Size2DSyntax)>]
insert[insert(+)string<content(      SizeLimitExceededException SizeRequirements SizeSequence Skeleton SkeletonMismatchException)>]
insert[insert(+)string<content(      SkeletonNotFoundException SliderUI Socket SocketAddress SocketChannel SocketException SocketFactory)>]
insert[insert(+)string<content(      SocketHandler SocketImpl SocketImplFactory SocketOptions SocketPermission SocketSecurityException)>]
insert[insert(+)string<content(      SocketTimeoutException SoftBevelBorder SoftReference SortControl SortedMap SortedSet)>]
insert[insert(+)string<content(      SortingFocusTraversalPolicy SortKey SortResponseControl Soundbank SoundbankReader SoundbankResource)>]
insert[insert(+)string<content(      Source SourceDataLine SourceLocator SpinnerDateModel SpinnerListModel SpinnerModel SpinnerNumberModel)>]
insert[insert(+)string<content(      SpinnerUI SplitPaneUI Spring SpringLayout SQLData SQLException SQLInput SQLInputImpl SQLOutput)>]
insert[insert(+)string<content(      SQLOutputImpl SQLPermission SQLWarning SSLContext SSLContextSpi SSLEngine SSLEngineResult SSLException)>]
insert[insert(+)string<content(      SSLHandshakeException SSLKeyException SSLPeerUnverifiedException SSLPermission SSLProtocolException)>]
insert[insert(+)string<content(      SslRMIClientSocketFactory SslRMIServerSocketFactory SSLServerSocket SSLServerSocketFactory SSLSession)>]
insert[insert(+)string<content(      SSLSessionBindingEvent SSLSessionBindingListener SSLSessionContext SSLSocket SSLSocketFactory Stack)>]
insert[insert(+)string<content(      StackOverflowError StackTraceElement StandardMBean StartTlsRequest StartTlsResponse StateEdit)>]
insert[insert(+)string<content(      StateEditable StateFactory Statement StreamCorruptedException StreamHandler StreamPrintService)>]
insert[insert(+)string<content(      StreamPrintServiceFactory StreamResult StreamSource StreamTokenizer StrictMath String StringBuffer)>]
insert[insert(+)string<content(      StringBufferInputStream StringBuilder StringCharacterIterator StringContent)>]
insert[insert(+)string<content(      StringIndexOutOfBoundsException StringMonitor StringMonitorMBean StringReader StringRefAddr)>]
insert[insert(+)string<content(      StringSelection StringTokenizer StringValueExp StringWriter Stroke Struct Stub StubDelegate)>]
insert[insert(+)string<content(      StubNotFoundException Style StyleConstants StyleContext StyledDocument StyledEditorKit StyleSheet)>]
insert[insert(+)string<content(      Subject SubjectDelegationPermission SubjectDomainCombiner SupportedValuesAttribute SuppressWarnings)>]
insert[insert(+)string<content(      SwingConstants SwingPropertyChangeSupport SwingUtilities SyncFactory SyncFactoryException)>]
insert[insert(+)string<content(      SyncFailedException SynchronousQueue SyncProvider SyncProviderException SyncResolver SynthConstants)>]
insert[insert(+)string<content(      SynthContext Synthesizer SynthGraphicsUtils SynthLookAndFeel SynthPainter SynthStyle SynthStyleFactory)>]
insert[insert(+)string<content(      SysexMessage System SystemColor SystemFlavorMap TabableView TabbedPaneUI TabExpander TableCellEditor)>]
insert[insert(+)string<content(      TableCellRenderer TableColumn TableColumnModel TableColumnModelEvent TableColumnModelListener)>]
insert[insert(+)string<content(      TableHeaderUI TableModel TableModelEvent TableModelListener TableUI TableView TabSet TabStop TabularData)>]
insert[insert(+)string<content(      TabularDataSupport TabularType TagElement Target TargetDataLine TargetedNotification Templates)>]
insert[insert(+)string<content(      TemplatesHandler TextAction TextArea TextAttribute TextComponent TextEvent TextField TextHitInfo)>]
insert[insert(+)string<content(      TextInputCallback TextLayout TextListener TextMeasurer TextOutputCallback TextSyntax TextUI TexturePaint)>]
insert[insert(+)string<content(      Thread ThreadDeath ThreadFactory ThreadGroup ThreadInfo ThreadLocal ThreadMXBean ThreadPoolExecutor)>]
insert[insert(+)string<content(      Throwable Tie TileObserver Time TimeLimitExceededException TimeoutException Timer)>]
insert[insert(+)string<content(      TimerAlarmClockNotification TimerMBean TimerNotification TimerTask Timestamp TimeUnit TimeZone)>]
insert[insert(+)string<content(      TitledBorder ToolBarUI Toolkit ToolTipManager ToolTipUI TooManyListenersException Track)>]
insert[insert(+)string<content(      TransactionalWriter TransactionRequiredException TransactionRolledbackException Transferable)>]
insert[insert(+)string<content(      TransferHandler TransformAttribute Transformer TransformerConfigurationException TransformerException)>]
insert[insert(+)string<content(      TransformerFactory TransformerFactoryConfigurationError TransformerHandler Transmitter Transparency)>]
insert[insert(+)string<content(      TreeCellEditor TreeCellRenderer TreeExpansionEvent TreeExpansionListener TreeMap TreeModel)>]
insert[insert(+)string<content(      TreeModelEvent TreeModelListener TreeNode TreePath TreeSelectionEvent TreeSelectionListener)>]
insert[insert(+)string<content(      TreeSelectionModel TreeSet TreeUI TreeWillExpandListener TrustAnchor TrustManager TrustManagerFactory)>]
insert[insert(+)string<content(      TrustManagerFactorySpi Type TypeInfoProvider TypeNotPresentException Types TypeVariable UID UIDefaults)>]
insert[insert(+)string<content(      UIManager UIResource UndeclaredThrowableException UndoableEdit UndoableEditEvent UndoableEditListener)>]
insert[insert(+)string<content(      UndoableEditSupport UndoManager UnexpectedException UnicastRemoteObject UnknownError)>]
insert[insert(+)string<content(      UnknownFormatConversionException UnknownFormatFlagsException UnknownGroupException UnknownHostException)>]
insert[insert(+)string<content(      UnknownObjectException UnknownServiceException UnmappableCharacterException UnmarshalException)>]
insert[insert(+)string<content(      UnmodifiableClassException UnmodifiableSetException UnrecoverableEntryException)>]
insert[insert(+)string<content(      UnrecoverableKeyException Unreferenced UnresolvedAddressException UnresolvedPermission)>]
insert[insert(+)string<content(      UnsatisfiedLinkError UnsolicitedNotification UnsolicitedNotificationEvent)>]
insert[insert(+)string<content(      UnsolicitedNotificationListener UnsupportedAddressTypeException UnsupportedAudioFileException)>]
insert[insert(+)string<content(      UnsupportedCallbackException UnsupportedCharsetException UnsupportedClassVersionError)>]
insert[insert(+)string<content(      UnsupportedEncodingException UnsupportedFlavorException UnsupportedLookAndFeelException)>]
insert[insert(+)string<content(      UnsupportedOperationException URI URIException URIResolver URISyntax URISyntaxException URL)>]
insert[insert(+)string<content(      URLClassLoader URLConnection URLDecoder URLEncoder URLStreamHandler URLStreamHandlerFactory)>]
insert[insert(+)string<content(      UTFDataFormatException Util UtilDelegate Utilities UUID Validator ValidatorHandler ValueExp ValueHandler)>]
insert[insert(+)string<content(      ValueHandlerMultiFormat VariableHeightLayoutCache Vector VerifyError VetoableChangeListener)>]
insert[insert(+)string<content(      VetoableChangeListenerProxy VetoableChangeSupport View ViewFactory ViewportLayout ViewportUI)>]
insert[insert(+)string<content(      VirtualMachineError Visibility VMID VoiceStatus Void VolatileImage WeakHashMap WeakReference WebRowSet)>]
insert[insert(+)string<content(      WildcardType Window WindowAdapter WindowConstants WindowEvent WindowFocusListener WindowListener)>]
insert[insert(+)string<content(      WindowStateListener WrappedPlainView WritableByteChannel WritableRaster WritableRenderedImage)>]
insert[insert(+)string<content(      WriteAbortedException Writer X500Principal X500PrivateCredential X509Certificate X509CertSelector)>]
insert[insert(+)string<content(      X509CRL X509CRLEntry X509CRLSelector X509EncodedKeySpec X509ExtendedKeyManager X509Extension)>]
insert[insert(+)string<content(      X509KeyManager X509TrustManager XAConnection XADataSource XAException XAResource Xid XMLConstants)>]
insert[insert(+)string<content(      XMLDecoder XMLEncoder XMLFormatter XMLGregorianCalendar XMLParseException XmlReader XmlWriter XPath)>]
insert[insert(+)string<content(      XPathConstants XPathException XPathExpression XPathExpressionException XPathFactory)>]
insert[insert(+)string<content(      XPathFactoryConfigurationException XPathFunction XPathFunctionException XPathFunctionResolver)>]
insert[insert(+)string<content(      XPathVariableResolver ZipEntry ZipException ZipFile ZipInputStream ZipOutputStream ZoneView)>]
insert[insert(+)string<content(    )delimiter(])>]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/ruby.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/ruby.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/ruby.rb)plain(	(revision 500\))]
change[change(@@)plain( -21,6 +21,10 )change(@@)]
     ident(file_extension) string<delimiter(')content(rb)delimiter(')>
 
     ident(helper) symbol(:patterns)
insert[insert(+)    ]
insert[insert(+)    keyword(if) keyword(not) keyword(defined?) constant(EncodingError)]
insert[insert(+)      constant(EncodingError) operator(=) constant(Class)operator(.)ident(new) constant(Exception)]
insert[insert(+)    keyword(end)]
 
   ident(private)
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
change[change(@@)plain( -31,9 +35,10 )change(@@)]
       ident(state) operator(=) symbol(:initial)
       ident(depth) operator(=) predefined_constant(nil)
       ident(inline_block_stack) operator(=) operator([)operator(])
delete[delete(-)]
insert[insert(+)      ident(unicode) operator(=) ident(string)operator(.)ident(respond_to?)operator(()symbol(:encoding)operator(\)) operator(&&) ident(string)operator(.)ident(encoding)operator(.)ident(name) operator(==) string<delimiter(')content(UTF-8)delimiter(')>]
insert[insert(+)      ]
       ident(patterns) operator(=) constant(Patterns)  comment(# avoid constant lookup)
delete[delete(-)]
insert[insert(+)eyecatcher<      >]
       keyword(until) ident(eos?)
         ident(match) operator(=) predefined_constant(nil)
         ident(kind) operator(=) predefined_constant(nil)
change[change(@@)plain( -125,14 +130,14 )change(@@)]
           keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([ )char(\\t)char(\\f)content(]+)delimiter(/)>operator(\))
             ident(kind) operator(=) symbol(:space)
             ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(*)delimiter(/)>operator(\)) keyword(unless) ident(eos?) operator(||) ident(heredocs)
delete[delete(-)            ident(value_expected) operator(=) predefined_constant(true) keyword(if) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))eyecatcher< comment(# FIXME not quite true)>]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true) keyword(if) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))]
             ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
             keyword(next)
             
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(?)char(\\n)delimiter(/)>operator(\))
             ident(kind) operator(=) symbol(:space)
             keyword(if) ident(match) operator(==) string<delimiter(")char(\\n)delimiter(")>
delete[delete(-)              ident(value_expected) operator(=) predefined_constant(true)eyecatcher<  comment(# FIXME not quite true)>]
insert[insert(+)              ident(value_expected) operator(=) predefined_constant(true)]
               ident(state) operator(=) symbol(:initial) keyword(if) ident(state) operator(==) symbol(:undef_comma_expected)
             keyword(end)
             keyword(if) ident(heredocs)
change[change(@@)plain( -147,17 +152,21 )change(@@)]
             ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
             keyword(next)
           
insert[insert(+)          keyword(elsif) ident(bol?) operator(&&) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\#)content(!.*)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:doctype)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)            ]
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\#)content(.*)delimiter(/)>operator(\)) keyword(or)
             operator(() ident(bol?) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(RUBYDOC_OR_DATA)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) operator(\))
               ident(kind) operator(=) symbol(:comment)
delete[delete(-)              ident(value_expected) operator(=) predefined_constant(true)]
               ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
               keyword(next)
 
           keyword(elsif) ident(state) operator(==) symbol(:initial)
 
             comment(# IDENTS #)
delete[delete(-)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            keyword(if) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME)inline_delimiter(})>delimiter(/)modifier(uo)> operator(:)]
insert[insert(+)                                      regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
               keyword(if) ident(last_token_dot)
                 ident(kind) operator(=) keyword(if) ident(match)operator([)regexp<delimiter(/)content(^[A-Z])delimiter(/)>operator(]) keyword(and) keyword(not) ident(match?)operator(()regexp<delimiter(/)char(\\()delimiter(/)>operator(\)) keyword(then) symbol(:constant) keyword(else) symbol(:ident) keyword(end)
               keyword(else)
change[change(@@)plain( -166,17 +175,16 )change(@@)]
                   ident(kind) operator(=) symbol(:constant)
                 keyword(elsif) ident(kind) operator(==) symbol(:reserved)
                   ident(state) operator(=) ident(patterns)operator(::)constant(DEF_NEW_STATE)operator([)ident(match)operator(])
insert[insert(+)                  ident(value_expected) operator(=) symbol(:set) keyword(if) ident(patterns)operator(::)constant(KEYWORDS_EXPECTING_VALUE)operator([)ident(match)operator(])]
                 keyword(end)
               keyword(end)
delete[delete(-)              comment(## experimental!)]
               ident(value_expected) operator(=) symbol(:set) keyword(if) ident(check)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(VALUE_FOLLOWS)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
             
delete[delete(-)            keyword(elsif) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OPERATOR)inline_delimiter(})>>regexp<delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            keyword(elsif) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OPERATOR)inline_delimiter(})>>eyecatcher<regexp<content(|)char(\\()>>regexp<delimiter(/)modifier(o)>operator(\))]
               ident(kind) operator(=) symbol(:ident)
               ident(value_expected) operator(=) symbol(:set) keyword(if) ident(check)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(VALUE_FOLLOWS)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
 
             comment(# OPERATORS #)
delete[delete(-)            comment(# TODO: match (\), [], {} as one single operator)]
             keyword(elsif) keyword(not) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\.)char(\\.)char(\\.)content(? | (?:)char(\\.)content(|::\)(\) | [,)char(\\()char(\\\))char(\\[)char(\\])char(\\{)char(\\})content(] | ==?=? )delimiter(/)modifier(x)>operator(\))
               keyword(if) ident(match) operator(!)operator(~) regexp<delimiter(/)content( [.)char(\\\))char(\\])char(\\})content(] )delimiter(/)modifier(x)> keyword(or) ident(match) operator(=)operator(~) regexp<delimiter(/)char(\\.)char(\\.)char(\\.)content(?)delimiter(/)>
                 ident(value_expected) operator(=) symbol(:set)
change[change(@@)plain( -191,6 +199,7 )change(@@)]
                   ident(depth) operator(-=) integer(1)
                   keyword(if) ident(depth) operator(==) integer(0)  comment(# closing brace of inline block reached)
                     ident(state)operator(,) ident(depth)operator(,) ident(heredocs) operator(=) ident(inline_block_stack)operator(.)ident(pop)
insert[insert(+)                    ident(heredocs) operator(=) predefined_constant(nil) keyword(if) ident(heredocs) operator(&&) ident(heredocs)operator(.)ident(empty?)]
                     ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:inline_delimiter)operator(])
                     ident(kind) operator(=) symbol(:inline)
                     ident(match) operator(=) symbol(:close)
change[change(@@)plain( -276,13 +285,24 )change(@@)]
 
             keyword(else)
               ident(kind) operator(=) symbol(:error)
delete[delete(-)              ident(match) operator(=) ident(getch)]
insert[insert(+)              ident(match) operator(=) operator(()ident(scan)operator(()regexp<delimiter(/)content(.)delimiter(/)modifier(mu)>operator(\)) keyword(rescue) predefined_constant(nil)operator(\)) operator(||) ident(getch)]
insert[insert(+)              keyword(if) operator(!)ident(unicode) operator(&&) ident(match)operator(.)ident(size) operator(>) integer(1)]
insert[insert(+)                comment(# warn 'Switching to unicode mode because of char %p' % [match])]
insert[insert(+)                ident(unicode) operator(=) predefined_constant(true)]
insert[insert(+)                ident(unscan)]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(end)]
 
             keyword(end)
 
           keyword(elsif) ident(state) operator(==) symbol(:def_expected)
             ident(state) operator(=) symbol(:initial)
delete[delete(-)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content((?>)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_EX)inline_delimiter(})>content(\)(?!)char(\\.)content(|::\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content(self)char(\\.)delimiter(/)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(self)delimiter(')>operator(,) symbol(:pre_constant)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(.)delimiter(')>operator(,) symbol(:operator)operator(])]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(if) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)content((?>)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_EX)inline_delimiter(})>content(\)(?!)char(\\.)content(|::\))delimiter(/)modifier(uo)> operator(:)]
insert[insert(+)                                      regexp<delimiter(/)content((?>)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_EX)inline_delimiter(})>content(\)(?!)char(\\.)content(|::\))delimiter(/)modifier(o)>operator(\))]
               ident(kind) operator(=) symbol(:method)
             keyword(else)
               keyword(next)
change[change(@@)plain( -322,7 +342,10 )change(@@)]
             keyword(end)
 
           keyword(elsif) ident(state) operator(==) symbol(:alias_expected)
delete[delete(-)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\)([ )char(\\t)content(]+\)()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)content(()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\)([ )char(\\t)content(]+\)()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\))delimiter(/)modifier(uo)> operator(:)]
insert[insert(+)                                   regexp<delimiter(/)content(()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\)([ )char(\\t)content(]+\)()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ]
insert[insert(+)            keyword(if) ident(match)]
               ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(1)operator(])operator(,) operator(()predefined_constant(self)operator([)integer(1)operator(])operator([)integer(0)operator(]) operator(==) integer(?:) operator(?) symbol(:symbol) operator(:) symbol(:method)operator(\))operator(])
               ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(2)operator(])operator(,) symbol(:space)operator(])
               ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(3)operator(])operator(,) operator(()predefined_constant(self)operator([)integer(3)operator(])operator([)integer(0)operator(]) operator(==) integer(?:) operator(?) symbol(:symbol) operator(:) symbol(:method)operator(\))operator(])
change[change(@@)plain( -346,7 +369,7 )change(@@)]
             ident(value_expected) operator(=) ident(value_expected) operator(==) symbol(:set)
             ident(last_token_dot) operator(=) ident(last_token_dot) operator(==) symbol(:set)
           keyword(end)
delete[delete(-)]
insert[insert(+)eyecatcher<          >]
           keyword(if) global_variable($DEBUG) keyword(and) keyword(not) ident(kind)
             ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
               operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)
head[head(Index: )plain(lib/coderay/scanners/python.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/python.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/python.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,289 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for Python. Supports Python 3.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Based on pygments' PythonLexer, see)]
insert[insert(+)  comment(# http://dev.pocoo.org/projects/pygments/browser/pygments/lexers/agile.py.)]
insert[insert(+)  keyword(class) class(Python) operator(<) constant(Scanner)]
insert[insert(+)    ]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:python)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(py)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KEYWORDS) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(as)delimiter(')>operator(,) string<delimiter(')content(assert)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(continue)delimiter(')>operator(,) string<delimiter(')content(def)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(del)delimiter(')>operator(,) string<delimiter(')content(elif)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,) string<delimiter(')content(except)delimiter(')>operator(,) string<delimiter(')content(finally)delimiter(')>operator(,) string<delimiter(')content(for)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(from)delimiter(')>operator(,) string<delimiter(')content(global)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(import)delimiter(')>operator(,) string<delimiter(')content(in)delimiter(')>operator(,) string<delimiter(')content(is)delimiter(')>operator(,) string<delimiter(')content(lambda)delimiter(')>operator(,) string<delimiter(')content(not)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(pass)delimiter(')>operator(,) string<delimiter(')content(raise)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,) string<delimiter(')content(try)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(with)delimiter(')>operator(,) string<delimiter(')content(yield)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(nonlocal)delimiter(')>operator(,)  comment(# new in Python 3)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(OLD_KEYWORDS) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(exec)delimiter(')>operator(,) string<delimiter(')content(print)delimiter(')>operator(,)  comment(# gone in Python 3)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_METHODS_AND_TYPES) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      __import__ abs all any apply basestring bin bool buffer)>]
insert[insert(+)string<content(      bytearray bytes callable chr classmethod cmp coerce compile)>]
insert[insert(+)string<content(      complex delattr dict dir divmod enumerate eval execfile exit)>]
insert[insert(+)string<content(      file filter float frozenset getattr globals hasattr hash hex id)>]
insert[insert(+)string<content(      input int intern isinstance issubclass iter len list locals)>]
insert[insert(+)string<content(      long map max min next object oct open ord pow property range)>]
insert[insert(+)string<content(      raw_input reduce reload repr reversed round set setattr slice)>]
insert[insert(+)string<content(      sorted staticmethod str sum super tuple type unichr unicode)>]
insert[insert(+)string<content(      vars xrange zip)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_EXCEPTIONS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      ArithmeticError AssertionError AttributeError)>]
insert[insert(+)string<content(      BaseException DeprecationWarning EOFError EnvironmentError)>]
insert[insert(+)string<content(      Exception FloatingPointError FutureWarning GeneratorExit IOError)>]
insert[insert(+)string<content(      ImportError ImportWarning IndentationError IndexError KeyError)>]
insert[insert(+)string<content(      KeyboardInterrupt LookupError MemoryError NameError)>]
insert[insert(+)string<content(      NotImplemented NotImplementedError OSError OverflowError)>]
insert[insert(+)string<content(      OverflowWarning PendingDeprecationWarning ReferenceError)>]
insert[insert(+)string<content(      RuntimeError RuntimeWarning StandardError StopIteration)>]
insert[insert(+)string<content(      SyntaxError SyntaxWarning SystemError SystemExit TabError)>]
insert[insert(+)string<content(      TypeError UnboundLocalError UnicodeDecodeError)>]
insert[insert(+)string<content(      UnicodeEncodeError UnicodeError UnicodeTranslateError)>]
insert[insert(+)string<content(      UnicodeWarning UserWarning ValueError Warning ZeroDivisionError)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_VARIABLES_AND_CONSTANTS) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(False)delimiter(')>operator(,) string<delimiter(')content(True)delimiter(')>operator(,) string<delimiter(')content(None)delimiter(')>operator(,)  comment(# "keywords" since Python 3)]
insert[insert(+)      string<delimiter(')content(self)delimiter(')>operator(,) string<delimiter(')content(Ellipsis)delimiter(')>operator(,) string<delimiter(')content(NotImplemented)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(KEYWORDS)operator(,) symbol(:keyword)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(OLD_KEYWORDS)operator(,) symbol(:old_keyword)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_METHODS_AND_TYPES)operator(,) symbol(:predefined)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_VARIABLES_AND_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_EXCEPTIONS)operator(,) symbol(:exception)operator(\))  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(NAME) operator(=) regexp<delimiter(/)content( [^)char(\\W)char(\\d)content(] )char(\\w)content(* )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [abfnrtv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} | N)char(\\{)content([-)char(\\w)content( ]+)char(\\})content( )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(OPERATOR) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(      )char(\\.)char(\\.)char(\\.)content( |          # ellipsis)>]
insert[insert(+)regexp<content(      )char(\\.)content((?!)char(\\d)content(\) |        # dot but not decimal point)>]
insert[insert(+)regexp<content(      [,;:(\))char(\\[)char(\\])content({}] |   # simple delimiters)>]
insert[insert(+)regexp<content(      )char(\\/)char(\\/)content(=? | )char(\\*)char(\\*)content(=? | # special math)>]
insert[insert(+)regexp<content(      [-+*)char(\\/)content(%&|^]=? |   # ordinary math and binary logic)>]
insert[insert(+)regexp<content(      [~`] |            # binary complement and inspection)>]
insert[insert(+)regexp<content(      <<=? | >>=? | [<>=]=? | !=  # comparison and assignment)>]
insert[insert(+)regexp<content(    )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(STRING_DELIMITER_REGEXP) operator(=) constant(Hash)operator(.)ident(new) operator({) operator(|)ident(h)operator(,) ident(delimiter)operator(|)]
insert[insert(+)      ident(h)operator([)ident(delimiter)operator(]) operator(=) constant(Regexp)operator(.)ident(union) ident(delimiter)  comment(# :nodoc:)]
insert[insert(+)    operator(})]
insert[insert(+)    ]
insert[insert(+)    constant(STRING_CONTENT_REGEXP) operator(=) constant(Hash)operator(.)ident(new) operator({) operator(|)ident(h)operator(,) ident(delimiter)operator(|)]
insert[insert(+)      ident(h)operator([)ident(delimiter)operator(]) operator(=) regexp<delimiter(/)content( [^)char(\\\\)char(\\n)content(]+? (?= )char(\\\\)content( | $ | )inline<inline_delimiter(#{)constant(Regexp)operator(.)ident(escape)operator(()ident(delimiter)operator(\))inline_delimiter(})>content( \) )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    operator(})]
insert[insert(+)    ]
insert[insert(+)    constant(DEF_NEW_STATE) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:initial)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()string<delimiter(%w()content(def)delimiter(\))>operator(,) symbol(:def_expected)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()string<delimiter(%w()content(import from)delimiter(\))>operator(,) symbol(:include_expected)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()string<delimiter(%w()content(class)delimiter(\))>operator(,) symbol(:class_expected)operator(\))  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(DESCRIPTOR) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(      )inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>>]
insert[insert(+)regexp<content(      (?: )char(\\.)content( )inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>content( \)*)>]
insert[insert(+)regexp<content(      | )char(\\*)>]
insert[insert(+)regexp<content(    )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(string_raw) operator(=) predefined_constant(false)]
insert[insert(+)      ident(import_clause) operator(=) ident(class_name_follows) operator(=) ident(last_token_dot) operator(=) predefined_constant(false)]
insert[insert(+)      ident(unicode) operator(=) ident(string)operator(.)ident(respond_to?)operator(()symbol(:encoding)operator(\)) operator(&&) ident(string)operator(.)ident(encoding)operator(.)ident(name) operator(==) string<delimiter(')content(UTF-8)delimiter(')>]
insert[insert(+)      ident(from_import_state) operator(=) operator([)operator(])]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) ident(state) operator(==) symbol(:string)]
insert[insert(+)          keyword(if) ident(scan)operator(()constant(STRING_DELIMITER_REGEXP)operator([)ident(string_delimiter)operator(])operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(string_delimiter)operator(.)ident(size) operator(==) integer(3) operator(&&) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()constant(STRING_CONTENT_REGEXP)operator([)ident(string_delimiter)operator(])operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) operator(!)ident(string_raw) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( . )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)operator(,) ident(state)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [ )char(\\t)content(]+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)          keyword(next)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)          ident(state) operator(=) symbol(:initial) keyword(if) ident(state) operator(==) symbol(:include_expected)]
insert[insert(+)          keyword(next)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\#)content( [^)char(\\n)content(]* )delimiter(/)modifier(mx)>operator(\))]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:comment)operator(])]
insert[insert(+)          keyword(next)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:initial)]
insert[insert(+)          ]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(OPERATOR)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content((u?r?|b\)?("""|"|'''|'\))delimiter(/)modifier(i)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) predefined_constant(self)operator([)integer(2)operator(])]
insert[insert(+)            ident(string_raw) operator(=) predefined_constant(false)]
insert[insert(+)            ident(modifiers) operator(=) predefined_constant(self)operator([)integer(1)operator(])]
insert[insert(+)            keyword(unless) ident(modifiers)operator(.)ident(empty?)]
insert[insert(+)              ident(string_raw) operator(=) operator(!)operator(!)ident(modifiers)operator(.)ident(index)operator(()integer(?r)operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(modifiers)operator(,) symbol(:modifier)operator(])]
insert[insert(+)              ident(match) operator(=) ident(string_delimiter)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(state) operator(=) symbol(:string)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)          ]
insert[insert(+)          comment(# TODO: backticks)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(uo)> operator(:) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            comment(# TODO: keyword arguments)]
insert[insert(+)            ident(kind) operator(=) symbol(:ident) keyword(if) ident(last_token_dot)]
insert[insert(+)            keyword(if) ident(kind) operator(==) symbol(:old_keyword)]
insert[insert(+)              ident(kind) operator(=) ident(check)operator(()regexp<delimiter(/)char(\\()delimiter(/)>operator(\)) operator(?) symbol(:ident) operator(:) symbol(:keyword)]
insert[insert(+)            keyword(elsif) ident(kind) operator(==) symbol(:predefined) operator(&&) ident(check)operator(()regexp<delimiter(/)content( *=)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:ident)]
insert[insert(+)            keyword(elsif) ident(kind) operator(==) symbol(:keyword)]
insert[insert(+)              ident(state) operator(=) constant(DEF_NEW_STATE)operator([)ident(match)operator(])]
insert[insert(+)              ident(from_import_state) operator(<<) ident(match)operator(.)ident(to_sym) keyword(if) ident(state) operator(==) symbol(:include_expected)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(@[a-zA-Z0-9_.]+[lL]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:decorator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+[lL]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:hex)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[bB][01]+[lL]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:bin)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\d)content(*)char(\\.)char(\\d)content(+|)char(\\d)content(+)char(\\.)char(\\d)content(*\)(?:[eE][+-]?)char(\\d)content(+\)?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:float)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content([jJ])delimiter(/)>operator(\))]
insert[insert(+)              ident(match) operator(<<) ident(matched)]
insert[insert(+)              ident(kind) operator(=) symbol(:imaginary)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[oO][0-7]+|0[0-7]+(?![89.eE]\)[lL]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:oct)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+([lL]\)?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(if) predefined_constant(self)operator([)integer(1)operator(]) operator(==) predefined_constant(nil) operator(&&) ident(scan)operator(()regexp<delimiter(/)content([jJ])delimiter(/)>operator(\))]
insert[insert(+)              ident(match) operator(<<) ident(matched)]
insert[insert(+)              ident(kind) operator(=) symbol(:imaginary)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          ]
insert[insert(+)          keyword(end)]
insert[insert(+)            ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:def_expected)]
insert[insert(+)          ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(uo)> operator(:) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:method)]
insert[insert(+)          keyword(else)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:class_expected)]
insert[insert(+)          ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(uo)> operator(:) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NAME)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:class)]
insert[insert(+)          keyword(else)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:include_expected)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()ident(unicode) operator(?) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DESCRIPTOR)inline_delimiter(})>delimiter(/)modifier(uo)> operator(:) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DESCRIPTOR)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:include)]
insert[insert(+)            keyword(if) ident(match) operator(==) string<delimiter(')content(as)delimiter(')>]
insert[insert(+)              ident(kind) operator(=) symbol(:keyword)]
insert[insert(+)              ident(from_import_state) operator(<<) symbol(:as)]
insert[insert(+)            keyword(elsif) ident(from_import_state)operator(.)ident(first) operator(==) symbol(:from) operator(&&) ident(match) operator(==) string<delimiter(')content(import)delimiter(')>]
insert[insert(+)              ident(kind) operator(=) symbol(:keyword)]
insert[insert(+)              ident(from_import_state) operator(<<) symbol(:import)]
insert[insert(+)            keyword(elsif) ident(from_import_state)operator(.)ident(last) operator(==) symbol(:as)]
insert[insert(+)              comment(# kind = match[0,1][unicode ? /[[:upper:]]/u : /[[:upper:]]/] ? :class : :method)]
insert[insert(+)              ident(kind) operator(=) symbol(:ident)]
insert[insert(+)              ident(from_import_state)operator(.)ident(pop)]
insert[insert(+)            keyword(elsif) constant(IDENT_KIND)operator([)ident(match)operator(]) operator(==) symbol(:keyword)]
insert[insert(+)              ident(unscan)]
insert[insert(+)              ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)              ident(state) operator(=) symbol(:initial)]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(,)delimiter(/)>operator(\))]
insert[insert(+)            ident(from_import_state)operator(.)ident(pop) keyword(if) ident(from_import_state)operator(.)ident(last) operator(==) symbol(:as)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(from_import_state) operator(=) operator([)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)operator(,) ident(state)]
insert[insert(+)          ]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens)operator(,) ident(state) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(last_token_dot) operator(=) ident(match) operator(==) string<delimiter(')content(.)delimiter(')>]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      keyword(if) ident(state) operator(==) symbol(:string)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/java.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/java.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/java.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,179 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for Java.)]
insert[insert(+)  keyword(class) class(Java) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ident(register_for) symbol(:java)]
insert[insert(+)    ident(helper) symbol(:builtin_types)]
insert[insert(+)    ]
insert[insert(+)    comment(# http://java.sun.com/docs/books/tutorial/java/nutsandbolts/_keywords.html)]
insert[insert(+)    constant(KEYWORDS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      assert break case catch continue default do else)>]
insert[insert(+)string<content(      finally for if instanceof import new package)>]
insert[insert(+)string<content(      return switch throw try typeof while)>]
insert[insert(+)string<content(      debugger export)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(RESERVED) operator(=) string<delimiter(%w[)content( const goto )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(CONSTANTS) operator(=) string<delimiter(%w[)content( false null true )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(MAGIC_VARIABLES) operator(=) string<delimiter(%w[)content( this super )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(TYPES) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      boolean byte char class double enum float int interface long)>]
insert[insert(+)string<content(      short void)>]
insert[insert(+)string<content(    )delimiter(])> operator(<<) string<delimiter(')content([])delimiter(')>  comment(# :nodoc: because int[] should be highlighted as a type)]
insert[insert(+)    constant(DIRECTIVES) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      abstract extends final implements native private protected public)>]
insert[insert(+)string<content(      static strictfp synchronized throws transient volatile)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(KEYWORDS)operator(,) symbol(:keyword)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(RESERVED)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(CONSTANTS)operator(,) symbol(:pre_constant)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(MAGIC_VARIABLES)operator(,) symbol(:local_variable)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(TYPES)operator(,) symbol(:type)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(BuiltinTypes)operator(::)constant(List)operator(,) symbol(:pre_type)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(BuiltinTypes)operator(::)constant(List)operator(.)ident(select) operator({) operator(|)ident(builtin)operator(|) ident(builtin)operator([)regexp<delimiter(/)content((Error|Exception\)$)delimiter(/)>operator(]) operator(})operator(,) symbol(:exception)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))  comment(# :nodoc:)]
insert[insert(+)]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [bfnrtv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(STRING_CONTENT_PATTERN) operator(=) operator({)]
insert[insert(+)      string<delimiter(")content(')delimiter(")> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content(']+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(")delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content("]+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(/)delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)char(\\/)content(]+)delimiter(/)>operator(,)]
insert[insert(+)    operator(})  comment(# :nodoc:)]
insert[insert(+)    constant(IDENT) operator(=) regexp<delimiter(/)content([a-zA-Z_][A-Za-z_0-9]*)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(import_clause) operator(=) ident(class_name_follows) operator(=) ident(last_token_dot) operator(=) predefined_constant(false)]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)char(\\\\)content(]* (?: )char(\\\\)content(. [^)char(\\n)char(\\\\)content(]* \)* | /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:comment)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(import_clause) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( (?: )char(\\.)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( \)* )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:include)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( | )char(\\[)char(\\])content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            keyword(if) ident(last_token_dot)]
insert[insert(+)              ident(kind) operator(=) symbol(:ident)]
insert[insert(+)            keyword(elsif) ident(class_name_follows)]
insert[insert(+)              ident(kind) operator(=) symbol(:class)]
insert[insert(+)              ident(class_name_follows) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(import_clause) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(import)delimiter(')>]
insert[insert(+)              ident(class_name_follows) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(class)delimiter(')> operator(||) ident(match) operator(==) string<delimiter(')content(interface)delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\.)content((?!)char(\\d)content(\) | [,?:(\))char(\\[)char(\\])content(}] | -- | )char(\\+)char(\\+)content( | && | )char(\\|)char(\\|)content( | )char(\\*)char(\\*)content(=? | [-+*)char(\\/)content(%^~&|<>=!]=? | <<<?=? | >>>?=? )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(;)delimiter(/)>operator(\))]
insert[insert(+)            ident(import_clause) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)            ident(class_name_follows) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(check)operator(()regexp<delimiter(/)content([)char(\\d)content(.])delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:hex)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?>0[0-7]+\)(?![89.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:oct)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+[fFdD]|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?[fFdD]?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+[fFdD]?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:float)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+[lL]?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["'])delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:string)]
insert[insert(+)            ident(string_delimiter) operator(=) ident(match)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( @ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:annotation)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:string)]
insert[insert(+)          keyword(if) ident(scan)operator(()constant(STRING_CONTENT_PATTERN)operator([)ident(string_delimiter)operator(])operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["')char(\\/)content(])delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(state) operator(==) symbol(:string) operator(&&) operator(()ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))operator(\))]
insert[insert(+)            keyword(if) ident(string_delimiter) operator(==) string<delimiter(")content(')delimiter(")> operator(&&) operator(!)operator(()ident(match) operator(==) string<delimiter(")char(\\\\)char(\\\\)delimiter(")> operator(||) ident(match) operator(==) string<delimiter(")char(\\\\)content(')delimiter(")>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(kind) operator(=) symbol(:char)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)]
insert[insert(+)        keyword(end)]
insert[insert(+)]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(last_token_dot) operator(=) ident(match) operator(==) string<delimiter(')content(.)delimiter(')>]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(if) ident(state) operator(==) symbol(:string)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/c.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/c.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/c.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,44 +1,55 )change(@@)]
 keyword(module) class(CodeRay)
 keyword(module) class(Scanners)
delete[delete(-)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for C.)]
   keyword(class) class(C) operator(<) constant(Scanner)
 
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ]
     ident(register_for) symbol(:c)
insert[insert(+)    ident(file_extension) string<delimiter(')content(c)delimiter(')>]
     
delete[delete(-)    ident(include) constant(Streamable)]
delete[delete(-)]
     constant(RESERVED_WORDS) operator(=) operator([)
delete[delete(-)      string<delimiter(')content(asm)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(continue)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,)]
delete[delete(-)      string<delimiter(')content(for)delimiter(')>operator(,) string<delimiter(')content(goto)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,) string<delimiter(')content(switch)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,)]
delete[delete(-)      string<delimiter(')content(struct)delimiter(')>operator(,) string<delimiter(')content(union)delimiter(')>operator(,) string<delimiter(')content(enum)delimiter(')>operator(,) string<delimiter(')content(typedef)delimiter(')>operator(,)]
delete[delete(-)      string<delimiter(')content(static)delimiter(')>operator(,) string<delimiter(')content(register)delimiter(')>operator(,) string<delimiter(')content(auto)delimiter(')>operator(,) string<delimiter(')content(extern)delimiter(')>operator(,)]
delete[delete(-)      string<delimiter(')content(sizeof)delimiter(')>operator(,)]
delete[delete(-)      string<delimiter(')content(volatile)delimiter(')>operator(,) string<delimiter(')content(const)delimiter(')>operator(,)  comment(# C89)]
delete[delete(-)      string<delimiter(')content(inline)delimiter(')>operator(,) string<delimiter(')content(restrict)delimiter(')>operator(,) comment(# C99)]
delete[delete(-)    operator(])]
insert[insert(+)      string<delimiter(')content(asm)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(continue)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(else)delimiter(')>operator(,) string<delimiter(')content(enum)delimiter(')>operator(,) string<delimiter(')content(for)delimiter(')>operator(,) string<delimiter(')content(goto)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(sizeof)delimiter(')>operator(,) string<delimiter(')content(struct)delimiter(')>operator(,) string<delimiter(')content(switch)delimiter(')>operator(,) string<delimiter(')content(typedef)delimiter(')>operator(,) string<delimiter(')content(union)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(restrict)delimiter(')>operator(,)  comment(# added in C99)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
 
     constant(PREDEFINED_TYPES) operator(=) operator([)
delete[delete(-)      string<delimiter(')content(int)delimiter(')>operator(,) string<delimiter(')content(long)delimiter(')>operator(,) string<delimiter(')content(short)delimiter(')>operator(,) string<delimiter(')content(char)delimiter(')>operator(,)eyecatcher< string<delimiter(')content(void)delimiter(')>operator(,)>]
insert[insert(+)      string<delimiter(')content(int)delimiter(')>operator(,) string<delimiter(')content(long)delimiter(')>operator(,) string<delimiter(')content(short)delimiter(')>operator(,) string<delimiter(')content(char)delimiter(')>operator(,)]
       string<delimiter(')content(signed)delimiter(')>operator(,) string<delimiter(')content(unsigned)delimiter(')>operator(,) string<delimiter(')content(float)delimiter(')>operator(,) string<delimiter(')content(double)delimiter(')>operator(,)
delete[delete(-)      string<delimiter(')content(bool)delimiter(')>operator(,) string<delimiter(')content(complex)delimiter(')>operator(,)  comment(# )comment(C99)]
delete[delete(-)    operator(])]
insert[insert(+)      string<delimiter(')content(bool)delimiter(')>operator(,) string<delimiter(')content(complex)delimiter(')>operator(,)  comment(# )eyecatcher<comment(added in )>comment(C99)]
insert[insert(+)    operator(])eyecatcher<  comment(# :nodoc:)>]
 
     constant(PREDEFINED_CONSTANTS) operator(=) operator([)
       string<delimiter(')content(EOF)delimiter(')>operator(,) string<delimiter(')content(NULL)delimiter(')>operator(,)
delete[delete(-)      string<delimiter(')content(true)delimiter(')>operator(,) string<delimiter(')content(false)delimiter(')>operator(,)  comment(# C99)]
delete[delete(-)    operator(])]
insert[insert(+)      string<delimiter(')content(true)delimiter(')>operator(,) string<delimiter(')content(false)delimiter(')>operator(,)  comment(# added in C99)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    constant(DIRECTIVES) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(auto)delimiter(')>operator(,) string<delimiter(')content(extern)delimiter(')>operator(,) string<delimiter(')content(register)delimiter(')>operator(,) string<delimiter(')content(static)delimiter(')>operator(,) string<delimiter(')content(void)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(const)delimiter(')>operator(,) string<delimiter(')content(volatile)delimiter(')>operator(,)  comment(# added in C89)]
insert[insert(+)      string<delimiter(')content(inline)delimiter(')>operator(,)  comment(# added in C99)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
 
     constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)
       ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
       ident(add)operator(()constant(PREDEFINED_TYPES)operator(,) symbol(:pre_type)operator(\))operator(.)
delete[delete(-)      ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))]
insert[insert(+)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))  comment(# :nodoc:)]
 
delete[delete(-)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [rbfnrtv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>]
delete[delete(-)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>]
delete[delete(-)]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [rbfntv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
 
       ident(state) operator(=) symbol(:initial)
insert[insert(+)      ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)      ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)      ident(label_expected_before_preproc_line) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(in_preproc_line) operator(=) predefined_constant(false)]
 
       keyword(until) ident(eos?)
 
change[change(@@)plain( -49,8 +60,13 )change(@@)]
 
         keyword(when) symbol(:initial)
 
delete[delete(-)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
delete[delete(-)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            keyword(if) ident(in_preproc_line) operator(&&) ident(match) operator(!=) string<delimiter(")char(\\\\)char(\\n)delimiter(")> operator(&&) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))]
insert[insert(+)              ident(in_preproc_line) operator(=) predefined_constant(false)]
insert[insert(+)              ident(label_expected) operator(=) ident(label_expected_before_preproc_line)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
 
           keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)char(\\\\)content(]* (?: )char(\\\\)content(. [^)char(\\n)char(\\\\)content(]* \)* | /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>operator(\))
             ident(kind) operator(=) symbol(:comment)
change[change(@@)plain( -59,16 +75,32 )change(@@)]
             ident(match) operator(<<) ident(scan_until)operator(()regexp<delimiter(/)content( ^)char(\\#)content( (?:elif|else|endif\) .*? $ | )char(\\z)content( )delimiter(/)modifier(xm)>operator(\)) keyword(unless) ident(eos?)
             ident(kind) operator(=) symbol(:comment)
 
delete[delete(-)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( [-+*)char(\\/)content(=<>?:;,!&^|(\))char(\\[)char(\\])content({}~%]+ | )char(\\.)content((?!)char(\\d)content(\) )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [-+*=<>?:;,!&^|(\))char(\\[)char(\\])content({}~%]+ | )char(\\/)content(=? | )char(\\.)content((?!)char(\\d)content(\) )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) ident(match) operator(=)operator(~) regexp<delimiter(/)content([;)char(\\{)char(\\})content(])delimiter(/)>]
insert[insert(+)            keyword(if) ident(case_expected)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(:)delimiter(')>]
insert[insert(+)              ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(end)]
             ident(kind) operator(=) symbol(:operator)
 
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [A-Za-z_][A-Za-z_0-9]* )delimiter(/)modifier(x)>operator(\))
             ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])
delete[delete(-)            keyword(if) ident(kind) operator(==) symbol(:ident) keyword(and) ident(check)operator(()regexp<delimiter(/)content(:(?!:\))delimiter(/)>operator(\))]
delete[delete(-)              ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)content(:)delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(kind) operator(==) symbol(:ident) operator(&&) ident(label_expected) operator(&&) operator(!)ident(in_preproc_line) operator(&&) ident(scan)operator(()regexp<delimiter(/)content(:(?!:\))delimiter(/)>operator(\))]
               ident(kind) operator(=) symbol(:label)
insert[insert(+)              ident(match) operator(<<) ident(matched)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)              keyword(if) ident(kind) operator(==) symbol(:reserved)]
insert[insert(+)                keyword(case) ident(match)]
insert[insert(+)                keyword(when) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>]
insert[insert(+)                  ident(case_expected) operator(=) predefined_constant(true)]
insert[insert(+)                keyword(end)]
insert[insert(+)              keyword(end)]
             keyword(end)
 
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\$)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:ident)]
insert[insert(+)          ]
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(L?")delimiter(/)>operator(\))
             ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])
             keyword(if) ident(match)operator([)integer(0)operator(]) operator(==) integer(?L)
change[change(@@)plain( -78,23 +110,30 )change(@@)]
             ident(state) operator(=) symbol(:string)
             ident(kind) operator(=) symbol(:delimiter)
 
delete[delete(-)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#)char(\\s)content(*()char(\\w)content(*\))delimiter(/)>operator(\))]
delete[delete(-)            ident(kind) operator(=) symbol(:preprocessor)  comment(# FIXME multiline preprocs)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#[ )char(\\t)content(]*()char(\\w)content(*\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:preprocessor)]
insert[insert(+)            ident(in_preproc_line) operator(=) predefined_constant(true)]
insert[insert(+)            ident(label_expected_before_preproc_line) operator(=) ident(label_expected)]
             ident(state) operator(=) symbol(:include_expected) keyword(if) predefined_constant(self)operator([)integer(1)operator(]) operator(==) string<delimiter(')content(include)delimiter(')>
 
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( L?' (?: [^)char(\\')char(\\n)char(\\\\)content(] | )char(\\\\)content( )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( \)? '? )delimiter(/)modifier(ox)>operator(\))
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             ident(kind) operator(=) symbol(:char)
 
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             ident(kind) operator(=) symbol(:hex)
 
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:0[0-7]+\)(?![89.eEfF]\))delimiter(/)>operator(\))
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             ident(kind) operator(=) symbol(:oct)
 
delete[delete(-)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\d)content(+\)(?![.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\d)content(+\)(?![.eEfF]\)L?L?)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             ident(kind) operator(=) symbol(:integer)
 
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content([fF]?|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?[fF]?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+[fF]?)delimiter(/)>operator(\))
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             ident(kind) operator(=) symbol(:float)
 
           keyword(else)
change[change(@@)plain( -110,6 +149,7 )change(@@)]
             ident(tokens) operator(<<) operator([)string<delimiter(')content(")delimiter(')>operator(,) symbol(:delimiter)operator(])
             ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])
             ident(state) operator(=) symbol(:initial)
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
             keyword(next)
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))
             ident(kind) operator(=) symbol(:char)
change[change(@@)plain( -117,6 +157,7 )change(@@)]
             ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])
             ident(kind) operator(=) symbol(:error)
             ident(state) operator(=) symbol(:initial)
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
           keyword(else)
             ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)
           keyword(end)
change[change(@@)plain( -131,8 +172,8 )change(@@)]
             ident(state) operator(=) symbol(:initial) keyword(if) ident(match)operator(.)ident(index) integer(?\\n)
 
           keyword(else)
delete[delete(-)            eyecatcher<ident(getch)>]
delete[delete(-)            eyecatcher<ident(kind) operator(=) symbol(:error)>]
insert[insert(+)            eyecatcher<ident(state) operator(=) symbol(:initial)>]
insert[insert(+)            eyecatcher<keyword(next)>]
 
           keyword(end)
 
change[change(@@)plain( -142,7 +183,7 )change(@@)]
         keyword(end)
 
         ident(match) operator(||=) ident(matched)
delete[delete(-)        keyword(if) global_variable($)global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)        keyword(if) global_variable($)eyecatcher<global_variable(CODERAY_)>global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
           ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
             operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)
         keyword(end)
head[head(Index: )plain(lib/coderay/scanners/cpp.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/cpp.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/cpp.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,233 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)]
insert[insert(+)  comment(# Scanner for C++.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Aliases: +cplusplus+, c++)]
insert[insert(+)  keyword(class) class(CPlusPlus) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:cpp)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(cpp)delimiter(')>]
insert[insert(+)    ident(title) string<delimiter(')content(C++)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    comment(#-- http://www.cppreference.com/wiki/keywords/start)]
insert[insert(+)    constant(RESERVED_WORDS) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(and_eq)delimiter(')>operator(,) string<delimiter(')content(asm)delimiter(')>operator(,) string<delimiter(')content(bitand)delimiter(')>operator(,) string<delimiter(')content(bitor)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(catch)delimiter(')>operator(,) string<delimiter(')content(class)delimiter(')>operator(,) string<delimiter(')content(compl)delimiter(')>operator(,) string<delimiter(')content(const_cast)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(continue)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>operator(,) string<delimiter(')content(delete)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,) string<delimiter(')content(dynamic_cast)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(enum)delimiter(')>operator(,) string<delimiter(')content(export)delimiter(')>operator(,) string<delimiter(')content(for)delimiter(')>operator(,) string<delimiter(')content(goto)delimiter(')>operator(,) string<delimiter(')content(if)delimiter(')>operator(,) string<delimiter(')content(namespace)delimiter(')>operator(,) string<delimiter(')content(new)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(not)delimiter(')>operator(,) string<delimiter(')content(not_eq)delimiter(')>operator(,) string<delimiter(')content(or)delimiter(')>operator(,) string<delimiter(')content(or_eq)delimiter(')>operator(,) string<delimiter(')content(reinterpret_cast)delimiter(')>operator(,) string<delimiter(')content(return)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(sizeof)delimiter(')>operator(,) string<delimiter(')content(static_cast)delimiter(')>operator(,) string<delimiter(')content(struct)delimiter(')>operator(,) string<delimiter(')content(switch)delimiter(')>operator(,) string<delimiter(')content(template)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(throw)delimiter(')>operator(,) string<delimiter(')content(try)delimiter(')>operator(,) string<delimiter(')content(typedef)delimiter(')>operator(,) string<delimiter(')content(typeid)delimiter(')>operator(,) string<delimiter(')content(typename)delimiter(')>operator(,) string<delimiter(')content(union)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(xor)delimiter(')>operator(,) string<delimiter(')content(xor_eq)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_TYPES) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(bool)delimiter(')>operator(,) string<delimiter(')content(char)delimiter(')>operator(,) string<delimiter(')content(double)delimiter(')>operator(,) string<delimiter(')content(float)delimiter(')>operator(,) string<delimiter(')content(int)delimiter(')>operator(,) string<delimiter(')content(long)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(short)delimiter(')>operator(,) string<delimiter(')content(signed)delimiter(')>operator(,) string<delimiter(')content(unsigned)delimiter(')>operator(,) string<delimiter(')content(wchar_t)delimiter(')>operator(,) string<delimiter(')content(string)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    constant(PREDEFINED_CONSTANTS) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(false)delimiter(')>operator(,) string<delimiter(')content(true)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(EOF)delimiter(')>operator(,) string<delimiter(')content(NULL)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    constant(PREDEFINED_VARIABLES) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(this)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    constant(DIRECTIVES) operator(=) operator([)]
insert[insert(+)      string<delimiter(')content(auto)delimiter(')>operator(,) string<delimiter(')content(const)delimiter(')>operator(,) string<delimiter(')content(explicit)delimiter(')>operator(,) string<delimiter(')content(extern)delimiter(')>operator(,) string<delimiter(')content(friend)delimiter(')>operator(,) string<delimiter(')content(inline)delimiter(')>operator(,) string<delimiter(')content(mutable)delimiter(')>operator(,) string<delimiter(')content(operator)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(private)delimiter(')>operator(,) string<delimiter(')content(protected)delimiter(')>operator(,) string<delimiter(')content(public)delimiter(')>operator(,) string<delimiter(')content(register)delimiter(')>operator(,) string<delimiter(')content(static)delimiter(')>operator(,) string<delimiter(')content(using)delimiter(')>operator(,) string<delimiter(')content(virtual)delimiter(')>operator(,) string<delimiter(')content(void)delimiter(')>operator(,)]
insert[insert(+)      string<delimiter(')content(volatile)delimiter(')>operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_TYPES)operator(,) symbol(:pre_type)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_VARIABLES)operator(,) symbol(:local_variable)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))  comment(# :nodoc:)]
insert[insert(+)]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [rbfntv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)      ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)      ident(label_expected_before_preproc_line) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(in_preproc_line) operator(=) predefined_constant(false)]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            keyword(if) ident(in_preproc_line) operator(&&) ident(match) operator(!=) string<delimiter(")char(\\\\)char(\\n)delimiter(")> operator(&&) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))]
insert[insert(+)              ident(in_preproc_line) operator(=) predefined_constant(false)]
insert[insert(+)              ident(label_expected) operator(=) ident(label_expected_before_preproc_line)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)char(\\\\)content(]* (?: )char(\\\\)content(. [^)char(\\n)char(\\\\)content(]* \)* | /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\#)content( )char(\\s)content(* if )char(\\s)content(* 0 )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(match) operator(<<) ident(scan_until)operator(()regexp<delimiter(/)content( ^)char(\\#)content( (?:elif|else|endif\) .*? $ | )char(\\z)content( )delimiter(/)modifier(xm)>operator(\)) keyword(unless) ident(eos?)]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [-+*=<>?:;,!&^|(\))char(\\[)char(\\])content({}~%]+ | )char(\\/)content(=? | )char(\\.)content((?!)char(\\d)content(\) )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) ident(match) operator(=)operator(~) regexp<delimiter(/)content([;)char(\\{)char(\\})content(])delimiter(/)>]
insert[insert(+)            keyword(if) ident(case_expected)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(:)delimiter(')>]
insert[insert(+)              ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [A-Za-z_][A-Za-z_0-9]* )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            keyword(if) ident(kind) operator(==) symbol(:ident) operator(&&) ident(label_expected) operator(&&) operator(!)ident(in_preproc_line) operator(&&) ident(scan)operator(()regexp<delimiter(/)content(:(?!:\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:label)]
insert[insert(+)              ident(match) operator(<<) ident(matched)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)              keyword(if) ident(kind) operator(==) symbol(:reserved)]
insert[insert(+)                keyword(case) ident(match)]
insert[insert(+)                keyword(when) string<delimiter(')content(class)delimiter(')>]
insert[insert(+)                  ident(state) operator(=) symbol(:class_name_expected)]
insert[insert(+)                keyword(when) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>]
insert[insert(+)                  ident(case_expected) operator(=) predefined_constant(true)]
insert[insert(+)                keyword(end)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\$)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:ident)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(L?")delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            keyword(if) ident(match)operator([)integer(0)operator(]) operator(==) integer(?L)]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(L)delimiter(')>operator(,) symbol(:modifier)operator(])]
insert[insert(+)              ident(match) operator(=) string<delimiter(')content(")delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(state) operator(=) symbol(:string)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#[ )char(\\t)content(]*()char(\\w)content(*\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:preprocessor)]
insert[insert(+)            ident(in_preproc_line) operator(=) predefined_constant(true)]
insert[insert(+)            ident(label_expected_before_preproc_line) operator(=) ident(label_expected)]
insert[insert(+)            ident(state) operator(=) symbol(:include_expected) keyword(if) predefined_constant(self)operator([)integer(1)operator(]) operator(==) string<delimiter(')content(include)delimiter(')>]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( L?' (?: [^)char(\\')char(\\n)char(\\\\)content(] | )char(\\\\)content( )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( \)? '? )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:hex)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:0[0-7]+\)(?![89.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:oct)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\d)content(+\)(?![.eEfF]\)L?L?)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:integer)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content([fF]?|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?[fF]?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+[fF]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:float)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:string)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content([^)char(\\\\)content("]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)string<delimiter(')content(")delimiter(')>operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:include_expected)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content(<[^>)char(\\n)content(]+>?|"[^")char(\\n)char(\\\\)content(]*(?:)char(\\\\)content(.[^")char(\\n)char(\\\\)content(]*\)*"?)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:include)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)            ident(state) operator(=) symbol(:initial) keyword(if) ident(match)operator(.)ident(index) integer(?\\n)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:class_name_expected)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content( [A-Za-z_][A-Za-z_0-9]* )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:class)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)]
insert[insert(+)        keyword(end)]
insert[insert(+)]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(if) ident(state) operator(==) symbol(:string)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/groovy.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/groovy.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/groovy.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,267 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)]
insert[insert(+)  ident(load) symbol(:java)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for Groovy.)]
insert[insert(+)  keyword(class) class(Groovy) operator(<) constant(Java)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ident(register_for) symbol(:groovy)]
insert[insert(+)    ]
insert[insert(+)    comment(# TODO: check list of keywords)]
insert[insert(+)    constant(GROOVY_KEYWORDS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      as assert def in)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(KEYWORDS_EXPECTING_VALUE) operator(=) constant(WordList)operator(.)ident(new)operator(.)ident(add) string<delimiter(%w[)>]
insert[insert(+)string<content(      case instanceof new return throw typeof while as assert in)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(GROOVY_MAGIC_VARIABLES) operator(=) string<delimiter(%w[)content( it )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(Java)operator(::)constant(IDENT_KIND)operator(.)ident(dup)operator(.)]
insert[insert(+)      ident(add)operator(()constant(GROOVY_KEYWORDS)operator(,) symbol(:keyword)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(GROOVY_MAGIC_VARIABLES)operator(,) symbol(:local_variable)operator(\))  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [bfnrtv$)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} )delimiter(/)modifier(x)>  comment(# :nodoc: no 4-byte unicode chars? U[a-fA-F0-9]{8})]
insert[insert(+)    constant(REGEXP_ESCAPE) operator(=)  regexp<delimiter(/)content( [bfnrtv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} | )char(\\d)content( | [bBdDsSwW)char(\\/)content(] )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    comment(# TODO: interpretation inside ', ", /)]
insert[insert(+)    constant(STRING_CONTENT_PATTERN) operator(=) operator({)]
insert[insert(+)      string<delimiter(")content(')delimiter(")> operator(=)operator(>) regexp<delimiter(/)content((?>)char(\\\\)content([^)char(\\\\)content(')char(\\n)content(]+|[^)char(\\\\)content(')char(\\n)content(]+\)+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(")delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content($")char(\\n)content(]+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(")content(''')delimiter(")> operator(=)operator(>) regexp<delimiter(/)content((?>[^)char(\\\\)content(']+|'(?!''\)\)+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(""")delimiter(')> operator(=)operator(>) regexp<delimiter(/)content((?>[^)char(\\\\)content($"]+|"(?!""\)\)+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(/)delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content($)char(\\/)char(\\n)content(]+)delimiter(/)>operator(,)]
insert[insert(+)    operator(})  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(inline_block_stack) operator(=) operator([)operator(])]
insert[insert(+)      ident(inline_block_paren_depth) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(import_clause) operator(=) ident(class_name_follows) operator(=) ident(last_token) operator(=) ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)      ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(if) ident(match)operator(.)ident(index) integer(?\\n)]
insert[insert(+)              ident(import_clause) operator(=) ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)              ident(value_expected) operator(=) predefined_constant(true) keyword(unless) ident(value_expected)]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)char(\\\\)content(]* (?: )char(\\\\)content(. [^)char(\\n)char(\\\\)content(]* \)* | /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(bol?) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( )char(\\#)content(!.* )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:doctype)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(import_clause) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( (?!as\) )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( (?: )char(\\.)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( \)* (?: )char(\\.)char(\\*)content( \)? )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:include)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( | )char(\\[)char(\\])content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            ident(value_expected) operator(=) operator(()ident(kind) operator(==) symbol(:keyword)operator(\)) operator(&&) constant(KEYWORDS_EXPECTING_VALUE)operator([)ident(match)operator(])]
insert[insert(+)            keyword(if) ident(last_token) operator(==) string<delimiter(')content(.)delimiter(')>]
insert[insert(+)              ident(kind) operator(=) symbol(:ident)]
insert[insert(+)            keyword(elsif) ident(class_name_follows)]
insert[insert(+)              ident(kind) operator(=) symbol(:class)]
insert[insert(+)              ident(class_name_follows) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(elsif) ident(after_def) operator(&&) ident(check)operator(()regexp<delimiter(/)char(\\s)content(*[({])delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:method)]
insert[insert(+)              ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(elsif) ident(kind) operator(==) symbol(:ident) operator(&&) ident(last_token) operator(!=) string<delimiter(')content(?)delimiter(')> operator(&&) ident(check)operator(()regexp<delimiter(/)content(:)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:key)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(class_name_follows) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(class)delimiter(')> operator(||) operator(()ident(import_clause) operator(&&) ident(match) operator(==) string<delimiter(')content(as)delimiter(')>operator(\))]
insert[insert(+)              ident(import_clause) operator(=) ident(match) operator(==) string<delimiter(')content(import)delimiter(')>]
insert[insert(+)              ident(after_def) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(def)delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(;)delimiter(/)>operator(\))]
insert[insert(+)            ident(import_clause) operator(=) ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)            ident(class_name_follows) operator(=) ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            keyword(if) operator(!)ident(inline_block_stack)operator(.)ident(empty?)]
insert[insert(+)              ident(inline_block_paren_depth) operator(+=) integer(1)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          comment(# TODO: ~'...', ~"..." and ~/.../ style regexps)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\.)char(\\.)content(<? | )char(\\*)content(?)char(\\.)content((?!)char(\\d)content(\)@? | )char(\\.)content(& | )char(\\?)content(:? | [,?:()char(\\[)content(] | -[->] | )char(\\+)char(\\+)content( |)>]
insert[insert(+)regexp<content(              && | )char(\\|)char(\\|)content( | )char(\\*)char(\\*)content(=? | ==?~ | <=?>? | [-+*%^~&|>=!]=? | <<<?=? | >>>?=? )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(value_expected) operator(=) symbol(:regexp) keyword(if) ident(match) operator(==) string<delimiter(')content(~)delimiter(')>]
insert[insert(+)            ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [\))char(\\])content(}] )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(if) operator(!)ident(inline_block_stack)operator(.)ident(empty?) operator(&&) ident(match) operator(==) string<delimiter(')content(})delimiter(')>]
insert[insert(+)              ident(inline_block_paren_depth) operator(-=) integer(1)]
insert[insert(+)              keyword(if) ident(inline_block_paren_depth) operator(==) integer(0)  comment(# closing brace of inline block reached)]
insert[insert(+)                ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:inline_delimiter)operator(])]
insert[insert(+)                ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])]
insert[insert(+)                ident(state)operator(,) ident(string_delimiter)operator(,) ident(inline_block_paren_depth) operator(=) ident(inline_block_stack)operator(.)ident(pop)]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(check)operator(()regexp<delimiter(/)content([)char(\\d)content(.])delimiter(/)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:hex)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?>0[0-7]+\)(?![89.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:oct)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+[fFdD]|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?[fFdD]?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+[fFdD]?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:float)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+[lLgG]?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content('''|""")delimiter(/)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) symbol(:multiline_string)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) ident(match)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)          ]
insert[insert(+)          comment(# TODO: record.'name' syntax)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["'])delimiter(/)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) ident(match) operator(==) string<delimiter(')content(/)delimiter(')> operator(?) symbol(:regexp) operator(:) symbol(:string)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) ident(state)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) ident(match)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(value_expected) operator(&&) operator(()ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\/)delimiter(/)>operator(\))operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:regexp)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:regexp)]
insert[insert(+)            ident(string_delimiter) operator(=) string<delimiter(')content(/)delimiter(')>]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( @ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:annotation)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\/)delimiter(/)>operator(\))]
insert[insert(+)            ident(after_def) operator(=) predefined_constant(false)]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:string)operator(,) symbol(:regexp)operator(,) symbol(:multiline_string)]
insert[insert(+)          keyword(if) ident(scan)operator(()constant(STRING_CONTENT_PATTERN)operator([)ident(string_delimiter)operator(])operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()ident(state) operator(==) symbol(:multiline_string) operator(?) regexp<delimiter(/)content('''|""")delimiter(/)> operator(:) regexp<delimiter(/)content(["')char(\\/)content(])delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            keyword(if) ident(state) operator(==) symbol(:regexp)]
insert[insert(+)              comment(# TODO: regexp modifiers? s, m, x, i?)]
insert[insert(+)              ident(modifiers) operator(=) ident(scan)operator(()regexp<delimiter(/)content([ix]+)delimiter(/)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(modifiers)operator(,) symbol(:modifier)operator(]) keyword(if) ident(modifiers) operator(&&) operator(!)ident(modifiers)operator(.)ident(empty?)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(state) operator(=) symbol(:string) keyword(if) ident(state) operator(==) symbol(:multiline_string)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) operator(()ident(state) operator(==) symbol(:string) operator(||) ident(state) operator(==) symbol(:multiline_string)operator(\)) operator(&&)]
insert[insert(+)              operator(()ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))operator(\))]
insert[insert(+)            keyword(if) ident(string_delimiter)operator([)integer(0)operator(]) operator(==) integer(?') operator(&&) operator(!)operator(()ident(match) operator(==) string<delimiter(")char(\\\\)char(\\\\)delimiter(")> operator(||) ident(match) operator(==) string<delimiter(")char(\\\\)content(')delimiter(")>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(kind) operator(=) symbol(:char)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(state) operator(==) symbol(:regexp) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(REGEXP_ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\$)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)string<delimiter(')content($)delimiter(')>operator(,) symbol(:inline_delimiter)operator(])]
insert[insert(+)            ident(match) operator(=) ident(match)operator([)integer(1)operator(..)integer(-1)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) constant(IDENT_KIND)operator([)ident(match)operator(])operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\$)content( )char(\\{)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)string<delimiter(')content(${)delimiter(')>operator(,) symbol(:inline_delimiter)operator(])]
insert[insert(+)            ident(inline_block_stack) operator(<<) operator([)ident(state)operator(,) ident(string_delimiter)operator(,) ident(inline_block_paren_depth)operator(])]
insert[insert(+)            ident(inline_block_paren_depth) operator(=) integer(1)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\$)content( )delimiter(/)modifier(mx)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content(. )delimiter(/)modifier(mx)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | )char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(after_def) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)]
insert[insert(+)        keyword(end)]
insert[insert(+)]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(last_token) operator(=) ident(match) keyword(unless) operator([)symbol(:space)operator(,) symbol(:comment)operator(,) symbol(:doctype)operator(])operator(.)ident(include?) ident(kind)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(if) operator([)symbol(:multiline_string)operator(,) symbol(:string)operator(,) symbol(:regexp)operator(])operator(.)ident(include?) ident(state)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/rhtml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/rhtml.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/rhtml.rb)plain(	(revision 500\))]
change[change(@@)plain( -4,13 +4,14 )change(@@)]
   ident(load) symbol(:html)
   ident(load) symbol(:ruby)
 
delete[delete(-)  comment(# RHTML Scanner)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# $Id$)]
insert[insert(+)  comment(# Scanner for HTML ERB templates.)]
   keyword(class) class(RHTML) operator(<) constant(Scanner)
 
     ident(include) constant(Streamable)
     ident(register_for) symbol(:rhtml)
insert[insert(+)    ident(title) string<delimiter(')content(HTML ERB Template)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) constant(HTML)operator(::)constant(KINDS_NOT_LOC)]
 
     constant(ERB_RUBY_BLOCK) operator(=) regexp<delimiter(/)>
regexp<content(       <%(?!%\)[=-]?)>
change[change(@@)plain( -22,13 +23,13 )change(@@)]
         operator(\))operator(*)
       operator(\))
       operator(()integer(?:) operator(-)integer(?%)operator(>) operator(\))operator(?)
delete[delete(-)    regexp<delimiter(/)content(x)>]
insert[insert(+)    regexp<delimiter(/)content(x)>eyecatcher<regexp<content(  # :nodoc:)>>]
regexp<content( )>
regexp<content(     START_OF_ERB = )delimiter(/)>
       operator(<)string<delimiter(%()content(?!%)delimiter(\))>
delete[delete(-)    regexp<delimiter(/)content(x)>]
insert[insert(+)    regexp<delimiter(/)content(x)>eyecatcher<regexp<content(  # :nodoc:)>>]
regexp<content( )>
delete[delete(-)regexp<content(  pr)>eyecatcher<regexp<content(ivate)>>]
insert[insert(+)regexp<content(  pr)>eyecatcher<regexp<content(otected)>>]
regexp<content( )>
regexp<content(     def setup)>
regexp<content(       @ruby_scanner = CodeRay.scanner :ruby, :tokens => @tokens, :keep_tokens => true)>
head[head(Index: )plain(lib/coderay/scanners/debug.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/debug.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/debug.rb)plain(	(revision 500\))]
change[change(@@)plain( -6,6 +6,8 )change(@@)]
 
     ident(include) constant(Streamable)
     ident(register_for) symbol(:debug)
insert[insert(+)    ident(file_extension) string<delimiter(')content(raydebug)delimiter(')>]
insert[insert(+)    ident(title) string<delimiter(')content(CodeRay Token Dump)delimiter(')>]
 
   ident(protected)
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
head[head(Index: )plain(lib/coderay/scanners/php.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/php.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/php.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,532 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  ident(load) symbol(:html)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for PHP.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Original by Stefan Walk.)]
insert[insert(+)  keyword(class) class(PHP) operator(<) constant(Scanner)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:php)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(php)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) constant(HTML)operator(::)constant(KINDS_NOT_LOC)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(setup)]
insert[insert(+)      instance_variable(@html_scanner) operator(=) constant(CodeRay)operator(.)ident(scanner) symbol(:html)operator(,) symbol(:tokens) operator(=)operator(>) instance_variable(@tokens)operator(,) symbol(:keep_tokens) operator(=)operator(>) predefined_constant(true)operator(,) symbol(:keep_state) operator(=)operator(>) predefined_constant(true)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(reset_instance)]
insert[insert(+)      keyword(super)]
insert[insert(+)      instance_variable(@html_scanner)operator(.)ident(reset)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(module) class(Words)  comment(# :nodoc:)]
insert[insert(+)      ]
insert[insert(+)      comment(# according to http://www.php.net/manual/en/reserved.keywords.php)]
insert[insert(+)      constant(KEYWORDS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        abstract and array as break case catch class clone const continue declare default do else elseif)>]
insert[insert(+)string<content(        enddeclare endfor endforeach endif endswitch endwhile extends final for foreach function global)>]
insert[insert(+)string<content(        goto if implements interface instanceof namespace new or private protected public static switch)>]
insert[insert(+)string<content(        throw try use var while xor)>]
insert[insert(+)string<content(        cfunction old_function)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(TYPES) operator(=) string<delimiter(%w[)content( int integer float double bool boolean string array object resource )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(LANGUAGE_CONSTRUCTS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        die echo empty exit eval include include_once isset list)>]
insert[insert(+)string<content(        require require_once return print unset)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(CLASSES) operator(=) string<delimiter(%w[)content( Directory stdClass __PHP_Incomplete_Class exception php_user_filter Closure )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      comment(# according to http://php.net/quickref.php on 2009-04-21;)]
insert[insert(+)      comment(# all functions with _ excluded (module functions\) and selected additional functions)]
insert[insert(+)      constant(BUILTIN_FUNCTIONS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        abs acos acosh addcslashes addslashes aggregate array arsort ascii2ebcdic asin asinh asort assert atan atan2)>]
insert[insert(+)string<content(        atanh basename bcadd bccomp bcdiv bcmod bcmul bcpow bcpowmod bcscale bcsqrt bcsub bin2hex bindec)>]
insert[insert(+)string<content(        bindtextdomain bzclose bzcompress bzdecompress bzerrno bzerror bzerrstr bzflush bzopen bzread bzwrite)>]
insert[insert(+)string<content(        calculhmac ceil chdir checkdate checkdnsrr chgrp chmod chop chown chr chroot clearstatcache closedir closelog)>]
insert[insert(+)string<content(        compact constant copy cos cosh count crc32 crypt current date dcgettext dcngettext deaggregate decbin dechex)>]
insert[insert(+)string<content(        decoct define defined deg2rad delete dgettext die dirname diskfreespace dl dngettext doubleval each)>]
insert[insert(+)string<content(        ebcdic2ascii echo empty end ereg eregi escapeshellarg escapeshellcmd eval exec exit exp explode expm1 extract)>]
insert[insert(+)string<content(        fclose feof fflush fgetc fgetcsv fgets fgetss file fileatime filectime filegroup fileinode filemtime fileowner)>]
insert[insert(+)string<content(        fileperms filepro filesize filetype floatval flock floor flush fmod fnmatch fopen fpassthru fprintf fputcsv)>]
insert[insert(+)string<content(        fputs fread frenchtojd fscanf fseek fsockopen fstat ftell ftok ftruncate fwrite getallheaders getcwd getdate)>]
insert[insert(+)string<content(        getenv gethostbyaddr gethostbyname gethostbynamel getimagesize getlastmod getmxrr getmygid getmyinode getmypid)>]
insert[insert(+)string<content(        getmyuid getopt getprotobyname getprotobynumber getrandmax getrusage getservbyname getservbyport gettext)>]
insert[insert(+)string<content(        gettimeofday gettype glob gmdate gmmktime gmstrftime gregoriantojd gzclose gzcompress gzdecode gzdeflate)>]
insert[insert(+)string<content(        gzencode gzeof gzfile gzgetc gzgets gzgetss gzinflate gzopen gzpassthru gzputs gzread gzrewind gzseek gztell)>]
insert[insert(+)string<content(        gzuncompress gzwrite hash header hebrev hebrevc hexdec htmlentities htmlspecialchars hypot iconv idate)>]
insert[insert(+)string<content(        implode include intval ip2long iptcembed iptcparse isset)>]
insert[insert(+)string<content(        jddayofweek jdmonthname jdtofrench jdtogregorian jdtojewish jdtojulian jdtounix jewishtojd join jpeg2wbmp)>]
insert[insert(+)string<content(        juliantojd key krsort ksort lcfirst lchgrp lchown levenshtein link linkinfo list localeconv localtime log)>]
insert[insert(+)string<content(        log10 log1p long2ip lstat ltrim mail main max md5 metaphone mhash microtime min mkdir mktime msql natcasesort)>]
insert[insert(+)string<content(        natsort next ngettext nl2br nthmac octdec opendir openlog)>]
insert[insert(+)string<content(        ord overload pack passthru pathinfo pclose pfsockopen phpcredits phpinfo phpversion pi png2wbmp popen pos pow)>]
insert[insert(+)string<content(        prev print printf putenv quotemeta rad2deg rand range rawurldecode rawurlencode readdir readfile readgzfile)>]
insert[insert(+)string<content(        readline readlink realpath recode rename require reset rewind rewinddir rmdir round rsort rtrim scandir)>]
insert[insert(+)string<content(        serialize setcookie setlocale setrawcookie settype sha1 shuffle signeurlpaiement sin sinh sizeof sleep snmpget)>]
insert[insert(+)string<content(        snmpgetnext snmprealwalk snmpset snmpwalk snmpwalkoid sort soundex split spliti sprintf sqrt srand sscanf stat)>]
insert[insert(+)string<content(        strcasecmp strchr strcmp strcoll strcspn strftime stripcslashes stripos stripslashes stristr strlen)>]
insert[insert(+)string<content(        strnatcasecmp strnatcmp strncasecmp strncmp strpbrk strpos strptime strrchr strrev strripos strrpos strspn)>]
insert[insert(+)string<content(        strstr strtok strtolower strtotime strtoupper strtr strval substr symlink syslog system tan tanh tempnam)>]
insert[insert(+)string<content(        textdomain time tmpfile touch trim uasort ucfirst ucwords uksort umask uniqid unixtojd unlink unpack)>]
insert[insert(+)string<content(        unserialize unset urldecode urlencode usleep usort vfprintf virtual vprintf vsprintf wordwrap)>]
insert[insert(+)string<content(        array_change_key_case array_chunk array_combine array_count_values array_diff array_diff_assoc)>]
insert[insert(+)string<content(        array_diff_key array_diff_uassoc array_diff_ukey array_fill array_fill_keys array_filter array_flip)>]
insert[insert(+)string<content(        array_intersect array_intersect_assoc array_intersect_key array_intersect_uassoc array_intersect_ukey)>]
insert[insert(+)string<content(        array_key_exists array_keys array_map array_merge array_merge_recursive array_multisort array_pad)>]
insert[insert(+)string<content(        array_pop array_product array_push array_rand array_reduce array_reverse array_search array_shift)>]
insert[insert(+)string<content(        array_slice array_splice array_sum array_udiff array_udiff_assoc array_udiff_uassoc array_uintersect)>]
insert[insert(+)string<content(        array_uintersect_assoc array_uintersect_uassoc array_unique array_unshift array_values array_walk)>]
insert[insert(+)string<content(        array_walk_recursive)>]
insert[insert(+)string<content(        assert_options base_convert base64_decode base64_encode)>]
insert[insert(+)string<content(        chunk_split class_exists class_implements class_parents)>]
insert[insert(+)string<content(        count_chars debug_backtrace debug_print_backtrace debug_zval_dump)>]
insert[insert(+)string<content(        error_get_last error_log error_reporting extension_loaded)>]
insert[insert(+)string<content(        file_exists file_get_contents file_put_contents load_file)>]
insert[insert(+)string<content(        func_get_arg func_get_args func_num_args function_exists)>]
insert[insert(+)string<content(        get_browser get_called_class get_cfg_var get_class get_class_methods get_class_vars)>]
insert[insert(+)string<content(        get_current_user get_declared_classes get_declared_interfaces get_defined_constants)>]
insert[insert(+)string<content(        get_defined_functions get_defined_vars get_extension_funcs get_headers get_html_translation_table)>]
insert[insert(+)string<content(        get_include_path get_included_files get_loaded_extensions get_magic_quotes_gpc get_magic_quotes_runtime)>]
insert[insert(+)string<content(        get_meta_tags get_object_vars get_parent_class get_required_filesget_resource_type)>]
insert[insert(+)string<content(        gc_collect_cycles gc_disable gc_enable gc_enabled)>]
insert[insert(+)string<content(        halt_compiler headers_list headers_sent highlight_file highlight_string)>]
insert[insert(+)string<content(        html_entity_decode htmlspecialchars_decode)>]
insert[insert(+)string<content(        in_array include_once inclued_get_data)>]
insert[insert(+)string<content(        is_a is_array is_binary is_bool is_buffer is_callable is_dir is_double is_executable is_file is_finite)>]
insert[insert(+)string<content(        is_float is_infinite is_int is_integer is_link is_long is_nan is_null is_numeric is_object is_readable)>]
insert[insert(+)string<content(        is_real is_resource is_scalar is_soap_fault is_string is_subclass_of is_unicode is_uploaded_file)>]
insert[insert(+)string<content(        is_writable is_writeable)>]
insert[insert(+)string<content(        locale_get_default locale_set_default)>]
insert[insert(+)string<content(        number_format override_function parse_str parse_url)>]
insert[insert(+)string<content(        php_check_syntax php_ini_loaded_file php_ini_scanned_files php_logo_guid php_sapi_name)>]
insert[insert(+)string<content(        php_strip_whitespace php_uname)>]
insert[insert(+)string<content(        preg_filter preg_grep preg_last_error preg_match preg_match_all preg_quote preg_replace)>]
insert[insert(+)string<content(        preg_replace_callback preg_split print_r)>]
insert[insert(+)string<content(        require_once register_shutdown_function register_tick_function)>]
insert[insert(+)string<content(        set_error_handler set_exception_handler set_file_buffer set_include_path)>]
insert[insert(+)string<content(        set_magic_quotes_runtime set_time_limit shell_exec)>]
insert[insert(+)string<content(        str_getcsv str_ireplace str_pad str_repeat str_replace str_rot13 str_shuffle str_split str_word_count)>]
insert[insert(+)string<content(        strip_tags substr_compare substr_count substr_replace)>]
insert[insert(+)string<content(        time_nanosleep time_sleep_until)>]
insert[insert(+)string<content(        token_get_all token_name trigger_error)>]
insert[insert(+)string<content(        unregister_tick_function use_soap_error_handler user_error)>]
insert[insert(+)string<content(        utf8_decode utf8_encode var_dump var_export)>]
insert[insert(+)string<content(        version_compare)>]
insert[insert(+)string<content(        zend_logo_guid zend_thread_id zend_version)>]
insert[insert(+)string<content(        create_function call_user_func_array)>]
insert[insert(+)string<content(        posix_access posix_ctermid posix_get_last_error posix_getcwd posix_getegid)>]
insert[insert(+)string<content(        posix_geteuid posix_getgid posix_getgrgid posix_getgrnam posix_getgroups)>]
insert[insert(+)string<content(        posix_getlogin posix_getpgid posix_getpgrp posix_getpid posix_getppid)>]
insert[insert(+)string<content(        posix_getpwnam posix_getpwuid posix_getrlimit posix_getsid posix_getuid)>]
insert[insert(+)string<content(        posix_initgroups posix_isatty posix_kill posix_mkfifo posix_mknod)>]
insert[insert(+)string<content(        posix_setegid posix_seteuid posix_setgid posix_setpgid posix_setsid)>]
insert[insert(+)string<content(        posix_setuid posix_strerror posix_times posix_ttyname posix_uname)>]
insert[insert(+)string<content(        pcntl_alarm pcntl_exec pcntl_fork pcntl_getpriority pcntl_setpriority)>]
insert[insert(+)string<content(        pcntl_signal pcntl_signal_dispatch pcntl_sigprocmask pcntl_sigtimedwait)>]
insert[insert(+)string<content(        pcntl_sigwaitinfo pcntl_wait pcntl_waitpid pcntl_wexitstatus pcntl_wifexited)>]
insert[insert(+)string<content(        pcntl_wifsignaled pcntl_wifstopped pcntl_wstopsig pcntl_wtermsig)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      comment(# TODO: more built-in PHP functions?)]
insert[insert(+)      ]
insert[insert(+)      constant(EXCEPTIONS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        E_ERROR E_WARNING E_PARSE E_NOTICE E_CORE_ERROR E_CORE_WARNING E_COMPILE_ERROR E_COMPILE_WARNING)>]
insert[insert(+)string<content(        E_USER_ERROR E_USER_WARNING E_USER_NOTICE E_DEPRECATED E_USER_DEPRECATED E_ALL E_STRICT)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(CONSTANTS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        null true false self parent)>]
insert[insert(+)string<content(        __LINE__ __DIR__ __FILE__ __LINE__)>]
insert[insert(+)string<content(        __CLASS__ __NAMESPACE__ __METHOD__ __FUNCTION__)>]
insert[insert(+)string<content(        PHP_VERSION PHP_MAJOR_VERSION PHP_MINOR_VERSION PHP_RELEASE_VERSION PHP_VERSION_ID PHP_EXTRA_VERSION PHP_ZTS)>]
insert[insert(+)string<content(        PHP_DEBUG PHP_MAXPATHLEN PHP_OS PHP_SAPI PHP_EOL PHP_INT_MAX PHP_INT_SIZE DEFAULT_INCLUDE_PATH)>]
insert[insert(+)string<content(        PEAR_INSTALL_DIR PEAR_EXTENSION_DIR PHP_EXTENSION_DIR PHP_PREFIX PHP_BINDIR PHP_LIBDIR PHP_DATADIR)>]
insert[insert(+)string<content(        PHP_SYSCONFDIR PHP_LOCALSTATEDIR PHP_CONFIG_FILE_PATH PHP_CONFIG_FILE_SCAN_DIR PHP_SHLIB_SUFFIX)>]
insert[insert(+)string<content(        PHP_OUTPUT_HANDLER_START PHP_OUTPUT_HANDLER_CONT PHP_OUTPUT_HANDLER_END)>]
insert[insert(+)string<content(        __COMPILER_HALT_OFFSET__)>]
insert[insert(+)string<content(        EXTR_OVERWRITE EXTR_SKIP EXTR_PREFIX_SAME EXTR_PREFIX_ALL EXTR_PREFIX_INVALID EXTR_PREFIX_IF_EXISTS)>]
insert[insert(+)string<content(        EXTR_IF_EXISTS SORT_ASC SORT_DESC SORT_REGULAR SORT_NUMERIC SORT_STRING CASE_LOWER CASE_UPPER COUNT_NORMAL)>]
insert[insert(+)string<content(        COUNT_RECURSIVE ASSERT_ACTIVE ASSERT_CALLBACK ASSERT_BAIL ASSERT_WARNING ASSERT_QUIET_EVAL CONNECTION_ABORTED)>]
insert[insert(+)string<content(        CONNECTION_NORMAL CONNECTION_TIMEOUT INI_USER INI_PERDIR INI_SYSTEM INI_ALL M_E M_LOG2E M_LOG10E M_LN2 M_LN10)>]
insert[insert(+)string<content(        M_PI M_PI_2 M_PI_4 M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2 CRYPT_SALT_LENGTH CRYPT_STD_DES CRYPT_EXT_DES)>]
insert[insert(+)string<content(        CRYPT_MD5 CRYPT_BLOWFISH DIRECTORY_SEPARATOR SEEK_SET SEEK_CUR SEEK_END LOCK_SH LOCK_EX LOCK_UN LOCK_NB)>]
insert[insert(+)string<content(        HTML_SPECIALCHARS HTML_ENTITIES ENT_COMPAT ENT_QUOTES ENT_NOQUOTES INFO_GENERAL INFO_CREDITS)>]
insert[insert(+)string<content(        INFO_CONFIGURATION INFO_MODULES INFO_ENVIRONMENT INFO_VARIABLES INFO_LICENSE INFO_ALL CREDITS_GROUP)>]
insert[insert(+)string<content(        CREDITS_GENERAL CREDITS_SAPI CREDITS_MODULES CREDITS_DOCS CREDITS_FULLPAGE CREDITS_QA CREDITS_ALL STR_PAD_LEFT)>]
insert[insert(+)string<content(        STR_PAD_RIGHT STR_PAD_BOTH PATHINFO_DIRNAME PATHINFO_BASENAME PATHINFO_EXTENSION PATH_SEPARATOR CHAR_MAX)>]
insert[insert(+)string<content(        LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_ALL LC_MESSAGES ABDAY_1 ABDAY_2 ABDAY_3 ABDAY_4 ABDAY_5)>]
insert[insert(+)string<content(        ABDAY_6 ABDAY_7 DAY_1 DAY_2 DAY_3 DAY_4 DAY_5 DAY_6 DAY_7 ABMON_1 ABMON_2 ABMON_3 ABMON_4 ABMON_5 ABMON_6)>]
insert[insert(+)string<content(        ABMON_7 ABMON_8 ABMON_9 ABMON_10 ABMON_11 ABMON_12 MON_1 MON_2 MON_3 MON_4 MON_5 MON_6 MON_7 MON_8 MON_9)>]
insert[insert(+)string<content(        MON_10 MON_11 MON_12 AM_STR PM_STR D_T_FMT D_FMT T_FMT T_FMT_AMPM ERA ERA_YEAR ERA_D_T_FMT ERA_D_FMT ERA_T_FMT)>]
insert[insert(+)string<content(        ALT_DIGITS INT_CURR_SYMBOL CURRENCY_SYMBOL CRNCYSTR MON_DECIMAL_POINT MON_THOUSANDS_SEP MON_GROUPING)>]
insert[insert(+)string<content(        POSITIVE_SIGN NEGATIVE_SIGN INT_FRAC_DIGITS FRAC_DIGITS P_CS_PRECEDES P_SEP_BY_SPACE N_CS_PRECEDES)>]
insert[insert(+)string<content(        N_SEP_BY_SPACE P_SIGN_POSN N_SIGN_POSN DECIMAL_POINT RADIXCHAR THOUSANDS_SEP THOUSEP GROUPING YESEXPR NOEXPR)>]
insert[insert(+)string<content(        YESSTR NOSTR CODESET LOG_EMERG LOG_ALERT LOG_CRIT LOG_ERR LOG_WARNING LOG_NOTICE LOG_INFO LOG_DEBUG LOG_KERN)>]
insert[insert(+)string<content(        LOG_USER LOG_MAIL LOG_DAEMON LOG_AUTH LOG_SYSLOG LOG_LPR LOG_NEWS LOG_UUCP LOG_CRON LOG_AUTHPRIV LOG_LOCAL0)>]
insert[insert(+)string<content(        LOG_LOCAL1 LOG_LOCAL2 LOG_LOCAL3 LOG_LOCAL4 LOG_LOCAL5 LOG_LOCAL6 LOG_LOCAL7 LOG_PID LOG_CONS LOG_ODELAY)>]
insert[insert(+)string<content(        LOG_NDELAY LOG_NOWAIT LOG_PERROR)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(PREDEFINED) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        $GLOBALS $_SERVER $_GET $_POST $_FILES $_REQUEST $_SESSION $_ENV)>]
insert[insert(+)string<content(        $_COOKIE $php_errormsg $HTTP_RAW_POST_DATA $http_response_header)>]
insert[insert(+)string<content(        $argc $argv)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)      ]
insert[insert(+)      constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(KEYWORDS)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(TYPES)operator(,) symbol(:pre_type)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(LANGUAGE_CONSTRUCTS)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(BUILTIN_FUNCTIONS)operator(,) symbol(:predefined)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(CLASSES)operator(,) symbol(:pre_constant)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(EXCEPTIONS)operator(,) symbol(:exception)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(CONSTANTS)operator(,) symbol(:pre_constant)operator(\))]
insert[insert(+)      ]
insert[insert(+)      constant(VARIABLE_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:local_variable)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(PREDEFINED)operator(,) symbol(:predefined)operator(\))]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    keyword(module) class(RE)  comment(# :nodoc:)]
insert[insert(+)      ]
insert[insert(+)      constant(PHP_START) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(        <script)char(\\s)content(+[^>]*?language)char(\\s)content(*=)char(\\s)content(*"php"[^>]*?> |)>]
insert[insert(+)regexp<content(        <script)char(\\s)content(+[^>]*?language)char(\\s)content(*=)char(\\s)content(*'php'[^>]*?> |)>]
insert[insert(+)regexp<content(        <)char(\\?)content(php)char(\\d)content(? |)>]
insert[insert(+)regexp<content(        <)char(\\?)content((?!xml\))>]
insert[insert(+)regexp<content(      )delimiter(/)modifier(xi)>]
insert[insert(+)      ]
insert[insert(+)      constant(PHP_END) operator(=) regexp<delimiter(%r!)>]
insert[insert(+)regexp<content(        </script> |)>]
insert[insert(+)regexp<content(        )char(\\?)content(>)>]
insert[insert(+)regexp<content(      )delimiter(!)modifier(xi)>]
insert[insert(+)      ]
insert[insert(+)      constant(HTML_INDICATOR) operator(=) regexp<delimiter(/)content(<!DOCTYPE html|<(?:html|body|div|p\)[> ])delimiter(/)modifier(i)>]
insert[insert(+)      ]
insert[insert(+)      constant(IDENTIFIER) operator(=) regexp<delimiter(/)content([a-z_)char(\\x7f)content(-)char(\\xFF)content(][a-z0-9_)char(\\x7f)content(-)char(\\xFF)content(]*)delimiter(/)modifier(i)>]
insert[insert(+)      constant(VARIABLE) operator(=) regexp<delimiter(/)char(\\$)inline<inline_delimiter(#{)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      ]
insert[insert(+)      constant(OPERATOR) operator(=) regexp<delimiter(/)>]
insert[insert(+)regexp<content(        )char(\\.)content((?!)char(\\d)content(\)=? |      # dot that is not decimal point, string concatenation)>]
insert[insert(+)regexp<content(        && | )char(\\|)char(\\|)content( |       # logic)>]
insert[insert(+)regexp<content(        :: | -> | => |    # scope, member, dictionary)>]
insert[insert(+)regexp<content(        )char(\\+)char(\\+)content( | -- |       # increment, decrement)>]
insert[insert(+)regexp<content(        [,;?:(\))char(\\[)char(\\])content({}] |  # simple delimiters)>]
insert[insert(+)regexp<content(        [-+*)char(\\/)content(%&|^]=? |   # ordinary math, binary logic, assignment shortcuts)>]
insert[insert(+)regexp<content(        [~$] |            # whatever)>]
insert[insert(+)regexp<content(        =& |              # reference assignment)>]
insert[insert(+)regexp<content(        [=!]=?=? | <> |   # comparison and assignment)>]
insert[insert(+)regexp<content(        <<=? | >>=? | [<>]=?  # comparison and shift)>]
insert[insert(+)regexp<content(      )delimiter(/)modifier(x)>]
insert[insert(+)      ]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      keyword(if) ident(check)operator(()constant(RE)operator(::)constant(PHP_START)operator(\)) operator(||)  comment(# starts with <?)]
insert[insert(+)       operator(()ident(match?)operator(()regexp<delimiter(/)char(\\s)content(*<)char(\\S)delimiter(/)>operator(\)) operator(&&) ident(exist?)operator(()constant(RE)operator(::)constant(PHP_START)operator(\))operator(\)) operator(||) comment(# starts with tag and contains <?)]
insert[insert(+)       ident(exist?)operator(()constant(RE)operator(::)constant(HTML_INDICATOR)operator(\)) operator(||)]
insert[insert(+)       ident(check)operator(()regexp<delimiter(/)content(.{1,100})inline<inline_delimiter(#{)constant(RE)operator(::)constant(PHP_START)inline_delimiter(})>delimiter(/)modifier(om)>operator(\))  comment(# PHP start after max 100 chars)]
insert[insert(+)        comment(# is HTML with embedded PHP, so start with HTML)]
insert[insert(+)        ident(states) operator(=) operator([)symbol(:initial)operator(])]
insert[insert(+)      keyword(else)]
insert[insert(+)        comment(# is just PHP, so start with PHP surrounded by HTML)]
insert[insert(+)        ident(states) operator(=) operator([)symbol(:initial)operator(,) symbol(:php)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)      ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)      ]
insert[insert(+)      ident(heredoc_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(modifier) operator(=) predefined_constant(nil)]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(states)operator(.)ident(last)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:initial)  comment(# HTML)]
insert[insert(+)          keyword(if) ident(scan) constant(RE)operator(::)constant(PHP_START)]
insert[insert(+)            ident(kind) operator(=) symbol(:inline_delimiter)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(states) operator(<<) symbol(:php)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(match) operator(=) ident(scan_until)operator(()regexp<delimiter(/)content((?=)inline<inline_delimiter(#{)constant(RE)operator(::)constant(PHP_START)inline_delimiter(})>content(\))delimiter(/)modifier(o)>operator(\)) operator(||) ident(scan_until)operator(()regexp<delimiter(/)char(\\z)delimiter(/)>operator(\))]
insert[insert(+)            instance_variable(@html_scanner)operator(.)ident(tokenize) ident(match) keyword(unless) ident(match)operator(.)ident(empty?)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:php)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( (?m: )char(\\/)char(\\*)content( (?: .*? )char(\\*)char(\\/)content( | .* \) \) | (?://|)char(\\#)content(\) .*? (?=)inline<inline_delimiter(#{)constant(RE)operator(::)constant(PHP_END)inline_delimiter(})>content(|$\) )delimiter(!)modifier(xo)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()constant(RE)operator(::)constant(IDENTIFIER)operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(Words)operator(::)constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            keyword(if) ident(kind) operator(==) symbol(:ident) operator(&&) ident(label_expected) operator(&&) ident(check)operator(()regexp<delimiter(/)content(:(?!:\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:label)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)              keyword(if) ident(kind) operator(==) symbol(:ident) operator(&&) ident(match) operator(=)operator(~) regexp<delimiter(/)content(^[A-Z])delimiter(/)>]
insert[insert(+)                ident(kind) operator(=) symbol(:constant)]
insert[insert(+)              keyword(elsif) ident(kind) operator(==) symbol(:reserved)]
insert[insert(+)                keyword(case) ident(match)]
insert[insert(+)                keyword(when) string<delimiter(')content(class)delimiter(')>]
insert[insert(+)                  ident(states) operator(<<) symbol(:class_expected)]
insert[insert(+)                keyword(when) string<delimiter(')content(function)delimiter(')>]
insert[insert(+)                  ident(states) operator(<<) symbol(:function_expected)]
insert[insert(+)                keyword(when) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>]
insert[insert(+)                  ident(case_expected) operator(=) predefined_constant(true)]
insert[insert(+)                keyword(end)]
insert[insert(+)              keyword(elsif) ident(match) operator(==) string<delimiter(')content(b)delimiter(')> operator(&&) ident(check)operator(()regexp<delimiter(/)content(['"])delimiter(/)>operator(\))  comment(# binary string literal)]
insert[insert(+)                ident(modifier) operator(=) ident(match)]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\d)content(+)char(\\.)char(\\d)content(*|)char(\\d)content(*)char(\\.)char(\\d)content(+\)(?:e[-+]?)char(\\d)content(+\)?|)char(\\d)content(+e[-+]?)char(\\d)content(+)delimiter(/)modifier(i)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:float)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0x[0-9a-fA-F]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:hex)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:integer)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(')delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            keyword(if) ident(modifier)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(modifier)operator(,) symbol(:modifier)operator(])]
insert[insert(+)              ident(modifier) operator(=) predefined_constant(nil)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)            ident(states)operator(.)ident(push) symbol(:sqstring)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["`])delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            keyword(if) ident(modifier)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(modifier)operator(,) symbol(:modifier)operator(])]
insert[insert(+)              ident(modifier) operator(=) predefined_constant(nil)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(delimiter) operator(=) ident(match)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)            ident(states)operator(.)ident(push) symbol(:dqstring)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()constant(RE)operator(::)constant(VARIABLE)operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) constant(Words)operator(::)constant(VARIABLE_KIND)operator([)ident(match)operator(])]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(states)operator(.)ident(push) symbol(:php)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\})delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(states)operator(.)ident(size) operator(==) integer(1)]
insert[insert(+)              ident(kind) operator(=) symbol(:error)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(states)operator(.)ident(pop)]
insert[insert(+)              keyword(if) ident(states)operator(.)ident(last)operator(.)ident(is_a?)operator(()operator(::)constant(Array)operator(\))]
insert[insert(+)                ident(delimiter) operator(=) ident(states)operator(.)ident(last)operator([)integer(1)operator(])]
insert[insert(+)                ident(states)operator([)integer(-1)operator(]) operator(=) ident(states)operator(.)ident(last)operator([)integer(0)operator(])]
insert[insert(+)                ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)                ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(else)]
insert[insert(+)                ident(kind) operator(=) symbol(:operator)]
insert[insert(+)                ident(label_expected) operator(=) predefined_constant(true)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(@)delimiter(/)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:exception)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan) constant(RE)operator(::)constant(PHP_END)]
insert[insert(+)            ident(kind) operator(=) symbol(:inline_delimiter)]
insert[insert(+)            ident(states) operator(=) operator([)symbol(:initial)operator(])]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<<<(?:()inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>content(\)|"()inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>content(\)"|'()inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>content(\)'\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(warn) string<delimiter(')content(heredoc in heredoc?)delimiter(')> keyword(if) ident(heredoc_delimiter)]
insert[insert(+)            ident(heredoc_delimiter) operator(=) constant(Regexp)operator(.)ident(escape)operator(()predefined_constant(self)operator([)integer(1)operator(]) operator(||) predefined_constant(self)operator([)integer(2)operator(]) operator(||) predefined_constant(self)operator([)integer(3)operator(])operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)            ident(states)operator(.)ident(push) predefined_constant(self)operator([)integer(3)operator(]) operator(?) symbol(:sqstring) operator(:) symbol(:dqstring)]
insert[insert(+)            ident(heredoc_delimiter) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)ident(heredoc_delimiter)inline_delimiter(})>content((?=;?$\))delimiter(/)>]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(OPERATOR)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(label_expected) operator(=) ident(match) operator(==) string<delimiter(')content(;)delimiter(')>]
insert[insert(+)            keyword(if) ident(case_expected)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(true) keyword(if) ident(match) operator(==) string<delimiter(')content(:)delimiter(')>]
insert[insert(+)              ident(case_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          ]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:sqstring)]
insert[insert(+)          keyword(if) ident(scan)operator(()ident(heredoc_delimiter) operator(?) regexp<delimiter(/)content([^)char(\\\\)char(\\n)content(]+)delimiter(/)> operator(:) regexp<delimiter(/)content([^')char(\\\\)content(]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) operator(!)ident(heredoc_delimiter) operator(&&) ident(scan)operator(()regexp<delimiter(/)content(')delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(heredoc_delimiter) operator(&&) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(if) ident(scan) ident(heredoc_delimiter)]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(")char(\\n)delimiter(")>operator(,) symbol(:content)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(heredoc_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)              ident(states)operator(.)ident(pop)]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()ident(heredoc_delimiter) operator(?) regexp<delimiter(/)char(\\\\)char(\\\\)delimiter(/)> operator(:) regexp<delimiter(/)char(\\\\)content([)char(\\\\)content(')char(\\n)content(])delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:dqstring)]
insert[insert(+)          keyword(if) ident(scan)operator(()ident(heredoc_delimiter) operator(?) regexp<delimiter(/)content([^${)char(\\\\)char(\\n)content(]+)delimiter(/)> operator(:) operator(()ident(delimiter) operator(==) string<delimiter(')content(")delimiter(')> operator(?) regexp<delimiter(/)content([^"${)char(\\\\)content(]+)delimiter(/)> operator(:) regexp<delimiter(/)content([^`${)char(\\\\)content(]+)delimiter(/)>operator(\))operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) operator(!)ident(heredoc_delimiter) operator(&&) ident(scan)operator(()ident(delimiter) operator(==) string<delimiter(')content(")delimiter(')> operator(?) regexp<delimiter(/)content(")delimiter(/)> operator(:) regexp<delimiter(/)content(`)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)            ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(heredoc_delimiter) operator(&&) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(if) ident(scan) ident(heredoc_delimiter)]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(")char(\\n)delimiter(")>operator(,) symbol(:content)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(heredoc_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)              ident(label_expected) operator(=) predefined_constant(false)]
insert[insert(+)              ident(states)operator(.)ident(pop)]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content((?:x[0-9A-Fa-f]{1,2}|[0-7]{1,3}\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()ident(heredoc_delimiter) operator(?) regexp<delimiter(/)char(\\\\)content([nrtvf)char(\\\\)content($])delimiter(/)> operator(:) operator(()ident(delimiter) operator(==) string<delimiter(')content(")delimiter(')> operator(?) regexp<delimiter(/)char(\\\\)content([nrtvf)char(\\\\)content($"])delimiter(/)> operator(:) regexp<delimiter(/)char(\\\\)content([nrtvf)char(\\\\)content($`])delimiter(/)>operator(\))operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(VARIABLE)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:local_variable)]
insert[insert(+)            keyword(if) ident(check)operator(()regexp<delimiter(/)char(\\[)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>char(\\])delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:local_variable)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(scan)operator(()regexp<delimiter(/)char(\\[)delimiter(/)>operator(\))operator(,) symbol(:operator)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))operator(,) symbol(:ident)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(scan)operator(()regexp<delimiter(/)char(\\])delimiter(/)>operator(\))operator(,) symbol(:operator)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(elsif) ident(check)operator(()regexp<delimiter(/)char(\\[)delimiter(/)>operator(\))]
insert[insert(+)              ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\[)content(['"]?)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>content(?['"]?)char(\\])content(?)delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:error)]
insert[insert(+)            keyword(elsif) ident(check)operator(()regexp<delimiter(/)content(->)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:local_variable)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(scan)operator(()regexp<delimiter(/)content(->)delimiter(/)>operator(\))operator(,) symbol(:operator)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))operator(,) symbol(:ident)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(elsif) ident(check)operator(()regexp<delimiter(/)content(->)delimiter(/)>operator(\))]
insert[insert(+)              ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)content(->)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:error)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(check)operator(()regexp<delimiter(/)char(\\$)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)              ident(states)operator([)integer(-1)operator(]) operator(=) operator([)ident(states)operator(.)ident(last)operator(,) ident(delimiter)operator(])]
insert[insert(+)              ident(delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)              ident(states)operator(.)ident(push) symbol(:php)]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(kind) operator(=) symbol(:string)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\$)char(\\{)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>char(\\})delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:local_variable)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\$)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:class_expected)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:class)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:function_expected)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(&)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:function)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state!)delimiter(')>operator(,) ident(tokens)operator(,) ident(states)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(states)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens)operator(,) ident(states) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/css.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/css.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/css.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,211 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)]
insert[insert(+)  keyword(class) class(CSS) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(register_for) symbol(:css)]
insert[insert(+)]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) operator([)]
insert[insert(+)      symbol(:comment)operator(,)]
insert[insert(+)      symbol(:class)operator(,) symbol(:pseudo_class)operator(,) symbol(:type)operator(,)]
insert[insert(+)      symbol(:constant)operator(,) symbol(:directive)operator(,)]
insert[insert(+)      symbol(:key)operator(,) symbol(:value)operator(,) symbol(:operator)operator(,) symbol(:color)operator(,) symbol(:float)operator(,)]
insert[insert(+)      symbol(:error)operator(,) symbol(:important)operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    keyword(module) class(RE)  comment(# :nodoc:)]
insert[insert(+)      constant(NonASCII) operator(=) regexp<delimiter(/)content([)char(\\x80)content(-)char(\\xFF)content(])delimiter(/)>]
insert[insert(+)      constant(Hex) operator(=) regexp<delimiter(/)content([0-9a-fA-F])delimiter(/)>]
insert[insert(+)      constant(Unicode) operator(=) regexp<delimiter(/)char(\\\\)inline<inline_delimiter(#{)constant(Hex)inline_delimiter(})>content({1,6}(?:)char(\\r)char(\\n)content(|)char(\\s)content(\)?)delimiter(/)> comment(# differs from standard because it allows uppercase hex too)]
insert[insert(+)      constant(Escape) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(Unicode)inline_delimiter(})>content(|)char(\\\\)content([^)char(\\r)char(\\n)char(\\f)content(0-9a-fA-F])delimiter(/)>]
insert[insert(+)      constant(NMChar) operator(=) regexp<delimiter(/)content([-_a-zA-Z0-9]|)inline<inline_delimiter(#{)constant(NonASCII)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(Escape)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NMStart) operator(=) regexp<delimiter(/)content([_a-zA-Z]|)inline<inline_delimiter(#{)constant(NonASCII)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(Escape)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NL) operator(=) regexp<delimiter(/)char(\\r)char(\\n)content(|)char(\\r)content(|)char(\\n)content(|)char(\\f)delimiter(/)>]
insert[insert(+)      constant(String1) operator(=) regexp<delimiter(/)content("(?:[^)char(\\n)char(\\r)char(\\f)char(\\\\)content("]|)char(\\\\)inline<inline_delimiter(#{)constant(NL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(Escape)inline_delimiter(})>content(\)*"?)delimiter(/)>  comment(# FIXME: buggy regexp)]
insert[insert(+)      constant(String2) operator(=) regexp<delimiter(/)content('(?:[^)char(\\n)char(\\r)char(\\f)char(\\\\)content(']|)char(\\\\)inline<inline_delimiter(#{)constant(NL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(Escape)inline_delimiter(})>content(\)*'?)delimiter(/)>  comment(# FIXME: buggy regexp)]
insert[insert(+)      constant(String) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(String1)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(String2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)]
insert[insert(+)      constant(HexColor) operator(=) regexp<delimiter(/)content(#(?:)inline<inline_delimiter(#{)constant(Hex)inline_delimiter(})>content({6}|)inline<inline_delimiter(#{)constant(Hex)inline_delimiter(})>content({3}\))delimiter(/)>]
insert[insert(+)      constant(Color) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(HexColor)inline_delimiter(})>delimiter(/)>]
insert[insert(+)]
insert[insert(+)      constant(Num) operator(=) regexp<delimiter(/)content(-?(?:[0-9]+|[0-9]*)char(\\.)content([0-9]+\))delimiter(/)>]
insert[insert(+)      constant(Name) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NMChar)inline_delimiter(})>content(+)delimiter(/)>]
insert[insert(+)      constant(Ident) operator(=) regexp<delimiter(/)content(-?)inline<inline_delimiter(#{)constant(NMStart)inline_delimiter(})>inline<inline_delimiter(#{)constant(NMChar)inline_delimiter(})>content(*)delimiter(/)>]
insert[insert(+)      constant(AtKeyword) operator(=) regexp<delimiter(/)content(@)inline<inline_delimiter(#{)constant(Ident)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(Percentage) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(Num)inline_delimiter(})>content(%)delimiter(/)>]
insert[insert(+)]
insert[insert(+)      ident(reldimensions) operator(=) string<delimiter(%w[)content(em ex px)delimiter(])>]
insert[insert(+)      ident(absdimensions) operator(=) string<delimiter(%w[)content(in cm mm pt pc)delimiter(])>]
insert[insert(+)      constant(Unit) operator(=) constant(Regexp)operator(.)ident(union)operator(()operator(*)operator(()ident(reldimensions) operator(+) ident(absdimensions)operator(\))operator(\))]
insert[insert(+)]
insert[insert(+)      constant(Dimension) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(Num)inline_delimiter(})>inline<inline_delimiter(#{)constant(Unit)inline_delimiter(})>delimiter(/)>]
insert[insert(+)]
insert[insert(+)      constant(Comment) operator(=) regexp<delimiter(%r!)content( /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>]
insert[insert(+)      constant(Function) operator(=) regexp<delimiter(/)content((?:url|alpha\))char(\\()content((?:[^\))char(\\n)char(\\r)char(\\f)content(]|)char(\\\\)char(\\\))content(\)*)char(\\\))content(?)delimiter(/)>]
insert[insert(+)]
insert[insert(+)      constant(Id) operator(=) regexp<delimiter(/)content(#)inline<inline_delimiter(#{)constant(Name)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(Class) operator(=) regexp<delimiter(/)char(\\.)inline<inline_delimiter(#{)constant(Name)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(PseudoClass) operator(=) regexp<delimiter(/)content(:)inline<inline_delimiter(#{)constant(Name)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(AttributeSelector) operator(=) regexp<delimiter(/)char(\\[)content([^)char(\\])content(]*)char(\\])content(?)delimiter(/)>]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(value_expected) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(states) operator(=) operator([)symbol(:initial)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)]
insert[insert(+)        keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:space)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) keyword(case) ident(states)operator(.)ident(last)]
insert[insert(+)          keyword(when) symbol(:initial)operator(,) symbol(:media)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content((?>)inline<inline_delimiter(#{)constant(RE)operator(::)constant(Ident)inline_delimiter(})>content(\)(?!)char(\\()content(\)|)char(\\*)delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:type)]
insert[insert(+)            keyword(elsif) ident(scan) constant(RE)operator(::)constant(Class)]
insert[insert(+)              ident(kind) operator(=) symbol(:class)]
insert[insert(+)            keyword(elsif) ident(scan) constant(RE)operator(::)constant(Id)]
insert[insert(+)              ident(kind) operator(=) symbol(:constant)]
insert[insert(+)            keyword(elsif) ident(scan) constant(RE)operator(::)constant(PseudoClass)]
insert[insert(+)              ident(kind) operator(=) symbol(:pseudo_class)]
insert[insert(+)            keyword(elsif) ident(match) operator(=) ident(scan)operator(()constant(RE)operator(::)constant(AttributeSelector)operator(\))]
insert[insert(+)              comment(# TODO: Improve highlighting inside of attribute selectors.)]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator([)integer(0)operator(,)integer(1)operator(])operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator([)integer(1)operator(..)integer(-2)operator(])operator(,) symbol(:content)operator(]) keyword(if) ident(match)operator(.)ident(size) operator(>) integer(2)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator([)integer(-1)operator(,)integer(1)operator(])operator(,) symbol(:delimiter)operator(]) keyword(if) ident(match)operator([)integer(-1)operator(]) operator(==) integer(?])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(@media)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:directive)]
insert[insert(+)              ident(states)operator(.)ident(push) symbol(:media_before_name)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(when) symbol(:block)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content((?>)inline<inline_delimiter(#{)constant(RE)operator(::)constant(Ident)inline_delimiter(})>content(\)(?!)char(\\()content(\))delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)              keyword(if) ident(value_expected)]
insert[insert(+)                ident(kind) operator(=) symbol(:value)]
insert[insert(+)              keyword(else)]
insert[insert(+)                ident(kind) operator(=) symbol(:key)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
insert[insert(+)          keyword(when) symbol(:media_before_name)]
insert[insert(+)            keyword(if) ident(scan) constant(RE)operator(::)constant(Ident)]
insert[insert(+)              ident(kind) operator(=) symbol(:type)]
insert[insert(+)              ident(states)operator([)integer(-1)operator(]) operator(=) symbol(:media_after_name)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(when) symbol(:media_after_name)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:operator)]
insert[insert(+)              ident(states)operator([)integer(-1)operator(]) operator(=) symbol(:media)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(when) symbol(:comment)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content((?:[^*)char(\\s)content(]|)char(\\*)content((?!)char(\\/)content(\)\)+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:comment)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\*)char(\\/)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:comment)]
insert[insert(+)              ident(states)operator(.)ident(pop)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:space)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\/)char(\\*)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:comment)]
insert[insert(+)          ident(states)operator(.)ident(push) symbol(:comment)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\{)delimiter(/)>operator(\))]
insert[insert(+)          ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)          ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          ident(states)operator(.)ident(push) symbol(:block)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\})delimiter(/)>operator(\))]
insert[insert(+)          ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)          keyword(if) ident(states)operator(.)ident(last) operator(==) symbol(:block) operator(||) ident(states)operator(.)ident(last) operator(==) symbol(:media)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            ident(states)operator(.)ident(pop)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(String)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)          ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator([)integer(0)operator(,) integer(1)operator(])operator(,) symbol(:delimiter)operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator([)integer(1)operator(..)integer(-2)operator(])operator(,) symbol(:content)operator(]) keyword(if) ident(match)operator(.)ident(size) operator(>) integer(2)]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator([)integer(-1)operator(,) integer(1)operator(])operator(,) symbol(:delimiter)operator(]) keyword(if) ident(match)operator(.)ident(size) operator(>)operator(=) integer(2)]
insert[insert(+)          ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)          keyword(next)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(Function)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)          ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)          ident(start) operator(=) ident(match)operator([)regexp<delimiter(/)content(^)char(\\w)content(+)char(\\()delimiter(/)>operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(start)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)          keyword(if) ident(match)operator([)integer(-1)operator(]) operator(==) integer(?\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator([)ident(start)operator(.)ident(size)operator(..)integer(-2)operator(])operator(,) symbol(:content)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)string<delimiter(')content(\))delimiter(')>operator(,) symbol(:delimiter)operator(])]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator([)ident(start)operator(.)ident(size)operator(..)integer(-1)operator(])operator(,) symbol(:content)operator(])]
insert[insert(+)          keyword(end)]
insert[insert(+)          ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)          keyword(next)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?: )inline<inline_delimiter(#{)constant(RE)operator(::)constant(Dimension)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(RE)operator(::)constant(Percentage)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(RE)operator(::)constant(Num)inline_delimiter(})>content( \))delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:float)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(Color)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:color)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(! *important)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:important)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(rgb)char(\\()content([^(\))char(\\n)content(]*)char(\\\))content(?)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:color)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(RE)operator(::)constant(AtKeyword)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:directive)]
insert[insert(+)]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [+>:;,.=(\))char(\\/)content(] )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)          keyword(if) ident(match) operator(==) string<delimiter(')content(:)delimiter(')>]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)          keyword(elsif) ident(match) operator(==) string<delimiter(')content(;)delimiter(')>]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ident(kind) operator(=) symbol(:operator)]
insert[insert(+)]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(getch)]
insert[insert(+)          ident(kind) operator(=) symbol(:error)]
insert[insert(+)]
insert[insert(+)        keyword(end)]
insert[insert(+)]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/sql.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/sql.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/sql.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,176 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay) keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# by Josh Goebel)]
insert[insert(+)  keyword(class) class(SQL) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(register_for) symbol(:sql)]
insert[insert(+)    ]
insert[insert(+)    constant(RESERVED_WORDS) operator(=) string<delimiter(%w()>]
insert[insert(+)string<content(      all and as before begin by case collate)>]
insert[insert(+)string<content(      constraint create else end engine exists)>]
insert[insert(+)string<content(      for foreign from group if inner is join key)>]
insert[insert(+)string<content(      like not on or order outer primary references replace)>]
insert[insert(+)string<content(      then to trigger union using values when where)>]
insert[insert(+)string<content(      left)>]
insert[insert(+)string<content(    )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(OBJECTS) operator(=) string<delimiter(%w()>]
insert[insert(+)string<content(      database databases table tables column columns index)>]
insert[insert(+)string<content(    )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(COMMANDS) operator(=) string<delimiter(%w()>]
insert[insert(+)string<content(      add alter comment create delete drop grant insert into select update set)>]
insert[insert(+)string<content(      show)>]
insert[insert(+)string<content(    )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_TYPES) operator(=) string<delimiter(%w()>]
insert[insert(+)string<content(      char varchar enum binary text tinytext mediumtext)>]
insert[insert(+)string<content(      longtext blob tinyblob mediumblob longblob timestamp)>]
insert[insert(+)string<content(      date time datetime year double decimal float int)>]
insert[insert(+)string<content(      integer tinyint mediumint bigint smallint unsigned bit)>]
insert[insert(+)string<content(      bool boolean hex bin oct)>]
insert[insert(+)string<content(    )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_FUNCTIONS) operator(=) string<delimiter(%w()content( sum cast substring abs pi count min max avg )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(DIRECTIVES) operator(=) string<delimiter(%w()content( auto_increment unique default charset )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(PREDEFINED_CONSTANTS) operator(=) string<delimiter(%w()content( null true false )delimiter(\))>]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(OBJECTS)operator(,) symbol(:type)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(COMMANDS)operator(,) symbol(:class)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_TYPES)operator(,) symbol(:pre_type)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_FUNCTIONS)operator(,) symbol(:predefined)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))]
insert[insert(+)    ]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [rbfntv)char(\\n)char(\\\\)char(\\/)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} | . )delimiter(/)modifier(mx)>]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>]
insert[insert(+)    ]
insert[insert(+)    constant(STRING_PREFIXES) operator(=) regexp<delimiter(/)content([xnb]|_)char(\\w)content(+)delimiter(/)modifier(i)>]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(string_type) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(string_content) operator(=) string<delimiter(')delimiter(')>]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) ident(state) operator(==) symbol(:initial)]
insert[insert(+)          ]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(^(?:--)char(\\s)content(?|#\).*)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(%r()content( /)char(\\*)content( )content(()content(!)content(\))content(? )content(()content(?: .*? )char(\\*)content(/ | .* )content(\))content( )delimiter(\))modifier(mx)>operator(\))]
insert[insert(+)            ident(kind) operator(=) predefined_constant(self)operator([)integer(1)operator(]) operator(?) symbol(:directive) operator(:) symbol(:comment)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( [-+*)char(\\/)content(=<>;,!&^|(\))char(\\[)char(\\])content({}~%] | )char(\\.)content((?!)char(\\d)content(\) )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(()inline<inline_delimiter(#{)constant(STRING_PREFIXES)inline_delimiter(})>content(\)?([`"']\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            ident(prefix) operator(=) predefined_constant(self)operator([)integer(1)operator(])]
insert[insert(+)            ident(string_type) operator(=) predefined_constant(self)operator([)integer(2)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(prefix)operator(,) symbol(:modifier)operator(]) keyword(if) ident(prefix)]
insert[insert(+)            ident(match) operator(=) ident(string_type)]
insert[insert(+)            ident(state) operator(=) symbol(:string)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( @? [A-Za-z_][A-Za-z_0-9]* )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) ident(match)operator([)integer(0)operator(]) operator(==) integer(?@) operator(?) symbol(:variable) operator(:) constant(IDENT_KIND)operator([)ident(match)operator(.)ident(downcase)operator(])]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:hex)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(0[0-7]+(?![89.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:oct)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?>)char(\\d)content(+\)(?![.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content([fF]|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:float)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(N)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:pre_constant)]
insert[insert(+)            ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:string)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([^)char(\\\\)content("'`]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(string_content) operator(<<) ident(match)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["'`])delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(string_type) operator(==) ident(match)]
insert[insert(+)              keyword(if) ident(peek)operator(()integer(1)operator(\)) operator(==) ident(string_type)  comment(# doubling means escape)]
insert[insert(+)                ident(string_content) operator(<<) ident(string_type) operator(<<) ident(getch)]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(end)]
insert[insert(+)              keyword(unless) ident(string_content)operator(.)ident(empty?)]
insert[insert(+)                ident(tokens) operator(<<) operator([)ident(string_content)operator(,) symbol(:content)operator(])]
insert[insert(+)                ident(string_content) operator(=) string<delimiter(')delimiter(')>]
insert[insert(+)              keyword(end)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(state) operator(=) symbol(:initial)]
insert[insert(+)              ident(string_type) operator(=) predefined_constant(nil)]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(string_content) operator(<<) ident(match)]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            keyword(unless) ident(string_content)operator(.)ident(empty?)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(string_content)operator(,) symbol(:content)operator(])]
insert[insert(+)              ident(string_content) operator(=) string<delimiter(')delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( . )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(string_content) operator(<<) ident(match)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            keyword(unless) ident(string_content)operator(.)ident(empty?)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(string_content)operator(,) symbol(:content)operator(])]
insert[insert(+)              ident(string_content) operator(=) string<delimiter(')delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise) string<delimiter(')content(else-case reached)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)          ]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(unless) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ident(tokens)]
insert[insert(+)      ]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end) keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/scanners/xml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/xml.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/xml.rb)plain(	(revision 500\))]
change[change(@@)plain( -3,15 +3,14 )change(@@)]
 
   ident(load) symbol(:html)
 
delete[delete(-)  comment(# )eyecatcher<comment(XML Scanner)>]
insert[insert(+)  comment(# )eyecatcher<comment(Scanner for XML.)>]
   comment(#)
delete[delete(-)  comment(# $Id$)]
delete[delete(-)  comment(#)]
   comment(# Currently this is the same scanner as Scanners::HTML.)
   keyword(class) class(XML) operator(<) constant(HTML)
 
     ident(register_for) symbol(:xml)
delete[delete(-)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(xml)delimiter(')>]
insert[insert(+)    ]
   keyword(end)
 
 keyword(end)
head[head(Index: )plain(lib/coderay/scanners/yaml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/yaml.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/yaml.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,142 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for YAML.)]
insert[insert(+)  comment(#)]
insert[insert(+)  comment(# Based on the YAML scanner from Syntax by Jamis Buck.)]
insert[insert(+)  keyword(class) class(YAML) operator(<) constant(Scanner)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:yaml)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(yml)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) symbol(:all)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(value_expected) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(key_indent) operator(=) ident(indent) operator(=) integer(0)]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(key_indent) operator(=) predefined_constant(nil) keyword(if) ident(bol?)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( +[)char(\\t)content( ]*)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:space)]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\n)content(+)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:space)]
insert[insert(+)          ident(state) operator(=) symbol(:initial) keyword(if) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(#.*)delimiter(/)>operator(\))]
insert[insert(+)          ident(kind) operator(=) symbol(:comment)]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) ident(bol?) keyword(and) keyword(case)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(---|)char(\\.)char(\\.)char(\\.)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:head)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:head)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:head)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(%.*)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:doctype)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(elsif) ident(state) operator(==) symbol(:value) keyword(and) keyword(case)]
insert[insert(+)          keyword(when) operator(!)ident(check)operator(()regexp<delimiter(/)content((?:"[^"]*"\)(?=: |:$\))delimiter(/)>operator(\)) operator(&&) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:content)operator(]) keyword(if) ident(scan)operator(()regexp<delimiter(/)content( [^")char(\\\\)content(]* (?: )char(\\\\)content(. [^")char(\\\\)content(]* \)* )delimiter(/)modifier(mx)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:delimiter)operator(]) keyword(if) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([|>][-+]?)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(string_indent) operator(=) ident(key_indent) operator(||) ident(column)operator(()ident(pos) operator(-) ident(match)operator(.)ident(size) operator(-) integer(1)operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:content)operator(]) keyword(if) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\n)content(+ {)inline<inline_delimiter(#{)ident(string_indent) operator(+) integer(1)inline_delimiter(})>content(}.*\)+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content((?![!"*&]\).+?(?=$|)char(\\s)content(+#\))delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:string)operator(])]
insert[insert(+)            ident(string_indent) operator(=) ident(key_indent) operator(||) ident(column)operator(()ident(pos) operator(-) ident(match)operator(.)ident(size) operator(-) integer(1)operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:string)operator(]) keyword(if) ident(scan)operator(()regexp<delimiter(/)content((?:)char(\\n)content(+ {)inline<inline_delimiter(#{)ident(string_indent) operator(+) integer(1)inline_delimiter(})>content(}.*\)+)delimiter(/)>operator(\))]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(elsif) keyword(case)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([-:](?= |$\))delimiter(/)>operator(\))]
insert[insert(+)            ident(state) operator(=) symbol(:value) keyword(if) ident(state) operator(==) symbol(:colon) operator(&&) operator(()ident(match) operator(==) string<delimiter(')content(:)delimiter(')> operator(||) ident(match) operator(==) string<delimiter(')content(-)delimiter(')>operator(\))]
insert[insert(+)            ident(state) operator(=) symbol(:value) keyword(if) ident(state) operator(==) symbol(:initial) operator(&&) ident(match) operator(==) string<delimiter(')content(-)delimiter(')>]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([,{})char(\\[)char(\\])content(])delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)          keyword(when) ident(state) operator(==) symbol(:initial) operator(&&) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([)char(\\w)content(.(\) ]*)char(\\S)content((?=: |:$\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:key)]
insert[insert(+)            ident(key_indent) operator(=) ident(column)operator(()ident(pos) operator(-) ident(match)operator(.)ident(size) operator(-) integer(1)operator(\))]
insert[insert(+)            comment(# tokens << [key_indent.inspect, :debug])]
insert[insert(+)            ident(state) operator(=) symbol(:colon)]
insert[insert(+)          keyword(when) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content((?:"[^")char(\\n)content(]*"|'[^')char(\\n)content(]*'\)(?=: |:$\))delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:key)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator([)integer(0)operator(,)integer(1)operator(])operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator([)integer(1)operator(..)integer(-2)operator(])operator(,) symbol(:content)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator([)integer(-1)operator(,)integer(1)operator(])operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:key)operator(])]
insert[insert(+)            ident(key_indent) operator(=) ident(column)operator(()ident(pos) operator(-) ident(match)operator(.)ident(size) operator(-) integer(1)operator(\))]
insert[insert(+)            comment(# tokens << [key_indent.inspect, :debug])]
insert[insert(+)            ident(state) operator(=) symbol(:colon)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content((![)char(\\w)char(\\/)content(]+\)(:([)char(\\w)content(:]+\)\)?)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(1)operator(])operator(,) symbol(:type)operator(])]
insert[insert(+)            keyword(if) predefined_constant(self)operator([)integer(2)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(:)delimiter(')>operator(,) symbol(:operator)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(3)operator(])operator(,) symbol(:class)operator(])]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content(&)char(\\S)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:variable)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)char(\\*)char(\\w)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:global_variable)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content(<<)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:class_variable)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)char(\\d)char(\\d)content(:)char(\\d)char(\\d)content(:)char(\\d)char(\\d)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:oct)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)char(\\d)char(\\d)char(\\d)char(\\d)content(-)char(\\d)char(\\d)content(-)char(\\d)char(\\d)char(\\s)char(\\d)char(\\d)content(:)char(\\d)char(\\d)content(:)char(\\d)char(\\d)content(()char(\\.)char(\\d)content(+\)? [-+])char(\\d)char(\\d)content(:)char(\\d)char(\\d)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:oct)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content(:)char(\\w)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:symbol)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content([^:)char(\\s)content(]+(:(?! |$\)[^:)char(\\s)content(]*\)* .*)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(when) ident(scan)operator(()regexp<delimiter(/)content([^:)char(\\s)content(]+(:(?! |$\)[^:)char(\\s)content(]*\)*)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(getch)]
insert[insert(+)          ident(kind) operator(=) symbol(:error)]
insert[insert(+)          ]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/html.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/html.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/html.rb)plain(	(revision 500\))]
change[change(@@)plain( -2,17 +2,25 )change(@@)]
 keyword(module) class(Scanners)
 
   comment(# HTML Scanner)
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# $Id$)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Alias: +xhtml+)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# See also: Scanners::XML)]
   keyword(class) class(HTML) operator(<) constant(Scanner)
 
     ident(include) constant(Streamable)
     ident(register_for) symbol(:html)
delete[delete(-)]
delete[delete(-)    constant(ATTR_NAME) operator(=) regexp<delimiter(/)content([)char(\\w)content(.:-]+)delimiter(/)>]
delete[delete(-)    constant(ATTR_VALUE_UNQUOTED) operator(=) constant(ATTR_NAME)]
delete[delete(-)    constant(TAG_END) operator(=) regexp<delimiter(/)char(\\/)content(?>)delimiter(/)>]
delete[delete(-)    constant(HEX) operator(=) regexp<delimiter(/)content([0-9a-fA-F])delimiter(/)>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) operator([)]
insert[insert(+)      symbol(:comment)operator(,) symbol(:doctype)operator(,) symbol(:preprocessor)operator(,)]
insert[insert(+)      symbol(:tag)operator(,) symbol(:attribute_name)operator(,) symbol(:operator)operator(,)]
insert[insert(+)      symbol(:attribute_value)operator(,) symbol(:delimiter)operator(,) symbol(:content)operator(,)]
insert[insert(+)      symbol(:plain)operator(,) symbol(:entity)operator(,) symbol(:error)operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(ATTR_NAME) operator(=) regexp<delimiter(/)content([)char(\\w)content(.:-]+)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)    constant(TAG_END) operator(=) regexp<delimiter(/)char(\\/)content(?>)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)    constant(HEX) operator(=) regexp<delimiter(/)content([0-9a-fA-F])delimiter(/)>  comment(# :nodoc:)]
     constant(ENTITY) operator(=) regexp<delimiter(/)>
regexp<content(       &)>
regexp<content(       (?:)>
change[change(@@)plain( -26,19 +34,21 )change(@@)]
         operator(\))
       operator(\))
       operator(;)
delete[delete(-)    regexp<delimiter(/)content(ox)>]
delete[delete(-)regexp<>]
insert[insert(+)    regexp<delimiter(/)content(ox)>eyecatcher<regexp<content(  # :nodoc:)>>]
insert[insert(+)regexp<>eyecatcher<regexp<content(    )>>]
regexp<content(     PLAIN_STRING_CONTENT = {)>
regexp<content(       "'" => )delimiter(/)>operator([)operator(^)operator(&)string<delimiter(')content(>)content(\\n)content(]+/,)>
string<content(       )delimiter(')>string<delimiter(")content(' => /[^&)delimiter(")>operator(>)error(\\)ident(n)operator(])operator(+)regexp<delimiter(/)content(,)>
delete[delete(-)regexp<content(    })>]
delete[delete(-)]
delete[delete(-)regexp<content(    def reset)>]
insert[insert(+)regexp<content(    }  # :nodoc:)>]
insert[insert(+)regexp<content(    )>]
insert[insert(+)regexp<content(    def reset  # :nodoc:)>]
insert[insert(+)regexp<content(      # FIXME: why not overwrite reset_instance?)>]
regexp<content(       super)>
regexp<content(       @state = :initial)>
regexp<content(     end)>
delete[delete(-)]
delete[delete(-)regexp<content(  private)>]
insert[insert(+)regexp<content(    )>]
insert[insert(+)regexp<content(  protected)>]
insert[insert(+)regexp<content(    )>]
regexp<content(     def setup)>
regexp<content(       @state = :initial)>
regexp<content(       @plain_string_content = nil)>
change[change(@@)plain( -65,14 +75,14 )change(@@)]
             keyword(if) ident(scan)operator(()regexp<delimiter(/)content(<!--.*?-->)delimiter(/)modifier(m)>operator(\))
               ident(kind) operator(=) symbol(:comment)
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(<!DOCTYPE.*?>)delimiter(/)modifier(m)>operator(\))
delete[delete(-)              ident(kind) operator(=) symbol(:)eyecatcher<symbol(preprocessor)>]
insert[insert(+)              ident(kind) operator(=) symbol(:)eyecatcher<symbol(doctype)>]
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(<)char(\\?)content(xml.*?)char(\\?)content(>)delimiter(/)modifier(m)>operator(\))
               ident(kind) operator(=) symbol(:preprocessor)
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(<)char(\\?)content(.*?)char(\\?)content(>|<%.*?%>)delimiter(/)modifier(m)>operator(\))
               ident(kind) operator(=) symbol(:comment)
delete[delete(-)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(<)char(\\/)content([-)char(\\w)>eyecatcher<regexp<content(_)>>regexp<content(.:]*>)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(<)char(\\/)content([-)char(\\w)>regexp<content(.:]*>)delimiter(/)modifier(m)>operator(\))]
               ident(kind) operator(=) symbol(:tag)
delete[delete(-)            keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<[-)char(\\w)>eyecatcher<regexp<content(_)>>regexp<content(.:]+>?)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<[-)char(\\w)>regexp<content(.:]+>?)delimiter(/)modifier(m)>operator(\))]
               ident(kind) operator(=) symbol(:tag)
               ident(state) operator(=) symbol(:attribute) keyword(unless) ident(match)operator([)integer(-1)operator(]) operator(==) integer(?>)
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content([^<>&]+)delimiter(/)>operator(\))
change[change(@@)plain( -112,7 +122,7 )change(@@)]
             keyword(end)
 
           keyword(when) symbol(:attribute_value)
delete[delete(-)            keyword(if) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(ATTR_)>>eyecatcher<regexp<inline<constant(VALUE_UNQUOTED)>>>regexp<inline<inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(ATTR_)>>eyecatcher<regexp<inline<constant(NAME)>>>regexp<inline<inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
               ident(kind) operator(=) symbol(:attribute_value)
               ident(state) operator(=) symbol(:attribute)
             keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["'])delimiter(/)>operator(\))
change[change(@@)plain( -154,7 +164,7 )change(@@)]
         keyword(end)
 
         ident(match) operator(||=) ident(matched)
delete[delete(-)        keyword(if) global_variable($)global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)        keyword(if) global_variable($)eyecatcher<global_variable(CODERAY_)>global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
           ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
             operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)
         keyword(end)
head[head(Index: )plain(lib/coderay/scanners/scheme.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/scheme.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/scheme.rb)plain(	(revision 500\))]
change[change(@@)plain( -2,72 +2,77 )change(@@)]
   keyword(module) class(Scanners)
 
     comment(# Scheme scanner for CodeRay (by closure\).)
insert[insert(+)    comment(# )]
     comment(# Thanks to murphy for putting CodeRay into public.)
     keyword(class) class(Scheme) operator(<) constant(Scanner)
       
insert[insert(+)      comment(# TODO: function defs)]
insert[insert(+)      comment(# TODO: built-in functions)]
insert[insert(+)      ]
       ident(register_for) symbol(:scheme)
delete[delete(-)      ident(file_extension) eyecatcher<symbol(:scm)>]
insert[insert(+)      ident(file_extension) string<>eyecatcher<string<delimiter(')content(scm)delimiter(')>>]
 
       constant(CORE_FORMS) operator(=) string<delimiter(%w[)>
string<content(         lambda let let* letrec syntax-case define-syntax let-syntax)>
string<content(         letrec-syntax begin define quote if or and cond case do delay)>
string<content(         quasiquote set! cons force call-with-current-continuation call/cc)>
delete[delete(-)string<content(      )delimiter(])>]
delete[delete(-)]
insert[insert(+)string<content(      )delimiter(])>eyecatcher<  comment(# :nodoc:)>]
insert[insert(+)eyecatcher<      >]
       constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)
delete[delete(-)        ident(add)operator(()constant(CORE_FORMS)operator(,) symbol(:reserved)operator(\))]
insert[insert(+)        ident(add)operator(()constant(CORE_FORMS)operator(,) symbol(:reserved)operator(\))eyecatcher<  comment(# :nodoc:)>]
       
       comment(#IDENTIFIER_INITIAL = /[a-z!@\\$%&\\*\\/\\:<=>\\?~_\\^]/i)
       comment(#IDENTIFIER_SUBSEQUENT = /#{IDENTIFIER_INITIAL}|\\d|\\.|\\+|-/)
       comment(#IDENTIFIER = /#{IDENTIFIER_INITIAL}#{IDENTIFIER_SUBSEQUENT}*|\\+|-|\\.{3}/)
delete[delete(-)      constant(IDENTIFIER) operator(=) regexp<delimiter(/)content([a-zA-Z!@$%&*)char(\\/)content(:<=>?~_^][)char(\\w)content(!@$%&*)char(\\/)content(:<=>?~^.+)char(\\-)content(]*|[+-]|)char(\\.)char(\\.)char(\\.)delimiter(/)>]
delete[delete(-)      constant(DIGIT) operator(=) regexp<delimiter(/)char(\\d)delimiter(/)>]
delete[delete(-)      constant(DIGIT10) operator(=) constant(DIGIT)]
delete[delete(-)      constant(DIGIT16) operator(=) regexp<delimiter(/)content([0-9a-f])delimiter(/)modifier(i)>]
delete[delete(-)      constant(DIGIT8) operator(=) regexp<delimiter(/)content([0-7])delimiter(/)>]
delete[delete(-)      constant(DIGIT2) operator(=) regexp<delimiter(/)content([01])delimiter(/)>]
delete[delete(-)      constant(RADIX16) operator(=) regexp<delimiter(/)char(\\#)content(x)delimiter(/)modifier(i)>]
delete[delete(-)      constant(RADIX8) operator(=) regexp<delimiter(/)char(\\#)content(o)delimiter(/)modifier(i)>]
delete[delete(-)      constant(RADIX2) operator(=) regexp<delimiter(/)char(\\#)content(b)delimiter(/)modifier(i)>]
delete[delete(-)      constant(RADIX10) operator(=) regexp<delimiter(/)char(\\#)content(d)delimiter(/)modifier(i)>]
delete[delete(-)      constant(EXACTNESS) operator(=) regexp<delimiter(/)content(#i|#e)delimiter(/)modifier(i)>]
delete[delete(-)      constant(SIGN) operator(=) regexp<delimiter(/)content([)char(\\+)content(-]?)delimiter(/)>]
delete[delete(-)      constant(EXP_MARK) operator(=) regexp<delimiter(/)content([esfdl])delimiter(/)modifier(i)>]
delete[delete(-)      constant(EXP) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP_MARK)inline_delimiter(})>inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(DIGIT)inline_delimiter(})>content(+)delimiter(/)>]
delete[delete(-)      constant(SUFFIX) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>content(?)delimiter(/)>]
delete[delete(-)      constant(PREFIX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)delimiter(/)>]
delete[delete(-)      constant(PREFIX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(PREFIX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(PREFIX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(UINT10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)delimiter(/)>]
delete[delete(-)      constant(UINT16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT16)inline_delimiter(})>content(+#*)delimiter(/)>]
delete[delete(-)      constant(UINT8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT8)inline_delimiter(})>content(+#*)delimiter(/)>]
delete[delete(-)      constant(UINT2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT2)inline_delimiter(})>content(+#*)delimiter(/)>]
delete[delete(-)      constant(DECIMAL) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#+)char(\\.)content(#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(*#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(UREAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(UREAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(UREAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(UREAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(REAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(REAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(REAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(REAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(IMAG10) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>content(i)delimiter(/)>]
delete[delete(-)      constant(IMAG16) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>content(i)delimiter(/)>]
delete[delete(-)      constant(IMAG8) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>content(i)delimiter(/)>]
delete[delete(-)      constant(IMAG2) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>content(i)delimiter(/)>]
delete[delete(-)      constant(COMPLEX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(COMPLEX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(COMPLEX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(COMPLEX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(NUM10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(COMPLEX10)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(NUM16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX16)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(NUM8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX8)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(NUM2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)      constant(NUM) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NUM10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM2)inline_delimiter(})>delimiter(/)>]
delete[delete(-)    ]
delete[delete(-)    ident(private)]
delete[delete(-)      keyword(def) method(scan_tokens) ident(tokens)operator(,)ident(options)]
insert[insert(+)      constant(IDENTIFIER) operator(=) regexp<delimiter(/)content([a-zA-Z!@$%&*)char(\\/)content(:<=>?~_^][)char(\\w)content(!@$%&*)char(\\/)content(:<=>?~^.+)char(\\-)content(]*|[+-]|)char(\\.)char(\\.)char(\\.)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(DIGIT) operator(=) regexp<delimiter(/)char(\\d)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(DIGIT10) operator(=) regexp<delimiter(/)char(\\d)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(DIGIT16) operator(=) regexp<delimiter(/)content([0-9a-f])delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(DIGIT8) operator(=) regexp<delimiter(/)content([0-7])delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(DIGIT2) operator(=) regexp<delimiter(/)content([01])delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(RADIX16) operator(=) regexp<delimiter(/)char(\\#)content(x)delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(RADIX8) operator(=) regexp<delimiter(/)char(\\#)content(o)delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(RADIX2) operator(=) regexp<delimiter(/)char(\\#)content(b)delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(RADIX10) operator(=) regexp<delimiter(/)char(\\#)content(d)delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(EXACTNESS) operator(=) regexp<delimiter(/)content(#i|#e)delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(SIGN) operator(=) regexp<delimiter(/)content([)char(\\+)content(-]?)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(EXP_MARK) operator(=) regexp<delimiter(/)content([esfdl])delimiter(/)modifier(i)>  comment(# :nodoc:)]
insert[insert(+)      constant(EXP) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP_MARK)inline_delimiter(})>inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(DIGIT)inline_delimiter(})>content(+)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(SUFFIX) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>content(?)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(PREFIX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(PREFIX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(PREFIX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(PREFIX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UINT10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UINT16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT16)inline_delimiter(})>content(+#*)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UINT8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT8)inline_delimiter(})>content(+#*)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UINT2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT2)inline_delimiter(})>content(+#*)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(DECIMAL) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#+)char(\\.)content(#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(*#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UREAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UREAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UREAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(UREAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(REAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(REAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(REAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(REAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(IMAG10) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>content(i)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(IMAG16) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>content(i)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(IMAG8) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>content(i)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(IMAG2) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>content(i)delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(COMPLEX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(COMPLEX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(COMPLEX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(COMPLEX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(NUM10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(COMPLEX10)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(NUM16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX16)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(NUM8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX8)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(NUM2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      constant(NUM) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NUM10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM2)inline_delimiter(})>delimiter(/)>  comment(# :nodoc:)]
insert[insert(+)      ]
insert[insert(+)    ident(protected)]
insert[insert(+)      ]
insert[insert(+)      keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
         
         ident(state) operator(=) symbol(:initial)
         ident(ident_kind) operator(=) constant(IDENT_KIND)
change[change(@@)plain( -80,7 +85,7 )change(@@)]
             keyword(if) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))
               ident(kind) operator(=) symbol(:space)
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content([')char(\\()char(\\[)char(\\\))char(\\])content(]|#)char(\\()delimiter(/)>operator(\))
delete[delete(-)              ident(kind) operator(=) symbol(:operator)symbol(_fat)]
insert[insert(+)              ident(kind) operator(=) symbol(:operator)eyecatcher<  comment(# FIXME: was :operator)>comment(_fat)]
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(;.*)delimiter(/)>operator(\))
               ident(kind) operator(=) symbol(:comment)
             keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#)char(\\\\)content((?:newline|space|.?\))delimiter(/)>operator(\))
change[change(@@)plain( -120,15 +125,15 )change(@@)]
           keyword(end)
           
           ident(match) operator(||=) ident(matched)
delete[delete(-)          keyword(if) global_variable($)global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          keyword(if) global_variable($)eyecatcher<global_variable(CODERAY_)>global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
             ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
delete[delete(-)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)            eyecatcher<  >operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
           keyword(end)
           ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens)operator(,) ident(state) keyword(unless) ident(match)
           
           ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
           
delete[delete(-)        keyword(end)eyecatcher<  comment(# until eos)>]
insert[insert(+)        keyword(end)]
         
         keyword(if) ident(state) operator(==) symbol(:string)
           ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])
change[change(@@)plain( -136,7 +141,7 )change(@@)]
         
         ident(tokens)
         
delete[delete(-)      keyword(end) comment(#scan_tokens)]
delete[delete(-)    keyword(end) comment(#class)]
delete[delete(-)  keyword(end) comment(#module scanners)]
delete[delete(-)keyword(end) comment(#module coderay)]
comment(\\ No newline at end of file)
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)  keyword(end)]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/scanners/java_script.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/java_script.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/java_script.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,229 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for JavaScript.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Aliases: +ecmascript+, +ecma_script+, +javascript+)]
insert[insert(+)  keyword(class) class(JavaScript) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)]
insert[insert(+)    ident(register_for) symbol(:java_script)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(js)delimiter(')>]
insert[insert(+)]
insert[insert(+)    comment(# The actual JavaScript keywords.)]
insert[insert(+)    constant(KEYWORDS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      break case catch continue default delete do else)>]
insert[insert(+)string<content(      finally for function if in instanceof new)>]
insert[insert(+)string<content(      return switch throw try typeof var void while with)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    constant(PREDEFINED_CONSTANTS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      false null true undefined NaN Infinity)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(MAGIC_VARIABLES) operator(=) string<delimiter(%w[)content( this arguments )delimiter(])>  comment(# :nodoc: arguments was introduced in JavaScript 1.4)]
insert[insert(+)    ]
insert[insert(+)    constant(KEYWORDS_EXPECTING_VALUE) operator(=) constant(WordList)operator(.)ident(new)operator(.)ident(add) string<delimiter(%w[)>]
insert[insert(+)string<content(      case delete in instanceof new return throw typeof with)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    comment(# Reserved for future use.)]
insert[insert(+)    constant(RESERVED_WORDS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(      abstract boolean byte char class debugger double enum export extends)>]
insert[insert(+)string<content(      final float goto implements import int interface long native package)>]
insert[insert(+)string<content(      private protected public short static super synchronized throws transient)>]
insert[insert(+)string<content(      volatile)>]
insert[insert(+)string<content(    )delimiter(])>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(PREDEFINED_CONSTANTS)operator(,) symbol(:pre_constant)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(MAGIC_VARIABLES)operator(,) symbol(:local_variable)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()constant(KEYWORDS)operator(,) symbol(:keyword)operator(\))  comment(# :nodoc:)]
insert[insert(+)]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [bfnrtv)char(\\n)char(\\\\)content('"] | x[a-fA-F0-9]{1,2} | [0-7]{1,3} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} | U[a-fA-F0-9]{8} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(REGEXP_ESCAPE) operator(=)  regexp<delimiter(/)content( [bBdDsSwW] )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(STRING_CONTENT_PATTERN) operator(=) operator({)]
insert[insert(+)      string<delimiter(")content(')delimiter(")> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content(']+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(")delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)content("]+)delimiter(/)>operator(,)]
insert[insert(+)      string<delimiter(')content(/)delimiter(')> operator(=)operator(>) regexp<delimiter(/)content([^)char(\\\\)char(\\/)content(]+)delimiter(/)>operator(,)]
insert[insert(+)    operator(})  comment(# :nodoc:)]
insert[insert(+)    constant(KEY_CHECK_PATTERN) operator(=) operator({)]
insert[insert(+)      string<delimiter(")content(')delimiter(")> operator(=)operator(>) regexp<delimiter(/)content( [^)char(\\\\)content(']* (?: )char(\\\\)content(.? [^)char(\\\\)content(']* \)* '? )char(\\s)content(* : )delimiter(/)modifier(x)>operator(,)]
insert[insert(+)      string<delimiter(')content(")delimiter(')> operator(=)operator(>) regexp<delimiter(/)content( [^)char(\\\\)content("]* (?: )char(\\\\)content(.? [^)char(\\\\)content("]* \)* "? )char(\\s)content(* : )delimiter(/)modifier(x)>operator(,)]
insert[insert(+)    operator(})  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)      ident(key_expected) operator(=) predefined_constant(false)]
insert[insert(+)      ident(function_expected) operator(=) predefined_constant(false)]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true) keyword(if) operator(!)ident(value_expected) operator(&&) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)char(\\\\)content(]* (?: )char(\\\\)content(. [^)char(\\n)char(\\\\)content(]* \)* | /)char(\\*)content( (?: .*? )char(\\*)content(/ | .* \) )delimiter(!)modifier(mx)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(check)operator(()regexp<delimiter(/)char(\\.)content(?)char(\\d)delimiter(/)>operator(\))]
insert[insert(+)            ident(key_expected) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content(0[xX][0-9A-Fa-f]+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:hex)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((?>0[0-7]+\)(?![89.eEfF]\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:oct)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+[fF]|)char(\\d)content(*)char(\\.)char(\\d)content(+(?:[eE][+-]?)char(\\d)content(+\)?[fF]?|)char(\\d)content(+[eE][+-]?)char(\\d)content(+[fF]?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:float)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\d)content(+)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(end)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(value_expected) operator(&&) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<([[:alpha:]])char(\\w)content(*\) (?: [^)char(\\/)content(>]*)char(\\/)content(> | .*?<)char(\\/)char(\\1)content(>\))delimiter(/)modifier(xim)>operator(\))]
insert[insert(+)            comment(# FIXME: scan over nested tags)]
insert[insert(+)            ident(xml_scanner)operator(.)ident(tokenize) ident(match)]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(next)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [-+*=<>?:;,!&^|()char(\\[)content({~%]+ | )char(\\.)content((?!)char(\\d)content(\) )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(last_operator) operator(=) ident(match)operator([)integer(-1)operator(])]
insert[insert(+)            ident(key_expected) operator(=) operator(()ident(last_operator) operator(==) integer(?{)operator(\)) operator(||) operator(()ident(last_operator) operator(==) integer(?,)operator(\))]
insert[insert(+)            ident(function_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( [\))char(\\])content(}]+ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(function_expected) operator(=) ident(key_expected) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [$a-zA-Z_][A-Za-z_0-9$]* )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            ident(value_expected) operator(=) operator(()ident(kind) operator(==) symbol(:keyword)operator(\)) operator(&&) constant(KEYWORDS_EXPECTING_VALUE)operator([)ident(match)operator(])]
insert[insert(+)            comment(# TODO: labels)]
insert[insert(+)            keyword(if) ident(kind) operator(==) symbol(:ident)]
insert[insert(+)              keyword(if) ident(match)operator(.)ident(index)operator(()integer(?$)operator(\))  comment(# $ allowed inside an identifier)]
insert[insert(+)                ident(kind) operator(=) symbol(:predefined)]
insert[insert(+)              keyword(elsif) ident(function_expected)]
insert[insert(+)                ident(kind) operator(=) symbol(:function)]
insert[insert(+)              keyword(elsif) ident(check)operator(()regexp<delimiter(/)char(\\s)content(*[=:])char(\\s)content(*function)char(\\b)delimiter(/)>operator(\))]
insert[insert(+)                ident(kind) operator(=) symbol(:function)]
insert[insert(+)              keyword(elsif) ident(key_expected) operator(&&) ident(check)operator(()regexp<delimiter(/)char(\\s)content(*:)delimiter(/)>operator(\))]
insert[insert(+)                ident(kind) operator(=) symbol(:key)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(function_expected) operator(=) operator(()ident(kind) operator(==) symbol(:keyword)operator(\)) operator(&&) operator(()ident(match) operator(==) string<delimiter(')content(function)delimiter(')>operator(\))]
insert[insert(+)            ident(key_expected) operator(=) predefined_constant(false)]
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["'])delimiter(/)>operator(\))]
insert[insert(+)            keyword(if) ident(key_expected) operator(&&) ident(check)operator(()constant(KEY_CHECK_PATTERN)operator([)ident(match)operator(])operator(\))]
insert[insert(+)              ident(state) operator(=) symbol(:key)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(state) operator(=) symbol(:string)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) ident(state)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) ident(match)]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(value_expected) operator(&&) operator(()ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\/)content((?=)char(\\S)content(\))delimiter(/)>operator(\))operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:regexp)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:regexp)]
insert[insert(+)            ident(string_delimiter) operator(=) string<delimiter(')content(/)delimiter(')>]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\/)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)            ident(key_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(when) symbol(:string)operator(,) symbol(:regexp)operator(,) symbol(:key)]
insert[insert(+)          keyword(if) ident(scan)operator(()constant(STRING_CONTENT_PATTERN)operator([)ident(string_delimiter)operator(])operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(["')char(\\/)content(])delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            keyword(if) ident(state) operator(==) symbol(:regexp)]
insert[insert(+)              ident(modifiers) operator(=) ident(scan)operator(()regexp<delimiter(/)content([gim]+)delimiter(/)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(modifiers)operator(,) symbol(:modifier)operator(]) keyword(if) ident(modifiers) operator(&&) operator(!)ident(modifiers)operator(.)ident(empty?)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)            ident(key_expected) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(state) operator(!=) symbol(:regexp) operator(&&) operator(()ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))operator(\))]
insert[insert(+)            keyword(if) ident(string_delimiter) operator(==) string<delimiter(")content(')delimiter(")> operator(&&) operator(!)operator(()ident(match) operator(==) string<delimiter(")char(\\\\)char(\\\\)delimiter(")> operator(||) ident(match) operator(==) string<delimiter(")char(\\\\)content(')delimiter(")>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(kind) operator(=) symbol(:char)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(state) operator(==) symbol(:regexp) operator(&&) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(REGEXP_ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(key_expected) operator(=) ident(value_expected) operator(=) predefined_constant(false)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)]
insert[insert(+)        keyword(end)]
insert[insert(+)]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(if) operator([)symbol(:string)operator(,) symbol(:regexp)operator(])operator(.)ident(include?) ident(state)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  ident(protected)]
insert[insert(+)]
insert[insert(+)    keyword(def) method(reset_instance)]
insert[insert(+)      keyword(super)]
insert[insert(+)      instance_variable(@xml_scanner)operator(.)ident(reset) keyword(if) keyword(defined?) instance_variable(@xml_scanner)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    keyword(def) method(xml_scanner)]
insert[insert(+)      instance_variable(@xml_scanner) operator(||=) constant(CodeRay)operator(.)ident(scanner) symbol(:xml)operator(,) symbol(:tokens) operator(=)operator(>) instance_variable(@tokens)operator(,) symbol(:keep_tokens) operator(=)operator(>) predefined_constant(true)operator(,) symbol(:keep_state) operator(=)operator(>) predefined_constant(false)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/delphi.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/delphi.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/delphi.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,9 +1,13 )change(@@)]
 keyword(module) class(CodeRay)
 keyword(module) class(Scanners)
   
insert[insert(+)  comment(# Scanner for the Delphi language (Object Pascal\).)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Alias: +pascal+)]
   keyword(class) class(Delphi) operator(<) constant(Scanner)
delete[delete(-)]
insert[insert(+)eyecatcher<    >]
     ident(register_for) symbol(:delphi)
insert[insert(+)    ident(file_extension) string<delimiter(')content(pas)delimiter(')>]
     
     constant(RESERVED_WORDS) operator(=) operator([)
       string<delimiter(')content(and)delimiter(')>operator(,) string<delimiter(')content(array)delimiter(')>operator(,) string<delimiter(')content(as)delimiter(')>operator(,) string<delimiter(')content(at)delimiter(')>operator(,) string<delimiter(')content(asm)delimiter(')>operator(,) string<delimiter(')content(at)delimiter(')>operator(,) string<delimiter(')content(begin)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(class)delimiter(')>operator(,)
change[change(@@)plain( -15,9 +19,9 )change(@@)]
       string<delimiter(')content(procedure)delimiter(')>operator(,) string<delimiter(')content(program)delimiter(')>operator(,) string<delimiter(')content(property)delimiter(')>operator(,) string<delimiter(')content(raise)delimiter(')>operator(,) string<delimiter(')content(record)delimiter(')>operator(,) string<delimiter(')content(repeat)delimiter(')>operator(,)
       string<delimiter(')content(resourcestring)delimiter(')>operator(,) string<delimiter(')content(set)delimiter(')>operator(,) string<delimiter(')content(shl)delimiter(')>operator(,) string<delimiter(')content(shr)delimiter(')>operator(,) string<delimiter(')content(string)delimiter(')>operator(,) string<delimiter(')content(then)delimiter(')>operator(,) string<delimiter(')content(threadvar)delimiter(')>operator(,)
       string<delimiter(')content(to)delimiter(')>operator(,) string<delimiter(')content(try)delimiter(')>operator(,) string<delimiter(')content(type)delimiter(')>operator(,) string<delimiter(')content(unit)delimiter(')>operator(,) string<delimiter(')content(until)delimiter(')>operator(,) string<delimiter(')content(uses)delimiter(')>operator(,) string<delimiter(')content(var)delimiter(')>operator(,) string<delimiter(')content(while)delimiter(')>operator(,) string<delimiter(')content(with)delimiter(')>operator(,)
delete[delete(-)      string<delimiter(')content(xor)delimiter(')>operator(,) string<delimiter(')content(on)delimiter(')>]
delete[delete(-)    operator(])]
delete[delete(-)]
insert[insert(+)      string<delimiter(')content(xor)delimiter(')>operator(,) string<delimiter(')content(on)delimiter(')>eyecatcher<operator(,)>]
insert[insert(+)    operator(])eyecatcher<  comment(# :nodoc:)>]
insert[insert(+)eyecatcher<    >]
     constant(DIRECTIVES) operator(=) operator([)
       string<delimiter(')content(absolute)delimiter(')>operator(,) string<delimiter(')content(abstract)delimiter(')>operator(,) string<delimiter(')content(assembler)delimiter(')>operator(,) string<delimiter(')content(at)delimiter(')>operator(,) string<delimiter(')content(automated)delimiter(')>operator(,) string<delimiter(')content(cdecl)delimiter(')>operator(,)
       string<delimiter(')content(contains)delimiter(')>operator(,) string<delimiter(')content(deprecated)delimiter(')>operator(,) string<delimiter(')content(dispid)delimiter(')>operator(,) string<delimiter(')content(dynamic)delimiter(')>operator(,) string<delimiter(')content(export)delimiter(')>operator(,)
change[change(@@)plain( -26,19 +30,20 )change(@@)]
       string<delimiter(')content(package)delimiter(')>operator(,) string<delimiter(')content(pascal)delimiter(')>operator(,) string<delimiter(')content(platform)delimiter(')>operator(,) string<delimiter(')content(private)delimiter(')>operator(,) string<delimiter(')content(protected)delimiter(')>operator(,) string<delimiter(')content(public)delimiter(')>operator(,)
       string<delimiter(')content(published)delimiter(')>operator(,) string<delimiter(')content(read)delimiter(')>operator(,) string<delimiter(')content(readonly)delimiter(')>operator(,) string<delimiter(')content(register)delimiter(')>operator(,) string<delimiter(')content(reintroduce)delimiter(')>operator(,)
       string<delimiter(')content(requires)delimiter(')>operator(,) string<delimiter(')content(resident)delimiter(')>operator(,) string<delimiter(')content(safecall)delimiter(')>operator(,) string<delimiter(')content(stdcall)delimiter(')>operator(,) string<delimiter(')content(stored)delimiter(')>operator(,) string<delimiter(')content(varargs)delimiter(')>operator(,)
delete[delete(-)      string<delimiter(')content(virtual)delimiter(')>operator(,) string<delimiter(')content(write)delimiter(')>operator(,) string<delimiter(')content(writeonly)delimiter(')>]
delete[delete(-)    operator(])]
delete[delete(-)]
delete[delete(-)    constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)eyecatcher<operator(,) ident(caching)operator(=)predefined_constant(true)>operator(\))operator(.)]
insert[insert(+)      string<delimiter(')content(virtual)delimiter(')>operator(,) string<delimiter(')content(write)delimiter(')>operator(,) string<delimiter(')content(writeonly)delimiter(')>eyecatcher<operator(,)>]
insert[insert(+)    operator(])eyecatcher<  comment(# :nodoc:)>]
insert[insert(+)eyecatcher<    >]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
       ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
delete[delete(-)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))]
insert[insert(+)      ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))eyecatcher<  comment(# :nodoc:)>]
     
delete[delete(-)    constant(NAME_FOLLOWS) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()predefined_constant(false)operator(,) ident(caching)operator(=)predefined_constant(true)operator(\))operator(.)]
delete[delete(-)      ident(add)operator(()string<delimiter(%w()content(procedure function .)delimiter(\))>operator(\))]
delete[delete(-)]
delete[delete(-)  ident(private)]
insert[insert(+)    constant(NAME_FOLLOWS) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()predefined_constant(false)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()string<delimiter(%w()content(procedure function .)delimiter(\))>operator(\))  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
delete[delete(-)]
insert[insert(+)eyecatcher<      >]
       ident(state) operator(=) symbol(:initial)
       ident(last_token) operator(=) string<delimiter(')delimiter(')>
 
change[change(@@)plain( -129,7 +134,7 )change(@@)]
         keyword(end)
         
         ident(match) operator(||=) ident(matched)
delete[delete(-)        keyword(if) global_variable($)global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)        keyword(if) global_variable($)eyecatcher<global_variable(CODERAY_)>global_variable(DEBUG) keyword(and) keyword(not) ident(kind)]
           ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
             operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)
         keyword(end)
head[head(Index: )plain(lib/coderay/scanners/nitro_xhtml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/nitro_xhtml.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/nitro_xhtml.rb)plain(	(revision 500\))]
change[change(@@)plain( -5,13 +5,17 )change(@@)]
   ident(load) symbol(:ruby)
 
   comment(# Nitro XHTML Scanner)
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# )eyecatcher<comment($Id$)>]
insert[insert(+)  comment(#)eyecatcher<comment( )>]
insert[insert(+)  comment(# )eyecatcher<comment(Alias: +nitro+)>]
   keyword(class) class(NitroXHTML) operator(<) constant(Scanner)
 
     ident(include) constant(Streamable)
     ident(register_for) symbol(:nitro_xhtml)
delete[delete(-)]
insert[insert(+)    ident(file_extension) symbol(:xhtml)]
insert[insert(+)    ident(title) string<delimiter(')content(Nitro XHTML)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) constant(HTML)operator(::)constant(KINDS_NOT_LOC)]
insert[insert(+)    ]
     constant(NITRO_RUBY_BLOCK) operator(=) regexp<delimiter(/)>
regexp<content(       <)char(\\?)content(r)>
regexp<content(       (?>)>
change[change(@@)plain( -33,7 +37,7 )change(@@)]
         operator(()integer(?>) operator(%)operator(()integer(?!)operator(>)operator(\)) operator([)operator(^)string<delimiter(%])content(* \)*)>
string<content(       \))>
string<content(       (?: %> \)?)>
delete[delete(-)string<content(    /mx)>]
insert[insert(+)string<content(    /mx)>eyecatcher<string<content(  # :nodoc:)>>]
string<content( )>
string<content(     NITRO_VALUE_BLOCK = /)>
string<content(       )char(\\#)>
change[change(@@)plain( -50,28 +54,27 )change(@@)]
       operator(|) error(\\)operator([) operator([)operator(^)error(\\)operator(])operator(])operator(*) error(\\)operator(])operator(?)
       operator(|) error(\\)error(\\) operator([)operator(^)error(\\)error(\\)operator(])operator(*) error(\\)error(\\)operator(?)
       operator(\))
delete[delete(-)    regexp<delimiter(/)content(x)>]
insert[insert(+)    regexp<delimiter(/)content(x)>eyecatcher<regexp<content(  # :nodoc:)>>]
regexp<content( )>
regexp<content(     NITRO_ENTITY = )delimiter(/)>
       string<delimiter(% )content((?:)delimiter( )>error(\\)comment(#\\d+ | \\w+ \) ;)
delete[delete(-)    regexp<delimiter(/)>]
insert[insert(+)    regexp<delimiter(/)>eyecatcher<regexp<content(  # :nodoc:)>>]
regexp<content( )>
regexp<content(     START_OF_RUBY = )delimiter(/)>
       operator(()integer(?=)operator([)operator(<)error(\\)comment(#%]\))
       operator(<) operator(()integer(?:) error(\\)operator(?)ident(r) operator(|) string<delimiter(% )content(|)delimiter( )>ident(ruby)operator(>) operator(\))
     operator(|) error(\\)comment(# [{(|])
     operator(|) string<delimiter(% )content((?:)delimiter( )>error(\\)comment(#\\d+ | \\w+ \) ;)
delete[delete(-)    regexp<delimiter(/)content(x)>]
insert[insert(+)    regexp<delimiter(/)content(x)>eyecatcher<regexp<content(  # :nodoc:)>>]
regexp<content( )>
delete[delete(-)regexp<content(    CLOSING_PAREN = Hash.new do |h, p|)>]
delete[delete(-)regexp<content(      h[p] = p)>]
delete[delete(-)regexp<content(    end.update( {)>]
insert[insert(+)regexp<content(    CLOSING_PAREN = Hash.new { |h, p| h[p] = p }  # :nodoc:)>]
insert[insert(+)regexp<content(    CLOSING_PAREN.update( {)>]
regexp<content(       '(' => '\)',)>
regexp<content(       '[' => ']',)>
regexp<content(       '{' => '}',)>
regexp<content(     } \))>
regexp<content( )>
delete[delete(-)regexp<content(  pr)>eyecatcher<regexp<content(ivate)>>]
insert[insert(+)regexp<content(  pr)>eyecatcher<regexp<content(otected)>>]
regexp<content( )>
regexp<content(     def setup)>
regexp<content(       @ruby_scanner = CodeRay.scanner :ruby, :tokens => @tokens, :keep_tokens => true)>
change[change(@@)plain( -119,6 +122,7 )change(@@)]
 
         keyword(else)
           ident(raise_inspect) string<delimiter(')content(else-case reached!)delimiter(')>operator(,) ident(tokens)
insert[insert(+)          ]
         keyword(end)
 
       keyword(end)
head[head(Index: )plain(lib/coderay/scanners/plaintext.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/plaintext.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/plaintext.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,15 +1,24 )change(@@)]
 keyword(module) class(CodeRay)
 keyword(module) class(Scanners)
delete[delete(-)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for plain text.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Yields just one token of the kind :plain.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Alias: +plain+)]
   keyword(class) class(Plaintext) operator(<) constant(Scanner)
 
     ident(register_for) symbol(:plaintext)operator(,) symbol(:plain)
insert[insert(+)    ident(title) string<delimiter(')content(Plain text)delimiter(')>]
     
     ident(include) constant(Streamable)
delete[delete(-)]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) operator([)symbol(:plain)operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
delete[delete(-)      ident(text) operator(=) operator(()ident(scan_until)operator(()regexp<delimiter(/)char(\\z)delimiter(/)>operator(\)) operator(||) string<delimiter(')delimiter(')>operator(\))]
delete[delete(-)      ident(tokens) operator(<<) operator([)ident(text)operator(,) symbol(:plain)operator(])]
insert[insert(+)      ident(tokens) operator(<<) operator([)ident(string)operator(,) symbol(:plain)operator(])]
     keyword(end)
 
   keyword(end)
head[head(Index: )plain(lib/coderay/scanners/diff.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/diff.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/diff.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,105 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  keyword(class) class(Diff) operator(<) constant(Scanner)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:diff)]
insert[insert(+)    ident(title) string<delimiter(')content(diff output)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(line_kind) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ident(kind) operator(=) ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)          keyword(if) ident(line_kind)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:end_line)operator(,) ident(line_kind)operator(])]
insert[insert(+)            ident(line_kind) operator(=) predefined_constant(nil)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)          keyword(next)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(--- |)char(\\+)char(\\+)char(\\+)content( |=+|_+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:head)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:head)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(Index: |Property changes on: )delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:head)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:head)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(Added: )delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:head)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:head)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)            ident(state) operator(=) symbol(:added)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content( )delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:change)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:change)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content((@@\)((?>[^@)char(\\n)content(]*\)\)(@@\))delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:change)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(1)operator(])operator(,) symbol(:change)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(2)operator(])operator(,) symbol(:plain)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(3)operator(])operator(,) symbol(:change)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:insert)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:insert)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(-)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:delete)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:delete)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( .*)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:head)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(')content(else case rached)delimiter(')>]
insert[insert(+)          keyword(end)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:added)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(   )char(\\+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:begin_line)operator(,) ident(line_kind) operator(=) symbol(:insert)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:insert)operator(])]
insert[insert(+)            keyword(next) keyword(unless) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(.+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:plain)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens) operator(<<) operator([)symbol(:end_line)operator(,) ident(line_kind)operator(]) keyword(if) ident(line_kind)]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/json.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/json.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/json.rb)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,115 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)  ]
insert[insert(+)  comment(# Scanner for JSON (JavaScript Object Notation\).)]
insert[insert(+)  keyword(class) class(JSON) operator(<) constant(Scanner)]
insert[insert(+)    ]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ]
insert[insert(+)    ident(register_for) symbol(:json)]
insert[insert(+)    ident(file_extension) string<delimiter(')content(json)delimiter(')>]
insert[insert(+)    ]
insert[insert(+)    constant(KINDS_NOT_LOC) operator(=) operator([)]
insert[insert(+)      symbol(:float)operator(,) symbol(:char)operator(,) symbol(:content)operator(,) symbol(:delimiter)operator(,)]
insert[insert(+)      symbol(:error)operator(,) symbol(:integer)operator(,) symbol(:operator)operator(,) symbol(:value)operator(,)]
insert[insert(+)    operator(])  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(CONSTANTS) operator(=) string<delimiter(%w()content( true false null )delimiter(\))>  comment(# :nodoc:)]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:key)operator(\))operator(.)ident(add)operator(()constant(CONSTANTS)operator(,) symbol(:value)operator(\))  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)    constant(ESCAPE) operator(=) regexp<delimiter(/)content( [bfnrt)char(\\\\)content(")char(\\/)content(] )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    constant(UNICODE_ESCAPE) operator(=)  regexp<delimiter(/)content( u[a-fA-F0-9]{4} )delimiter(/)modifier(x)>  comment(# :nodoc:)]
insert[insert(+)    ]
insert[insert(+)  ident(protected)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)      ]
insert[insert(+)      ident(state) operator(=) symbol(:initial)]
insert[insert(+)      ident(stack) operator(=) operator([)operator(])]
insert[insert(+)      ident(string_delimiter) operator(=) predefined_constant(nil)]
insert[insert(+)      ident(key_expected) operator(=) predefined_constant(false)]
insert[insert(+)      ]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)        ]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)        ]
insert[insert(+)        keyword(case) ident(state)]
insert[insert(+)        ]
insert[insert(+)        keyword(when) symbol(:initial)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [:,)char(\\[)content({)char(\\])content(}] )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            keyword(case) ident(match)]
insert[insert(+)            keyword(when) string<delimiter(')content({)delimiter(')> keyword(then) ident(stack) operator(<<) symbol(:object)operator(;) ident(key_expected) operator(=) predefined_constant(true)]
insert[insert(+)            keyword(when) string<delimiter(')content([)delimiter(')> keyword(then) ident(stack) operator(<<) symbol(:array)]
insert[insert(+)            keyword(when) string<delimiter(')content(:)delimiter(')> keyword(then) ident(key_expected) operator(=) predefined_constant(false)]
insert[insert(+)            keyword(when) string<delimiter(')content(,)delimiter(')> keyword(then) ident(key_expected) operator(=) predefined_constant(true) keyword(if) ident(stack)operator(.)ident(last) operator(==) symbol(:object)]
insert[insert(+)            keyword(when) string<delimiter(')content(})delimiter(')>operator(,) string<delimiter(')content(])delimiter(')> keyword(then) ident(stack)operator(.)ident(pop)  comment(# no error recovery, but works for valid JSON)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( true | false | null )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(-?(?:0|[1-9])char(\\d)content(*\))delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\.)char(\\d)content(+(?:[eE][-+]?)char(\\d)content(+\)?|[eE][-+]?)char(\\d)content(+)delimiter(/)>operator(\))]
insert[insert(+)              ident(match) operator(<<) ident(matched)]
insert[insert(+)              ident(kind) operator(=) symbol(:float)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)            ident(state) operator(=) ident(key_expected) operator(?) symbol(:key) operator(:) symbol(:string)]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:open)operator(,) ident(state)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:delimiter)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(getch)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(when) symbol(:string)operator(,) symbol(:key)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)content([^)char(\\\\)content("]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)string<delimiter(')content(")delimiter(')>operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( (?: )inline<inline_delimiter(#{)constant(ESCAPE)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(UNICODE_ESCAPE)inline_delimiter(})>content( \) )delimiter(/)modifier(mox)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:char)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.)delimiter(/)modifier(m)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:content)]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( )char(\\\\)content( | $ )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:delimiter)operator(])]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)        keyword(else)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Unknown state)delimiter(')>operator(,) ident(tokens)]
insert[insert(+)          ]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($CODERAY_DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      keyword(if) operator([)symbol(:string)operator(,) symbol(:key)operator(])operator(.)ident(include?) ident(state)]
insert[insert(+)        ident(tokens) operator(<<) operator([)symbol(:close)operator(,) ident(state)operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/_map.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/_map.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay/scanners/_map.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,13 +1,20 )change(@@)]
 keyword(module) class(CodeRay)
 keyword(module) class(Scanners)
 
delete[delete(-)  ident(map) symbol(:cpp) operator(=)operator(>) symbol(:c)operator(,)]
insert[insert(+)  ident(map) \]
insert[insert(+)    symbol(:cplusplus) operator(=)operator(>) symbol(:cpp)operator(,)]
insert[insert(+)    symbol<symbol(:)delimiter(')content(c++)delimiter(')> operator(=)operator(>) symbol(:cpp)operator(,)]
insert[insert(+)    symbol(:ecmascript) operator(=)operator(>) symbol(:java_script)operator(,)]
insert[insert(+)    symbol(:ecma_script) operator(=)operator(>) symbol(:java_script)operator(,)]
insert[insert(+)    symbol(:irb) operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    symbol(:javascript) operator(=)operator(>) symbol(:java_script)operator(,)]
insert[insert(+)    symbol(:js) operator(=)operator(>) symbol(:java_script)operator(,)]
insert[insert(+)    symbol(:nitro) operator(=)operator(>) symbol(:nitro_xhtml)operator(,)]
insert[insert(+)    symbol(:pascal) operator(=)operator(>) symbol(:delphi)operator(,)]
insert[insert(+)    symbol(:patch) operator(=)operator(>) symbol(:diff)operator(,)]
     symbol(:plain) operator(=)operator(>) symbol(:plaintext)operator(,)
delete[delete(-)    symbol(:pascal) operator(=)operator(>) symbol(:delphi)operator(,)]
delete[delete(-)    symbol(:irb) operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    symbol(:xml) operator(=)operator(>) symbol(:html)operator(,)]
delete[delete(-)    symbol(:xhtml) operator(=)operator(>) symbol(:nitro_xhtml)operator(,)]
delete[delete(-)    symbol(:nitro) operator(=)operator(>) symbol(:nitro_xhtml)]
insert[insert(+)    symbol(:xhtml) operator(=)operator(>) symbol(:html)operator(,)]
insert[insert(+)    symbol(:yml) operator(=)operator(>) symbol(:yaml)]
 
   ident(default) symbol(:plain)
 
head[head(Index: )plain(lib/coderay.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay.rb)plain(	(revision 250\))]
head[head(+++ )filename(lib/coderay.rb)plain(	(revision 500\))]
change[change(@@)plain( -1,7 +1,5 )change(@@)]
 comment(# = CodeRay Library)
 comment(#)
delete[delete(-)comment(# $Id$)]
delete[delete(-)comment(#)]
 comment(# CodeRay is a Ruby library for syntax highlighting.)
 comment(#)
 comment(# I try to make CodeRay easy to use and intuitive, but at the same time fully featured, complete,)
change[change(@@)plain( -16,7 +14,7 )change(@@)]
 comment(# )
 comment(# Here's a fancy graphic to light up this gray docu:)
 comment(# )
delete[delete(-)comment(# http://)eyecatcher<comment(rd.cYcnus.de)>comment(/coderay/scheme.png)]
insert[insert(+)comment(# http://)eyecatcher<comment(cycnus.de/raindark)>comment(/coderay/scheme.png)]
 comment(# )
 comment(# == Documentation)
 comment(#)
change[change(@@)plain( -130,13 +128,14 )change(@@)]
 keyword(module) class(CodeRay)
 
   comment(# Version: Major.Minor.Teeny[.Revision])
delete[delete(-)  comment(# Major: 0 for pre-)eyecatcher<comment(releas)>comment(e)]
delete[delete(-)  comment(# Minor: )eyecatcher<comment(odd for beta, even for stabl)>comment(e)]
delete[delete(-)  comment(# Teeny: development state)]
delete[delete(-)  comment(# Revision: Subversion Revision number (generated on rake)comment(\))]
delete[delete(-)  constant(VERSION) operator(=) string<delimiter(')content(0.)>eyecatcher<string<content(7.9)>>string<delimiter(')>]
insert[insert(+)  comment(# Major: 0 for pre-)eyecatcher<comment(stable, 1 for stabl)>comment(e)]
insert[insert(+)  comment(# Minor: )eyecatcher<comment(feature mileston)>comment(e)]
insert[insert(+)  comment(# Teeny: development state)eyecatcher<comment(, 0 for pre-release)>]
insert[insert(+)  comment(# Revision: Subversion Revision number (generated on rake)eyecatcher<comment( gem:make)>comment(\))]
insert[insert(+)  constant(VERSION) operator(=) string<delimiter(')content(0.)>eyecatcher<string<content(9.1)>>string<delimiter(')>]
 
   ident(require) string<delimiter(')content(coderay/tokens)delimiter(')>
insert[insert(+)  ident(require) string<delimiter(')content(coderay/token_classes)delimiter(')>]
   ident(require) string<delimiter(')content(coderay/scanner)delimiter(')>
   ident(require) string<delimiter(')content(coderay/encoder)delimiter(')>
   ident(require) string<delimiter(')content(coderay/duo)delimiter(')>
head[head(Index: )plain(lib/README)]
head[head(===================================================================)]
head[head(--- )filename(lib/README)plain(	(revision 0\))]
head[head(+++ )filename(lib/README)plain(	(revision 500\))]
change[change(@@)plain( -0,0 +1,129 )change(@@)]
insert[insert(+)plain(= CodeRay)]
insert[insert(+)]
insert[insert(+)plain([- Tired of blue'n'gray? Try the original version of this documentation on)]
insert[insert(+)plain(coderay.rubychan.de[http://coderay.rubychan.de/doc/] (use Ctrl+Click to open it in its own frame.\) -])]
insert[insert(+)]
insert[insert(+)plain(== About)]
insert[insert(+)plain(CodeRay is a Ruby library for syntax highlighting.)]
insert[insert(+)]
insert[insert(+)plain(Syntax highlighting means: You put your code in, and you get it back colored;)]
insert[insert(+)plain(Keywords, strings, floats, comments - all in different colors.)]
insert[insert(+)plain(And with line numbers.)]
insert[insert(+)]
insert[insert(+)plain(*Syntax* *Highlighting*...)]
insert[insert(+)plain(* makes code easier to read and maintain)]
insert[insert(+)plain(* lets you detect syntax errors faster)]
insert[insert(+)plain(* helps you to understand the syntax of a language)]
insert[insert(+)plain(* looks nice)]
insert[insert(+)plain(* is what everybody should have on their website)]
insert[insert(+)plain(* solves all your problems and makes the girls run after you)]
insert[insert(+)]
insert[insert(+)plain(Version: 0.9.1)]
insert[insert(+)plain(Author:: murphy (Kornelius Kalnbach\))]
insert[insert(+)plain(Contact:: murphy rubychan de)]
insert[insert(+)plain(Website:: coderay.rubychan.de[http://coderay.rubychan.de])]
insert[insert(+)plain(License:: GNU LGPL; see LICENSE file in the main directory.)]
insert[insert(+)]
insert[insert(+)plain(== Installation)]
insert[insert(+)]
insert[insert(+)plain(You need RubyGems[http://rubyforge.org/frs/?group_id=126].)]
insert[insert(+)]
insert[insert(+)plain( % gem install coderay)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(=== Dependencies)]
insert[insert(+)]
insert[insert(+)plain(CodeRay needs Ruby 1.8.6 or later. It also runs with Ruby 1.9.1+ and JRuby 1.1+.)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Example Usage)]
insert[insert(+)plain((Forgive me, but this is not highlighted.\))]
insert[insert(+)]
insert[insert(+)plain( require 'coderay')]
insert[insert(+)plain( )]
insert[insert(+)plain( tokens = CodeRay.scan "puts 'Hello, world!'", :ruby)]
insert[insert(+)plain( page = tokens.html :line_numbers => :inline, :wrap => :page)]
insert[insert(+)plain( puts page)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Documentation)]
insert[insert(+)]
insert[insert(+)plain(See CodeRay.)]
insert[insert(+)]
insert[insert(+)plain(Please report errors in this documentation to <murphy rubychan de>.)]
insert[insert(+)]
insert[insert(+)]
insert[insert(+)plain(== Credits)]
insert[insert(+)]
insert[insert(+)plain(=== Special Thanks to)]
insert[insert(+)]
insert[insert(+)plain(* licenser (Heinz N. Gies\) for ending my QBasic career, inventing the Coder)]
insert[insert(+)plain(  project and the input/output plugin system.)]
insert[insert(+)plain(  CodeRay would not exist without him.)]
insert[insert(+)plain(* bovi (Daniel Bovensiepen\) for helping me out on various occasions.)]
insert[insert(+)]
insert[insert(+)plain(=== Thanks to)]
insert[insert(+)]
insert[insert(+)plain(* Caleb Clausen for writing RubyLexer (see)]
insert[insert(+)plain(  http://rubyforge.org/projects/rubylexer\) and lots of very interesting mail)]
insert[insert(+)plain(  traffic)]
insert[insert(+)plain(* birkenfeld (Georg Brandl\) and mitsuhiku (Arnim Ronacher\) for PyKleur, now pygments.)]
insert[insert(+)plain(  You guys rock!)]
insert[insert(+)plain(* Jamis Buck for writing Syntax (see http://rubyforge.org/projects/syntax\))]
insert[insert(+)plain(  I got some useful ideas from it.)]
insert[insert(+)plain(* Doug Kearns and everyone else who worked on ruby.vim - it not only helped me)]
insert[insert(+)plain(  coding CodeRay, but also gave me a wonderful target to reach for the Ruby)]
insert[insert(+)plain(  scanner.)]
insert[insert(+)plain(* everyone who uses CodeBB on http://www.rubyforen.de and http://www.python-forum.de)]
insert[insert(+)plain(* iGEL, magichisoka, manveru, WoNDo and everyone I forgot from rubyforen.de)]
insert[insert(+)plain(* Dethix from ruby-mine.de)]
insert[insert(+)plain(* zickzackw)]
insert[insert(+)plain(* Dookie (who is no longer with us...\) and Leonidas from http://www.python-forum.de)]
insert[insert(+)plain(* Andreas Schwarz for finding out that CaseIgnoringWordList was not case)]
insert[insert(+)plain(  ignoring! Such things really make you write tests.)]
insert[insert(+)plain(* closure for the first version of the Scheme scanner.)]
insert[insert(+)plain(* Stefan Walk for the first version of the JavaScript scanner.)]
insert[insert(+)plain(* Josh Goebel for another version of the JavaScript scanner and a Diff scanner.)]
insert[insert(+)plain(* Jonathan Younger for pointing out the licence confusion caused by wrong LICENSE file.)]
insert[insert(+)plain(* Jeremy Hinegardner for finding the shebang-on-empty-file bug in FileType.)]
insert[insert(+)plain(* Charles Oliver Nutter and Yehuda Katz for helping me benchmark CodeRay on JRuby.)]
insert[insert(+)plain(* Andreas Neuhaus for pointing out a markup bug in coderay/for_redcloth.)]
insert[insert(+)plain(* 0xf30fc7 for the FileType patch concerning Delphi file extensions.)]
insert[insert(+)plain(* The folks at redmine.org - thank you for using and fixing CodeRay!)]
insert[insert(+)plain(* matz and all Ruby gods and gurus)]
insert[insert(+)plain(* The inventors of: the computer, the internet, the true color display, HTML &)]
insert[insert(+)plain(  CSS, VIM, Ruby, pizza, microwaves, guitars, scouting, programming, anime, )]
insert[insert(+)plain(  manga, coke and green ice tea.)]
insert[insert(+)]
insert[insert(+)plain(Where would we be without all those people?)]
insert[insert(+)]
insert[insert(+)plain(=== Created using)]
insert[insert(+)]
insert[insert(+)plain(* Ruby[http://ruby-lang.org/])]
insert[insert(+)plain(* Chihiro (my Sony VAIO laptop\); Henrietta (my old MacBook\);)]
insert[insert(+)plain(  Triella, born Rico (my new MacBook\); as well as)]
insert[insert(+)plain(  Seras and Hikari (my PCs\))]
insert[insert(+)plain(* RDE[http://homepage2.nifty.com/sakazuki/rde_e.html],)]
insert[insert(+)plain(  VIM[http://vim.org] and TextMate[http://macromates.com])]
insert[insert(+)plain(* Subversion[http://subversion.tigris.org/])]
insert[insert(+)plain(* Redmine[http://redmine.org/])]
insert[insert(+)plain(* Firefox[http://www.mozilla.org/products/firefox/],)]
insert[insert(+)plain(  Firebug[http://getfirebug.com/], Safari[http://www.apple.com/safari/], and)]
insert[insert(+)plain(  Thunderbird[http://www.mozilla.org/products/thunderbird/])]
insert[insert(+)plain(* RubyGems[http://docs.rubygems.org/] and Rake[http://rake.rubyforge.org/])]
insert[insert(+)plain(* TortoiseSVN[http://tortoisesvn.tigris.org/] using Apache via)]
insert[insert(+)plain(  XAMPP[http://www.apachefriends.org/en/xampp.html])]
insert[insert(+)plain(* RDoc (though I'm quite unsatisfied with it\))]
insert[insert(+)plain(* Microsoft Windows (yes, I confess!\) and MacOS X)]
insert[insert(+)plain(* GNUWin32, MinGW and some other tools to make the shell under windows a bit)]
insert[insert(+)plain(  less useless)]
insert[insert(+)plain(* Term::ANSIColor[http://term-ansicolor.rubyforge.org/])]
insert[insert(+)plain(* PLEAC[http://pleac.sourceforge.net/] code examples)]
insert[insert(+)]
insert[insert(+)plain(=== Free)]
insert[insert(+)]
insert[insert(+)plain(* As you can see, CodeRay was created under heavy use of *free* software.)]
insert[insert(+)plain(* So CodeRay is also *free*.)]
insert[insert(+)plain(* If you use CodeRay to create software, think about making this software)]
insert[insert(+)plain(  *free*, too.)]
insert[insert(+)plain(* Thanks :\))]

head[head(Property changes on: )plain(lib/README)]
head[head(___________________________________________________________________)]
head[head(Added: )plain(svn:keywords)]
insert[insert(   +)plain( Id)]
head[head(Added: )plain(svn:mergeinfo)]

